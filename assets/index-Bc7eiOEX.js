var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField = (obj, key, value2) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
function isObject$2(obj) {
  return obj !== null && typeof obj === "object" && "constructor" in obj && obj.constructor === Object;
}
function extend$2(target = {}, src = {}) {
  Object.keys(src).forEach((key) => {
    if (typeof target[key] === "undefined")
      target[key] = src[key];
    else if (isObject$2(src[key]) && isObject$2(target[key]) && Object.keys(src[key]).length > 0) {
      extend$2(target[key], src[key]);
    }
  });
}
const ssrDocument = {
  body: {},
  addEventListener() {
  },
  removeEventListener() {
  },
  activeElement: {
    blur() {
    },
    nodeName: ""
  },
  querySelector() {
    return null;
  },
  querySelectorAll() {
    return [];
  },
  getElementById() {
    return null;
  },
  createEvent() {
    return {
      initEvent() {
      }
    };
  },
  createElement() {
    return {
      children: [],
      childNodes: [],
      style: {},
      setAttribute() {
      },
      getElementsByTagName() {
        return [];
      }
    };
  },
  createElementNS() {
    return {};
  },
  importNode() {
    return null;
  },
  location: {
    hash: "",
    host: "",
    hostname: "",
    href: "",
    origin: "",
    pathname: "",
    protocol: "",
    search: ""
  }
};
function getDocument() {
  const doc = typeof document !== "undefined" ? document : {};
  extend$2(doc, ssrDocument);
  return doc;
}
const ssrWindow = {
  document: ssrDocument,
  navigator: {
    userAgent: ""
  },
  location: {
    hash: "",
    host: "",
    hostname: "",
    href: "",
    origin: "",
    pathname: "",
    protocol: "",
    search: ""
  },
  history: {
    replaceState() {
    },
    pushState() {
    },
    go() {
    },
    back() {
    }
  },
  CustomEvent: function CustomEvent2() {
    return this;
  },
  addEventListener() {
  },
  removeEventListener() {
  },
  getComputedStyle() {
    return {
      getPropertyValue() {
        return "";
      }
    };
  },
  Image() {
  },
  Date() {
  },
  screen: {},
  setTimeout() {
  },
  clearTimeout() {
  },
  matchMedia() {
    return {};
  },
  requestAnimationFrame(callback) {
    if (typeof setTimeout === "undefined") {
      callback();
      return null;
    }
    return setTimeout(callback, 0);
  },
  cancelAnimationFrame(id2) {
    if (typeof setTimeout === "undefined") {
      return;
    }
    clearTimeout(id2);
  }
};
function getWindow() {
  const win = typeof window !== "undefined" ? window : {};
  extend$2(win, ssrWindow);
  return win;
}
function makeReactive(obj) {
  const proto = obj.__proto__;
  Object.defineProperty(obj, "__proto__", {
    get() {
      return proto;
    },
    set(value2) {
      proto.__proto__ = value2;
    }
  });
}
class Dom7 extends Array {
  constructor(items) {
    if (typeof items === "number") {
      super(items);
    } else {
      super(...items || []);
      makeReactive(this);
    }
  }
}
function arrayFlat(arr = []) {
  const res = [];
  arr.forEach((el) => {
    if (Array.isArray(el)) {
      res.push(...arrayFlat(el));
    } else {
      res.push(el);
    }
  });
  return res;
}
function arrayFilter(arr, callback) {
  return Array.prototype.filter.call(arr, callback);
}
function arrayUnique(arr) {
  const uniqueArray = [];
  for (let i = 0; i < arr.length; i += 1) {
    if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
  }
  return uniqueArray;
}
function toCamelCase$1(string) {
  return string.toLowerCase().replace(/-(.)/g, (match, group) => group.toUpperCase());
}
function qsa(selector, context) {
  if (typeof selector !== "string") {
    return [selector];
  }
  const a = [];
  const res = context.querySelectorAll(selector);
  for (let i = 0; i < res.length; i += 1) {
    a.push(res[i]);
  }
  return a;
}
function $$1(selector, context) {
  const window2 = getWindow();
  const document2 = getDocument();
  let arr = [];
  if (!context && selector instanceof Dom7) {
    return selector;
  }
  if (!selector) {
    return new Dom7(arr);
  }
  if (typeof selector === "string") {
    const html2 = selector.trim();
    if (html2.indexOf("<") >= 0 && html2.indexOf(">") >= 0) {
      let toCreate = "div";
      if (html2.indexOf("<li") === 0) toCreate = "ul";
      if (html2.indexOf("<tr") === 0) toCreate = "tbody";
      if (html2.indexOf("<td") === 0 || html2.indexOf("<th") === 0) toCreate = "tr";
      if (html2.indexOf("<tbody") === 0) toCreate = "table";
      if (html2.indexOf("<option") === 0) toCreate = "select";
      const tempParent = document2.createElement(toCreate);
      tempParent.innerHTML = html2;
      for (let i = 0; i < tempParent.childNodes.length; i += 1) {
        arr.push(tempParent.childNodes[i]);
      }
    } else {
      arr = qsa(selector.trim(), context || document2);
    }
  } else if (selector.nodeType || selector === window2 || selector === document2) {
    arr.push(selector);
  } else if (Array.isArray(selector)) {
    if (selector instanceof Dom7) return selector;
    arr = selector;
  }
  return new Dom7(arrayUnique(arr));
}
$$1.fn = Dom7.prototype;
function addClass(...classes) {
  const classNames2 = arrayFlat(classes.map((c) => c.split(" ")));
  this.forEach((el) => {
    el.classList.add(...classNames2);
  });
  return this;
}
function removeClass(...classes) {
  const classNames2 = arrayFlat(classes.map((c) => c.split(" ")));
  this.forEach((el) => {
    el.classList.remove(...classNames2);
  });
  return this;
}
function toggleClass(...classes) {
  const classNames2 = arrayFlat(classes.map((c) => c.split(" ")));
  this.forEach((el) => {
    classNames2.forEach((className) => {
      el.classList.toggle(className);
    });
  });
}
function hasClass(...classes) {
  const classNames2 = arrayFlat(classes.map((c) => c.split(" ")));
  return arrayFilter(this, (el) => {
    return classNames2.filter((className) => el.classList.contains(className)).length > 0;
  }).length > 0;
}
function attr$1(attrs, value2) {
  if (arguments.length === 1 && typeof attrs === "string") {
    if (this[0]) return this[0].getAttribute(attrs);
    return void 0;
  }
  for (let i = 0; i < this.length; i += 1) {
    if (arguments.length === 2) {
      this[i].setAttribute(attrs, value2);
    } else {
      for (const attrName in attrs) {
        this[i][attrName] = attrs[attrName];
        this[i].setAttribute(attrName, attrs[attrName]);
      }
    }
  }
  return this;
}
function removeAttr(attr2) {
  for (let i = 0; i < this.length; i += 1) {
    this[i].removeAttribute(attr2);
  }
  return this;
}
function prop(props, value2) {
  if (arguments.length === 1 && typeof props === "string") {
    if (this[0]) return this[0][props];
  } else {
    for (let i = 0; i < this.length; i += 1) {
      if (arguments.length === 2) {
        this[i][props] = value2;
      } else {
        for (const propName in props) {
          this[i][propName] = props[propName];
        }
      }
    }
    return this;
  }
  return this;
}
function data(key, value2) {
  let el;
  if (typeof value2 === "undefined") {
    el = this[0];
    if (!el) return void 0;
    if (el.dom7ElementDataStorage && key in el.dom7ElementDataStorage) {
      return el.dom7ElementDataStorage[key];
    }
    const dataKey = el.getAttribute(`data-${key}`);
    if (dataKey) {
      return dataKey;
    }
    return void 0;
  }
  for (let i = 0; i < this.length; i += 1) {
    el = this[i];
    if (!el.dom7ElementDataStorage) el.dom7ElementDataStorage = {};
    el.dom7ElementDataStorage[key] = value2;
  }
  return this;
}
function removeData(key) {
  for (let i = 0; i < this.length; i += 1) {
    const el = this[i];
    if (el.dom7ElementDataStorage && el.dom7ElementDataStorage[key]) {
      el.dom7ElementDataStorage[key] = null;
      delete el.dom7ElementDataStorage[key];
    }
  }
}
function dataset() {
  const el = this[0];
  if (!el) return void 0;
  const dataset2 = {};
  if (el.dataset) {
    for (const dataKey in el.dataset) {
      dataset2[dataKey] = el.dataset[dataKey];
    }
  } else {
    for (let i = 0; i < el.attributes.length; i += 1) {
      const attr2 = el.attributes[i];
      if (attr2.name.indexOf("data-") >= 0) {
        dataset2[toCamelCase$1(attr2.name.split("data-")[1])] = attr2.value;
      }
    }
  }
  for (const key in dataset2) {
    if (dataset2[key] === "false") dataset2[key] = false;
    else if (dataset2[key] === "true") dataset2[key] = true;
    else if (parseFloat(dataset2[key]) === dataset2[key] * 1) dataset2[key] *= 1;
  }
  return dataset2;
}
function val(value2) {
  if (typeof value2 === "undefined") {
    const el = this[0];
    if (!el) return void 0;
    if (el.multiple && el.nodeName.toLowerCase() === "select") {
      const values = [];
      for (let i = 0; i < el.selectedOptions.length; i += 1) {
        values.push(el.selectedOptions[i].value);
      }
      return values;
    }
    return el.value;
  }
  for (let i = 0; i < this.length; i += 1) {
    const el = this[i];
    if (Array.isArray(value2) && el.multiple && el.nodeName.toLowerCase() === "select") {
      for (let j = 0; j < el.options.length; j += 1) {
        el.options[j].selected = value2.indexOf(el.options[j].value) >= 0;
      }
    } else {
      el.value = value2;
    }
  }
  return this;
}
function value(value2) {
  return this.val(value2);
}
function transform(transform2) {
  for (let i = 0; i < this.length; i += 1) {
    this[i].style.transform = transform2;
  }
  return this;
}
function transition(duration) {
  for (let i = 0; i < this.length; i += 1) {
    this[i].style.transitionDuration = typeof duration !== "string" ? `${duration}ms` : duration;
  }
  return this;
}
function on(...args) {
  let [eventType, targetSelector, listener, capture] = args;
  if (typeof args[1] === "function") {
    [eventType, listener, capture] = args;
    targetSelector = void 0;
  }
  if (!capture) capture = false;
  function handleLiveEvent(e) {
    const target = e.target;
    if (!target) return;
    const eventData = e.target.dom7EventData || [];
    if (eventData.indexOf(e) < 0) {
      eventData.unshift(e);
    }
    if ($$1(target).is(targetSelector)) listener.apply(target, eventData);
    else {
      const parents2 = $$1(target).parents();
      for (let k = 0; k < parents2.length; k += 1) {
        if ($$1(parents2[k]).is(targetSelector)) listener.apply(parents2[k], eventData);
      }
    }
  }
  function handleEvent2(e) {
    const eventData = e && e.target ? e.target.dom7EventData || [] : [];
    if (eventData.indexOf(e) < 0) {
      eventData.unshift(e);
    }
    listener.apply(this, eventData);
  }
  const events = eventType.split(" ");
  let j;
  for (let i = 0; i < this.length; i += 1) {
    const el = this[i];
    if (!targetSelector) {
      for (j = 0; j < events.length; j += 1) {
        const event = events[j];
        if (!el.dom7Listeners) el.dom7Listeners = {};
        if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
        el.dom7Listeners[event].push({
          listener,
          proxyListener: handleEvent2
        });
        el.addEventListener(event, handleEvent2, capture);
      }
    } else {
      for (j = 0; j < events.length; j += 1) {
        const event = events[j];
        if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
        if (!el.dom7LiveListeners[event]) el.dom7LiveListeners[event] = [];
        el.dom7LiveListeners[event].push({
          listener,
          proxyListener: handleLiveEvent
        });
        el.addEventListener(event, handleLiveEvent, capture);
      }
    }
  }
  return this;
}
function off(...args) {
  let [eventType, targetSelector, listener, capture] = args;
  if (typeof args[1] === "function") {
    [eventType, listener, capture] = args;
    targetSelector = void 0;
  }
  if (!capture) capture = false;
  const events = eventType.split(" ");
  for (let i = 0; i < events.length; i += 1) {
    const event = events[i];
    for (let j = 0; j < this.length; j += 1) {
      const el = this[j];
      let handlers;
      if (!targetSelector && el.dom7Listeners) {
        handlers = el.dom7Listeners[event];
      } else if (targetSelector && el.dom7LiveListeners) {
        handlers = el.dom7LiveListeners[event];
      }
      if (handlers && handlers.length) {
        for (let k = handlers.length - 1; k >= 0; k -= 1) {
          const handler = handlers[k];
          if (listener && handler.listener === listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          } else if (!listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          }
        }
      }
    }
  }
  return this;
}
function once(...args) {
  const dom = this;
  let [eventName, targetSelector, listener, capture] = args;
  if (typeof args[1] === "function") {
    [eventName, listener, capture] = args;
    targetSelector = void 0;
  }
  function onceHandler(...eventArgs) {
    listener.apply(this, eventArgs);
    dom.off(eventName, targetSelector, onceHandler, capture);
    if (onceHandler.dom7proxy) {
      delete onceHandler.dom7proxy;
    }
  }
  onceHandler.dom7proxy = listener;
  return dom.on(eventName, targetSelector, onceHandler, capture);
}
function trigger(...args) {
  const window2 = getWindow();
  const events = args[0].split(" ");
  const eventData = args[1];
  for (let i = 0; i < events.length; i += 1) {
    const event = events[i];
    for (let j = 0; j < this.length; j += 1) {
      const el = this[j];
      if (window2.CustomEvent) {
        const evt = new window2.CustomEvent(event, {
          detail: eventData,
          bubbles: true,
          cancelable: true
        });
        el.dom7EventData = args.filter((data2, dataIndex) => dataIndex > 0);
        el.dispatchEvent(evt);
        el.dom7EventData = [];
        delete el.dom7EventData;
      }
    }
  }
  return this;
}
function transitionStart(callback) {
  const dom = this;
  function fireCallBack(e) {
    if (e.target !== this) return;
    callback.call(this, e);
    dom.off("transitionstart", fireCallBack);
  }
  if (callback) {
    dom.on("transitionstart", fireCallBack);
  }
  return this;
}
function transitionEnd(callback) {
  const dom = this;
  function fireCallBack(e) {
    if (e.target !== this) return;
    callback.call(this, e);
    dom.off("transitionend", fireCallBack);
  }
  if (callback) {
    dom.on("transitionend", fireCallBack);
  }
  return this;
}
function animationEnd(callback) {
  const dom = this;
  function fireCallBack(e) {
    if (e.target !== this) return;
    callback.call(this, e);
    dom.off("animationend", fireCallBack);
  }
  if (callback) {
    dom.on("animationend", fireCallBack);
  }
  return this;
}
function width() {
  const window2 = getWindow();
  if (this[0] === window2) {
    return window2.innerWidth;
  }
  if (this.length > 0) {
    return parseFloat(this.css("width"));
  }
  return null;
}
function outerWidth(includeMargins) {
  if (this.length > 0) {
    if (includeMargins) {
      const styles2 = this.styles();
      return this[0].offsetWidth + parseFloat(styles2.getPropertyValue("margin-right")) + parseFloat(styles2.getPropertyValue("margin-left"));
    }
    return this[0].offsetWidth;
  }
  return null;
}
function height() {
  const window2 = getWindow();
  if (this[0] === window2) {
    return window2.innerHeight;
  }
  if (this.length > 0) {
    return parseFloat(this.css("height"));
  }
  return null;
}
function outerHeight(includeMargins) {
  if (this.length > 0) {
    if (includeMargins) {
      const styles2 = this.styles();
      return this[0].offsetHeight + parseFloat(styles2.getPropertyValue("margin-top")) + parseFloat(styles2.getPropertyValue("margin-bottom"));
    }
    return this[0].offsetHeight;
  }
  return null;
}
function offset() {
  if (this.length > 0) {
    const window2 = getWindow();
    const document2 = getDocument();
    const el = this[0];
    const box = el.getBoundingClientRect();
    const body = document2.body;
    const clientTop = el.clientTop || body.clientTop || 0;
    const clientLeft = el.clientLeft || body.clientLeft || 0;
    const scrollTop2 = el === window2 ? window2.scrollY : el.scrollTop;
    const scrollLeft2 = el === window2 ? window2.scrollX : el.scrollLeft;
    return {
      top: box.top + scrollTop2 - clientTop,
      left: box.left + scrollLeft2 - clientLeft
    };
  }
  return null;
}
function hide() {
  for (let i = 0; i < this.length; i += 1) {
    this[i].style.display = "none";
  }
  return this;
}
function show() {
  const window2 = getWindow();
  for (let i = 0; i < this.length; i += 1) {
    const el = this[i];
    if (el.style.display === "none") {
      el.style.display = "";
    }
    if (window2.getComputedStyle(el, null).getPropertyValue("display") === "none") {
      el.style.display = "block";
    }
  }
  return this;
}
function styles() {
  const window2 = getWindow();
  if (this[0]) return window2.getComputedStyle(this[0], null);
  return {};
}
function css(props, value2) {
  const window2 = getWindow();
  let i;
  if (arguments.length === 1) {
    if (typeof props === "string") {
      if (this[0]) return window2.getComputedStyle(this[0], null).getPropertyValue(props);
    } else {
      for (i = 0; i < this.length; i += 1) {
        for (const prop2 in props) {
          this[i].style[prop2] = props[prop2];
        }
      }
      return this;
    }
  }
  if (arguments.length === 2 && typeof props === "string") {
    for (i = 0; i < this.length; i += 1) {
      this[i].style[props] = value2;
    }
    return this;
  }
  return this;
}
function each(callback) {
  if (!callback) return this;
  this.forEach((el, index2) => {
    callback.apply(el, [el, index2]);
  });
  return this;
}
function filter(callback) {
  const result = arrayFilter(this, callback);
  return $$1(result);
}
function html(html2) {
  if (typeof html2 === "undefined") {
    return this[0] ? this[0].innerHTML : null;
  }
  for (let i = 0; i < this.length; i += 1) {
    this[i].innerHTML = html2;
  }
  return this;
}
function text$1(text2) {
  if (typeof text2 === "undefined") {
    return this[0] ? this[0].textContent.trim() : null;
  }
  for (let i = 0; i < this.length; i += 1) {
    this[i].textContent = text2;
  }
  return this;
}
function is(selector) {
  const window2 = getWindow();
  const document2 = getDocument();
  const el = this[0];
  let compareWith;
  let i;
  if (!el || typeof selector === "undefined") return false;
  if (typeof selector === "string") {
    if (el.matches) return el.matches(selector);
    if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
    if (el.msMatchesSelector) return el.msMatchesSelector(selector);
    compareWith = $$1(selector);
    for (i = 0; i < compareWith.length; i += 1) {
      if (compareWith[i] === el) return true;
    }
    return false;
  }
  if (selector === document2) {
    return el === document2;
  }
  if (selector === window2) {
    return el === window2;
  }
  if (selector.nodeType || selector instanceof Dom7) {
    compareWith = selector.nodeType ? [selector] : selector;
    for (i = 0; i < compareWith.length; i += 1) {
      if (compareWith[i] === el) return true;
    }
    return false;
  }
  return false;
}
function index() {
  let child = this[0];
  let i;
  if (child) {
    i = 0;
    while ((child = child.previousSibling) !== null) {
      if (child.nodeType === 1) i += 1;
    }
    return i;
  }
  return void 0;
}
function eq(index2) {
  if (typeof index2 === "undefined") return this;
  const length = this.length;
  if (index2 > length - 1) {
    return $$1([]);
  }
  if (index2 < 0) {
    const returnIndex = length + index2;
    if (returnIndex < 0) return $$1([]);
    return $$1([this[returnIndex]]);
  }
  return $$1([this[index2]]);
}
function append$1(...els) {
  let newChild;
  const document2 = getDocument();
  for (let k = 0; k < els.length; k += 1) {
    newChild = els[k];
    for (let i = 0; i < this.length; i += 1) {
      if (typeof newChild === "string") {
        const tempDiv = document2.createElement("div");
        tempDiv.innerHTML = newChild;
        while (tempDiv.firstChild) {
          this[i].appendChild(tempDiv.firstChild);
        }
      } else if (newChild instanceof Dom7) {
        for (let j = 0; j < newChild.length; j += 1) {
          this[i].appendChild(newChild[j]);
        }
      } else {
        this[i].appendChild(newChild);
      }
    }
  }
  return this;
}
function appendTo(parent2) {
  $$1(parent2).append(this);
  return this;
}
function prepend(newChild) {
  const document2 = getDocument();
  let i;
  let j;
  for (i = 0; i < this.length; i += 1) {
    if (typeof newChild === "string") {
      const tempDiv = document2.createElement("div");
      tempDiv.innerHTML = newChild;
      for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
        this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
      }
    } else if (newChild instanceof Dom7) {
      for (j = 0; j < newChild.length; j += 1) {
        this[i].insertBefore(newChild[j], this[i].childNodes[0]);
      }
    } else {
      this[i].insertBefore(newChild, this[i].childNodes[0]);
    }
  }
  return this;
}
function prependTo(parent2) {
  $$1(parent2).prepend(this);
  return this;
}
function insertBefore$1(selector) {
  const before = $$1(selector);
  for (let i = 0; i < this.length; i += 1) {
    if (before.length === 1) {
      before[0].parentNode.insertBefore(this[i], before[0]);
    } else if (before.length > 1) {
      for (let j = 0; j < before.length; j += 1) {
        before[j].parentNode.insertBefore(this[i].cloneNode(true), before[j]);
      }
    }
  }
}
function insertAfter(selector) {
  const after = $$1(selector);
  for (let i = 0; i < this.length; i += 1) {
    if (after.length === 1) {
      after[0].parentNode.insertBefore(this[i], after[0].nextSibling);
    } else if (after.length > 1) {
      for (let j = 0; j < after.length; j += 1) {
        after[j].parentNode.insertBefore(this[i].cloneNode(true), after[j].nextSibling);
      }
    }
  }
}
function next(selector) {
  if (this.length > 0) {
    if (selector) {
      if (this[0].nextElementSibling && $$1(this[0].nextElementSibling).is(selector)) {
        return $$1([this[0].nextElementSibling]);
      }
      return $$1([]);
    }
    if (this[0].nextElementSibling) return $$1([this[0].nextElementSibling]);
    return $$1([]);
  }
  return $$1([]);
}
function nextAll(selector) {
  const nextEls = [];
  let el = this[0];
  if (!el) return $$1([]);
  while (el.nextElementSibling) {
    const next2 = el.nextElementSibling;
    if (selector) {
      if ($$1(next2).is(selector)) nextEls.push(next2);
    } else nextEls.push(next2);
    el = next2;
  }
  return $$1(nextEls);
}
function prev(selector) {
  if (this.length > 0) {
    const el = this[0];
    if (selector) {
      if (el.previousElementSibling && $$1(el.previousElementSibling).is(selector)) {
        return $$1([el.previousElementSibling]);
      }
      return $$1([]);
    }
    if (el.previousElementSibling) return $$1([el.previousElementSibling]);
    return $$1([]);
  }
  return $$1([]);
}
function prevAll(selector) {
  const prevEls = [];
  let el = this[0];
  if (!el) return $$1([]);
  while (el.previousElementSibling) {
    const prev2 = el.previousElementSibling;
    if (selector) {
      if ($$1(prev2).is(selector)) prevEls.push(prev2);
    } else prevEls.push(prev2);
    el = prev2;
  }
  return $$1(prevEls);
}
function siblings(selector) {
  return this.nextAll(selector).add(this.prevAll(selector));
}
function parent(selector) {
  const parents2 = [];
  for (let i = 0; i < this.length; i += 1) {
    if (this[i].parentNode !== null) {
      if (selector) {
        if ($$1(this[i].parentNode).is(selector)) parents2.push(this[i].parentNode);
      } else {
        parents2.push(this[i].parentNode);
      }
    }
  }
  return $$1(parents2);
}
function parents(selector) {
  const parents2 = [];
  for (let i = 0; i < this.length; i += 1) {
    let parent2 = this[i].parentNode;
    while (parent2) {
      if (selector) {
        if ($$1(parent2).is(selector)) parents2.push(parent2);
      } else {
        parents2.push(parent2);
      }
      parent2 = parent2.parentNode;
    }
  }
  return $$1(parents2);
}
function closest(selector) {
  let closest2 = this;
  if (typeof selector === "undefined") {
    return $$1([]);
  }
  if (!closest2.is(selector)) {
    closest2 = closest2.parents(selector).eq(0);
  }
  return closest2;
}
function find(selector) {
  const foundElements = [];
  for (let i = 0; i < this.length; i += 1) {
    const found = this[i].querySelectorAll(selector);
    for (let j = 0; j < found.length; j += 1) {
      foundElements.push(found[j]);
    }
  }
  return $$1(foundElements);
}
function children$1(selector) {
  const children2 = [];
  for (let i = 0; i < this.length; i += 1) {
    const childNodes = this[i].children;
    for (let j = 0; j < childNodes.length; j += 1) {
      if (!selector || $$1(childNodes[j]).is(selector)) {
        children2.push(childNodes[j]);
      }
    }
  }
  return $$1(children2);
}
function remove() {
  for (let i = 0; i < this.length; i += 1) {
    if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
  }
  return this;
}
function detach$1() {
  return this.remove();
}
function add(...els) {
  const dom = this;
  let i;
  let j;
  for (i = 0; i < els.length; i += 1) {
    const toAdd = $$1(els[i]);
    for (j = 0; j < toAdd.length; j += 1) {
      dom.push(toAdd[j]);
    }
  }
  return dom;
}
function empty$1() {
  for (let i = 0; i < this.length; i += 1) {
    const el = this[i];
    if (el.nodeType === 1) {
      for (let j = 0; j < el.childNodes.length; j += 1) {
        if (el.childNodes[j].parentNode) {
          el.childNodes[j].parentNode.removeChild(el.childNodes[j]);
        }
      }
      el.textContent = "";
    }
  }
  return this;
}
function scrollTo(...args) {
  const window2 = getWindow();
  let [left, top, duration, easing, callback] = args;
  if (args.length === 4 && typeof easing === "function") {
    callback = easing;
    [left, top, duration, callback, easing] = args;
  }
  if (typeof easing === "undefined") easing = "swing";
  return this.each(function animate2() {
    const el = this;
    let currentTop;
    let currentLeft;
    let maxTop;
    let maxLeft;
    let newTop;
    let newLeft;
    let scrollTop2;
    let scrollLeft2;
    let animateTop = top > 0 || top === 0;
    let animateLeft = left > 0 || left === 0;
    if (typeof easing === "undefined") {
      easing = "swing";
    }
    if (animateTop) {
      currentTop = el.scrollTop;
      if (!duration) {
        el.scrollTop = top;
      }
    }
    if (animateLeft) {
      currentLeft = el.scrollLeft;
      if (!duration) {
        el.scrollLeft = left;
      }
    }
    if (!duration) return;
    if (animateTop) {
      maxTop = el.scrollHeight - el.offsetHeight;
      newTop = Math.max(Math.min(top, maxTop), 0);
    }
    if (animateLeft) {
      maxLeft = el.scrollWidth - el.offsetWidth;
      newLeft = Math.max(Math.min(left, maxLeft), 0);
    }
    let startTime = null;
    if (animateTop && newTop === currentTop) animateTop = false;
    if (animateLeft && newLeft === currentLeft) animateLeft = false;
    function render(time = (/* @__PURE__ */ new Date()).getTime()) {
      if (startTime === null) {
        startTime = time;
      }
      const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
      const easeProgress = easing === "linear" ? progress : 0.5 - Math.cos(progress * Math.PI) / 2;
      let done;
      if (animateTop) scrollTop2 = currentTop + easeProgress * (newTop - currentTop);
      if (animateLeft) scrollLeft2 = currentLeft + easeProgress * (newLeft - currentLeft);
      if (animateTop && newTop > currentTop && scrollTop2 >= newTop) {
        el.scrollTop = newTop;
        done = true;
      }
      if (animateTop && newTop < currentTop && scrollTop2 <= newTop) {
        el.scrollTop = newTop;
        done = true;
      }
      if (animateLeft && newLeft > currentLeft && scrollLeft2 >= newLeft) {
        el.scrollLeft = newLeft;
        done = true;
      }
      if (animateLeft && newLeft < currentLeft && scrollLeft2 <= newLeft) {
        el.scrollLeft = newLeft;
        done = true;
      }
      if (done) {
        if (callback) callback();
        return;
      }
      if (animateTop) el.scrollTop = scrollTop2;
      if (animateLeft) el.scrollLeft = scrollLeft2;
      window2.requestAnimationFrame(render);
    }
    window2.requestAnimationFrame(render);
  });
}
function scrollTop(...args) {
  let [top, duration, easing, callback] = args;
  if (args.length === 3 && typeof easing === "function") {
    [top, duration, callback, easing] = args;
  }
  const dom = this;
  if (typeof top === "undefined") {
    if (dom.length > 0) return dom[0].scrollTop;
    return null;
  }
  return dom.scrollTo(void 0, top, duration, easing, callback);
}
function scrollLeft(...args) {
  let [left, duration, easing, callback] = args;
  if (args.length === 3 && typeof easing === "function") {
    [left, duration, callback, easing] = args;
  }
  const dom = this;
  if (typeof left === "undefined") {
    if (dom.length > 0) return dom[0].scrollLeft;
    return null;
  }
  return dom.scrollTo(left, void 0, duration, easing, callback);
}
function animate(initialProps, initialParams) {
  const window2 = getWindow();
  const els = this;
  const a = {
    props: Object.assign({}, initialProps),
    params: Object.assign({
      duration: 300,
      easing: "swing"
      // or 'linear'
      /* Callbacks
      begin(elements)
      complete(elements)
      progress(elements, complete, remaining, start, tweenValue)
      */
    }, initialParams),
    elements: els,
    animating: false,
    que: [],
    easingProgress(easing, progress) {
      if (easing === "swing") {
        return 0.5 - Math.cos(progress * Math.PI) / 2;
      }
      if (typeof easing === "function") {
        return easing(progress);
      }
      return progress;
    },
    stop() {
      if (a.frameId) {
        window2.cancelAnimationFrame(a.frameId);
      }
      a.animating = false;
      a.elements.each((el) => {
        const element2 = el;
        delete element2.dom7AnimateInstance;
      });
      a.que = [];
    },
    done(complete) {
      a.animating = false;
      a.elements.each((el) => {
        const element2 = el;
        delete element2.dom7AnimateInstance;
      });
      if (complete) complete(els);
      if (a.que.length > 0) {
        const que = a.que.shift();
        a.animate(que[0], que[1]);
      }
    },
    animate(props, params) {
      if (a.animating) {
        a.que.push([props, params]);
        return a;
      }
      const elements = [];
      a.elements.each((el, index2) => {
        let initialFullValue;
        let initialValue;
        let unit;
        let finalValue;
        let finalFullValue;
        if (!el.dom7AnimateInstance) a.elements[index2].dom7AnimateInstance = a;
        elements[index2] = {
          container: el
        };
        Object.keys(props).forEach((prop2) => {
          initialFullValue = window2.getComputedStyle(el, null).getPropertyValue(prop2).replace(",", ".");
          initialValue = parseFloat(initialFullValue);
          unit = initialFullValue.replace(initialValue, "");
          finalValue = parseFloat(props[prop2]);
          finalFullValue = props[prop2] + unit;
          elements[index2][prop2] = {
            initialFullValue,
            initialValue,
            unit,
            finalValue,
            finalFullValue,
            currentValue: initialValue
          };
        });
      });
      let startTime = null;
      let time;
      let elementsDone = 0;
      let propsDone = 0;
      let done;
      let began = false;
      a.animating = true;
      function render() {
        time = (/* @__PURE__ */ new Date()).getTime();
        let progress;
        let easeProgress;
        if (!began) {
          began = true;
          if (params.begin) params.begin(els);
        }
        if (startTime === null) {
          startTime = time;
        }
        if (params.progress) {
          params.progress(els, Math.max(Math.min((time - startTime) / params.duration, 1), 0), startTime + params.duration - time < 0 ? 0 : startTime + params.duration - time, startTime);
        }
        elements.forEach((element2) => {
          const el = element2;
          if (done || el.done) return;
          Object.keys(props).forEach((prop2) => {
            if (done || el.done) return;
            progress = Math.max(Math.min((time - startTime) / params.duration, 1), 0);
            easeProgress = a.easingProgress(params.easing, progress);
            const {
              initialValue,
              finalValue,
              unit
            } = el[prop2];
            el[prop2].currentValue = initialValue + easeProgress * (finalValue - initialValue);
            const currentValue = el[prop2].currentValue;
            if (finalValue > initialValue && currentValue >= finalValue || finalValue < initialValue && currentValue <= finalValue) {
              el.container.style[prop2] = finalValue + unit;
              propsDone += 1;
              if (propsDone === Object.keys(props).length) {
                el.done = true;
                elementsDone += 1;
              }
              if (elementsDone === elements.length) {
                done = true;
              }
            }
            if (done) {
              a.done(params.complete);
              return;
            }
            el.container.style[prop2] = currentValue + unit;
          });
        });
        if (done) return;
        a.frameId = window2.requestAnimationFrame(render);
      }
      a.frameId = window2.requestAnimationFrame(render);
      return a;
    }
  };
  if (a.elements.length === 0) {
    return els;
  }
  let animateInstance;
  for (let i = 0; i < a.elements.length; i += 1) {
    if (a.elements[i].dom7AnimateInstance) {
      animateInstance = a.elements[i].dom7AnimateInstance;
    } else a.elements[i].dom7AnimateInstance = a;
  }
  if (!animateInstance) {
    animateInstance = a;
  }
  if (initialProps === "stop") {
    animateInstance.stop();
  } else {
    animateInstance.animate(a.props, a.params);
  }
  return els;
}
function stop() {
  const els = this;
  for (let i = 0; i < els.length; i += 1) {
    if (els[i].dom7AnimateInstance) {
      els[i].dom7AnimateInstance.stop();
    }
  }
}
const noTrigger = "resize scroll".split(" ");
function shortcut(name) {
  function eventHandler(...args) {
    if (typeof args[0] === "undefined") {
      for (let i = 0; i < this.length; i += 1) {
        if (noTrigger.indexOf(name) < 0) {
          if (name in this[i]) this[i][name]();
          else {
            $$1(this[i]).trigger(name);
          }
        }
      }
      return this;
    }
    return this.on(name, ...args);
  }
  return eventHandler;
}
const click = shortcut("click");
const blur = shortcut("blur");
const focus = shortcut("focus");
const focusin = shortcut("focusin");
const focusout = shortcut("focusout");
const keyup = shortcut("keyup");
const keydown = shortcut("keydown");
const keypress = shortcut("keypress");
const submit = shortcut("submit");
const change = shortcut("change");
const mousedown = shortcut("mousedown");
const mousemove = shortcut("mousemove");
const mouseup = shortcut("mouseup");
const mouseenter = shortcut("mouseenter");
const mouseleave = shortcut("mouseleave");
const mouseout = shortcut("mouseout");
const mouseover = shortcut("mouseover");
const touchstart = shortcut("touchstart");
const touchend = shortcut("touchend");
const touchmove = shortcut("touchmove");
const resize = shortcut("resize");
const scroll = shortcut("scroll");
const methods = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  $: $$1,
  add,
  addClass,
  animate,
  animationEnd,
  append: append$1,
  appendTo,
  attr: attr$1,
  blur,
  change,
  children: children$1,
  click,
  closest,
  css,
  data,
  dataset,
  default: $$1,
  detach: detach$1,
  each,
  empty: empty$1,
  eq,
  filter,
  find,
  focus,
  focusin,
  focusout,
  hasClass,
  height,
  hide,
  html,
  index,
  insertAfter,
  insertBefore: insertBefore$1,
  is,
  keydown,
  keypress,
  keyup,
  mousedown,
  mouseenter,
  mouseleave,
  mousemove,
  mouseout,
  mouseover,
  mouseup,
  next,
  nextAll,
  off,
  offset,
  on,
  once,
  outerHeight,
  outerWidth,
  parent,
  parents,
  prepend,
  prependTo,
  prev,
  prevAll,
  prop,
  remove,
  removeAttr,
  removeClass,
  removeData,
  resize,
  scroll,
  scrollLeft,
  scrollTo,
  scrollTop,
  show,
  siblings,
  stop,
  styles,
  submit,
  text: text$1,
  toggleClass,
  touchend,
  touchmove,
  touchstart,
  transform,
  transition,
  transitionEnd,
  transitionStart,
  trigger,
  val,
  value,
  width
}, Symbol.toStringTag, { value: "Module" }));
Object.keys(methods).forEach((methodName) => {
  if (methodName === "$") return;
  $$1.fn[methodName] = methods[methodName];
});
const $ = $$1;
function signum(num) {
  return num < 0 ? -1 : 0 === num ? 0 : 1;
}
function lerp(start, stop2, amount) {
  return (1 - amount) * start + amount * stop2;
}
function clampInt(min, max, input) {
  return input < min ? min : input > max ? max : input;
}
function clampDouble(min, max, input) {
  return input < min ? min : input > max ? max : input;
}
function sanitizeDegreesDouble(degrees) {
  return (degrees %= 360) < 0 && (degrees += 360), degrees;
}
function rotationDirection(from, to) {
  return sanitizeDegreesDouble(to - from) <= 180 ? 1 : -1;
}
function differenceDegrees(a, b) {
  return 180 - Math.abs(Math.abs(a - b) - 180);
}
function matrixMultiply(row, matrix) {
  return [row[0] * matrix[0][0] + row[1] * matrix[0][1] + row[2] * matrix[0][2], row[0] * matrix[1][0] + row[1] * matrix[1][1] + row[2] * matrix[1][2], row[0] * matrix[2][0] + row[1] * matrix[2][1] + row[2] * matrix[2][2]];
}
const SRGB_TO_XYZ = [[0.41233895, 0.35762064, 0.18051042], [0.2126, 0.7152, 0.0722], [0.01932141, 0.11916382, 0.95034478]], XYZ_TO_SRGB = [[3.2413774792388685, -1.5376652402851851, -0.49885366846268053], [-0.9691452513005321, 1.8758853451067872, 0.04156585616912061], [0.05562093689691305, -0.20395524564742123, 1.0571799111220335]], WHITE_POINT_D65 = [95.047, 100, 108.883];
function argbFromRgb(red, green, blue) {
  return (255 << 24 | (255 & red) << 16 | (255 & green) << 8 | 255 & blue) >>> 0;
}
function argbFromLinrgb(linrgb) {
  return argbFromRgb(delinearized(linrgb[0]), delinearized(linrgb[1]), delinearized(linrgb[2]));
}
function redFromArgb(argb) {
  return argb >> 16 & 255;
}
function greenFromArgb(argb) {
  return argb >> 8 & 255;
}
function blueFromArgb(argb) {
  return 255 & argb;
}
function argbFromXyz(x, y, z) {
  const matrix = XYZ_TO_SRGB, linearR = matrix[0][0] * x + matrix[0][1] * y + matrix[0][2] * z, linearG = matrix[1][0] * x + matrix[1][1] * y + matrix[1][2] * z, linearB = matrix[2][0] * x + matrix[2][1] * y + matrix[2][2] * z;
  return argbFromRgb(delinearized(linearR), delinearized(linearG), delinearized(linearB));
}
function xyzFromArgb(argb) {
  return matrixMultiply([linearized(redFromArgb(argb)), linearized(greenFromArgb(argb)), linearized(blueFromArgb(argb))], SRGB_TO_XYZ);
}
function argbFromLstar(lstar) {
  const component = delinearized(yFromLstar(lstar));
  return argbFromRgb(component, component, component);
}
function lstarFromArgb(argb) {
  return 116 * labF(xyzFromArgb(argb)[1] / 100) - 16;
}
function yFromLstar(lstar) {
  return 100 * labInvf((lstar + 16) / 116);
}
function lstarFromY(y) {
  return 116 * labF(y / 100) - 16;
}
function linearized(rgbComponent) {
  const normalized = rgbComponent / 255;
  return normalized <= 0.040449936 ? normalized / 12.92 * 100 : 100 * Math.pow((normalized + 0.055) / 1.055, 2.4);
}
function delinearized(rgbComponent) {
  const normalized = rgbComponent / 100;
  let delinearized2 = 0;
  return delinearized2 = normalized <= 31308e-7 ? 12.92 * normalized : 1.055 * Math.pow(normalized, 1 / 2.4) - 0.055, clampInt(0, 255, Math.round(255 * delinearized2));
}
function whitePointD65() {
  return WHITE_POINT_D65;
}
function labF(t2) {
  return t2 > 216 / 24389 ? Math.pow(t2, 1 / 3) : (903.2962962962963 * t2 + 16) / 116;
}
function labInvf(ft) {
  const ft3 = ft * ft * ft;
  return ft3 > 216 / 24389 ? ft3 : (116 * ft - 16) / 903.2962962962963;
}
class ViewingConditions {
  static make(whitePoint, adaptingLuminance, backgroundLstar, surround, discountingIlluminant) {
    if (whitePoint === void 0) {
      whitePoint = whitePointD65();
    }
    if (adaptingLuminance === void 0) {
      adaptingLuminance = 200 / Math.PI * yFromLstar(50) / 100;
    }
    if (backgroundLstar === void 0) {
      backgroundLstar = 50;
    }
    if (surround === void 0) {
      surround = 2;
    }
    if (discountingIlluminant === void 0) {
      discountingIlluminant = false;
    }
    const xyz = whitePoint, rW = 0.401288 * xyz[0] + 0.650173 * xyz[1] + -0.051461 * xyz[2], gW = -0.250268 * xyz[0] + 1.204414 * xyz[1] + 0.045854 * xyz[2], bW = -2079e-6 * xyz[0] + 0.048952 * xyz[1] + 0.953127 * xyz[2], f = 0.8 + surround / 10, c = f >= 0.9 ? lerp(0.59, 0.69, 10 * (f - 0.9)) : lerp(0.525, 0.59, 10 * (f - 0.8));
    let d = discountingIlluminant ? 1 : f * (1 - 1 / 3.6 * Math.exp((-adaptingLuminance - 42) / 92));
    d = d > 1 ? 1 : d < 0 ? 0 : d;
    const nc = f, rgbD = [d * (100 / rW) + 1 - d, d * (100 / gW) + 1 - d, d * (100 / bW) + 1 - d], k = 1 / (5 * adaptingLuminance + 1), k4 = k * k * k * k, k4F = 1 - k4, fl = k4 * adaptingLuminance + 0.1 * k4F * k4F * Math.cbrt(5 * adaptingLuminance), n2 = yFromLstar(backgroundLstar) / whitePoint[1], z = 1.48 + Math.sqrt(n2), nbb = 0.725 / Math.pow(n2, 0.2), ncb = nbb, rgbAFactors = [Math.pow(fl * rgbD[0] * rW / 100, 0.42), Math.pow(fl * rgbD[1] * gW / 100, 0.42), Math.pow(fl * rgbD[2] * bW / 100, 0.42)], rgbA = [400 * rgbAFactors[0] / (rgbAFactors[0] + 27.13), 400 * rgbAFactors[1] / (rgbAFactors[1] + 27.13), 400 * rgbAFactors[2] / (rgbAFactors[2] + 27.13)];
    return new ViewingConditions(n2, (2 * rgbA[0] + rgbA[1] + 0.05 * rgbA[2]) * nbb, nbb, ncb, c, nc, rgbD, fl, Math.pow(fl, 0.25), z);
  }
  constructor(n2, aw, nbb, ncb, c, nc, rgbD, fl, fLRoot, z) {
    this.n = n2, this.aw = aw, this.nbb = nbb, this.ncb = ncb, this.c = c, this.nc = nc, this.rgbD = rgbD, this.fl = fl, this.fLRoot = fLRoot, this.z = z;
  }
}
ViewingConditions.DEFAULT = ViewingConditions.make();
class Cam16 {
  constructor(hue, chroma, j, q, m, s, jstar, astar, bstar) {
    this.hue = hue, this.chroma = chroma, this.j = j, this.q = q, this.m = m, this.s = s, this.jstar = jstar, this.astar = astar, this.bstar = bstar;
  }
  distance(other) {
    const dJ = this.jstar - other.jstar, dA = this.astar - other.astar, dB = this.bstar - other.bstar, dEPrime = Math.sqrt(dJ * dJ + dA * dA + dB * dB);
    return 1.41 * Math.pow(dEPrime, 0.63);
  }
  static fromInt(argb) {
    return Cam16.fromIntInViewingConditions(argb, ViewingConditions.DEFAULT);
  }
  static fromIntInViewingConditions(argb, viewingConditions) {
    const green = (65280 & argb) >> 8, blue = 255 & argb, redL = linearized((16711680 & argb) >> 16), greenL = linearized(green), blueL = linearized(blue), x = 0.41233895 * redL + 0.35762064 * greenL + 0.18051042 * blueL, y = 0.2126 * redL + 0.7152 * greenL + 0.0722 * blueL, z = 0.01932141 * redL + 0.11916382 * greenL + 0.95034478 * blueL, rC = 0.401288 * x + 0.650173 * y - 0.051461 * z, gC = -0.250268 * x + 1.204414 * y + 0.045854 * z, bC = -2079e-6 * x + 0.048952 * y + 0.953127 * z, rD = viewingConditions.rgbD[0] * rC, gD = viewingConditions.rgbD[1] * gC, bD = viewingConditions.rgbD[2] * bC, rAF = Math.pow(viewingConditions.fl * Math.abs(rD) / 100, 0.42), gAF = Math.pow(viewingConditions.fl * Math.abs(gD) / 100, 0.42), bAF = Math.pow(viewingConditions.fl * Math.abs(bD) / 100, 0.42), rA = 400 * signum(rD) * rAF / (rAF + 27.13), gA = 400 * signum(gD) * gAF / (gAF + 27.13), bA = 400 * signum(bD) * bAF / (bAF + 27.13), a = (11 * rA + -12 * gA + bA) / 11, b = (rA + gA - 2 * bA) / 9, u = (20 * rA + 20 * gA + 21 * bA) / 20, p2 = (40 * rA + 20 * gA + bA) / 20, atanDegrees = 180 * Math.atan2(b, a) / Math.PI, hue = atanDegrees < 0 ? atanDegrees + 360 : atanDegrees >= 360 ? atanDegrees - 360 : atanDegrees, hueRadians = hue * Math.PI / 180, ac = p2 * viewingConditions.nbb, j = 100 * Math.pow(ac / viewingConditions.aw, viewingConditions.c * viewingConditions.z), q = 4 / viewingConditions.c * Math.sqrt(j / 100) * (viewingConditions.aw + 4) * viewingConditions.fLRoot, huePrime = hue < 20.14 ? hue + 360 : hue, t2 = 5e4 / 13 * (0.25 * (Math.cos(huePrime * Math.PI / 180 + 2) + 3.8)) * viewingConditions.nc * viewingConditions.ncb * Math.sqrt(a * a + b * b) / (u + 0.305), alpha = Math.pow(t2, 0.9) * Math.pow(1.64 - Math.pow(0.29, viewingConditions.n), 0.73), c = alpha * Math.sqrt(j / 100), m = c * viewingConditions.fLRoot, s = 50 * Math.sqrt(alpha * viewingConditions.c / (viewingConditions.aw + 4)), jstar = (1 + 100 * 7e-3) * j / (1 + 7e-3 * j), mstar = 1 / 0.0228 * Math.log(1 + 0.0228 * m), astar = mstar * Math.cos(hueRadians), bstar = mstar * Math.sin(hueRadians);
    return new Cam16(hue, c, j, q, m, s, jstar, astar, bstar);
  }
  static fromJch(j, c, h2) {
    return Cam16.fromJchInViewingConditions(j, c, h2, ViewingConditions.DEFAULT);
  }
  static fromJchInViewingConditions(j, c, h2, viewingConditions) {
    const q = 4 / viewingConditions.c * Math.sqrt(j / 100) * (viewingConditions.aw + 4) * viewingConditions.fLRoot, m = c * viewingConditions.fLRoot, alpha = c / Math.sqrt(j / 100), s = 50 * Math.sqrt(alpha * viewingConditions.c / (viewingConditions.aw + 4)), hueRadians = h2 * Math.PI / 180, jstar = (1 + 100 * 7e-3) * j / (1 + 7e-3 * j), mstar = 1 / 0.0228 * Math.log(1 + 0.0228 * m), astar = mstar * Math.cos(hueRadians), bstar = mstar * Math.sin(hueRadians);
    return new Cam16(h2, c, j, q, m, s, jstar, astar, bstar);
  }
  static fromUcs(jstar, astar, bstar) {
    return Cam16.fromUcsInViewingConditions(jstar, astar, bstar, ViewingConditions.DEFAULT);
  }
  static fromUcsInViewingConditions(jstar, astar, bstar, viewingConditions) {
    const a = astar, b = bstar, m = Math.sqrt(a * a + b * b), c = (Math.exp(0.0228 * m) - 1) / 0.0228 / viewingConditions.fLRoot;
    let h2 = Math.atan2(b, a) * (180 / Math.PI);
    h2 < 0 && (h2 += 360);
    const j = jstar / (1 - 7e-3 * (jstar - 100));
    return Cam16.fromJchInViewingConditions(j, c, h2, viewingConditions);
  }
  toInt() {
    return this.viewed(ViewingConditions.DEFAULT);
  }
  viewed(viewingConditions) {
    const alpha = 0 === this.chroma || 0 === this.j ? 0 : this.chroma / Math.sqrt(this.j / 100), t2 = Math.pow(alpha / Math.pow(1.64 - Math.pow(0.29, viewingConditions.n), 0.73), 1 / 0.9), hRad = this.hue * Math.PI / 180, eHue = 0.25 * (Math.cos(hRad + 2) + 3.8), ac = viewingConditions.aw * Math.pow(this.j / 100, 1 / viewingConditions.c / viewingConditions.z), p1 = eHue * (5e4 / 13) * viewingConditions.nc * viewingConditions.ncb, p2 = ac / viewingConditions.nbb, hSin = Math.sin(hRad), hCos = Math.cos(hRad), gamma = 23 * (p2 + 0.305) * t2 / (23 * p1 + 11 * t2 * hCos + 108 * t2 * hSin), a = gamma * hCos, b = gamma * hSin, rA = (460 * p2 + 451 * a + 288 * b) / 1403, gA = (460 * p2 - 891 * a - 261 * b) / 1403, bA = (460 * p2 - 220 * a - 6300 * b) / 1403, rCBase = Math.max(0, 27.13 * Math.abs(rA) / (400 - Math.abs(rA))), rC = signum(rA) * (100 / viewingConditions.fl) * Math.pow(rCBase, 1 / 0.42), gCBase = Math.max(0, 27.13 * Math.abs(gA) / (400 - Math.abs(gA))), gC = signum(gA) * (100 / viewingConditions.fl) * Math.pow(gCBase, 1 / 0.42), bCBase = Math.max(0, 27.13 * Math.abs(bA) / (400 - Math.abs(bA))), bC = signum(bA) * (100 / viewingConditions.fl) * Math.pow(bCBase, 1 / 0.42), rF = rC / viewingConditions.rgbD[0], gF = gC / viewingConditions.rgbD[1], bF = bC / viewingConditions.rgbD[2];
    return argbFromXyz(1.86206786 * rF - 1.01125463 * gF + 0.14918677 * bF, 0.38752654 * rF + 0.62144744 * gF - 897398e-8 * bF, -0.0158415 * rF - 0.03412294 * gF + 1.04996444 * bF);
  }
  static fromXyzInViewingConditions(x, y, z, viewingConditions) {
    const rC = 0.401288 * x + 0.650173 * y - 0.051461 * z, gC = -0.250268 * x + 1.204414 * y + 0.045854 * z, bC = -2079e-6 * x + 0.048952 * y + 0.953127 * z, rD = viewingConditions.rgbD[0] * rC, gD = viewingConditions.rgbD[1] * gC, bD = viewingConditions.rgbD[2] * bC, rAF = Math.pow(viewingConditions.fl * Math.abs(rD) / 100, 0.42), gAF = Math.pow(viewingConditions.fl * Math.abs(gD) / 100, 0.42), bAF = Math.pow(viewingConditions.fl * Math.abs(bD) / 100, 0.42), rA = 400 * signum(rD) * rAF / (rAF + 27.13), gA = 400 * signum(gD) * gAF / (gAF + 27.13), bA = 400 * signum(bD) * bAF / (bAF + 27.13), a = (11 * rA + -12 * gA + bA) / 11, b = (rA + gA - 2 * bA) / 9, u = (20 * rA + 20 * gA + 21 * bA) / 20, p2 = (40 * rA + 20 * gA + bA) / 20, atanDegrees = 180 * Math.atan2(b, a) / Math.PI, hue = atanDegrees < 0 ? atanDegrees + 360 : atanDegrees >= 360 ? atanDegrees - 360 : atanDegrees, hueRadians = hue * Math.PI / 180, ac = p2 * viewingConditions.nbb, J = 100 * Math.pow(ac / viewingConditions.aw, viewingConditions.c * viewingConditions.z), Q = 4 / viewingConditions.c * Math.sqrt(J / 100) * (viewingConditions.aw + 4) * viewingConditions.fLRoot, huePrime = hue < 20.14 ? hue + 360 : hue, t2 = 5e4 / 13 * (1 / 4 * (Math.cos(huePrime * Math.PI / 180 + 2) + 3.8)) * viewingConditions.nc * viewingConditions.ncb * Math.sqrt(a * a + b * b) / (u + 0.305), alpha = Math.pow(t2, 0.9) * Math.pow(1.64 - Math.pow(0.29, viewingConditions.n), 0.73), C = alpha * Math.sqrt(J / 100), M = C * viewingConditions.fLRoot, s = 50 * Math.sqrt(alpha * viewingConditions.c / (viewingConditions.aw + 4)), jstar = (1 + 100 * 7e-3) * J / (1 + 7e-3 * J), mstar = Math.log(1 + 0.0228 * M) / 0.0228, astar = mstar * Math.cos(hueRadians), bstar = mstar * Math.sin(hueRadians);
    return new Cam16(hue, C, J, Q, M, s, jstar, astar, bstar);
  }
  xyzInViewingConditions(viewingConditions) {
    const alpha = 0 === this.chroma || 0 === this.j ? 0 : this.chroma / Math.sqrt(this.j / 100), t2 = Math.pow(alpha / Math.pow(1.64 - Math.pow(0.29, viewingConditions.n), 0.73), 1 / 0.9), hRad = this.hue * Math.PI / 180, eHue = 0.25 * (Math.cos(hRad + 2) + 3.8), ac = viewingConditions.aw * Math.pow(this.j / 100, 1 / viewingConditions.c / viewingConditions.z), p1 = eHue * (5e4 / 13) * viewingConditions.nc * viewingConditions.ncb, p2 = ac / viewingConditions.nbb, hSin = Math.sin(hRad), hCos = Math.cos(hRad), gamma = 23 * (p2 + 0.305) * t2 / (23 * p1 + 11 * t2 * hCos + 108 * t2 * hSin), a = gamma * hCos, b = gamma * hSin, rA = (460 * p2 + 451 * a + 288 * b) / 1403, gA = (460 * p2 - 891 * a - 261 * b) / 1403, bA = (460 * p2 - 220 * a - 6300 * b) / 1403, rCBase = Math.max(0, 27.13 * Math.abs(rA) / (400 - Math.abs(rA))), rC = signum(rA) * (100 / viewingConditions.fl) * Math.pow(rCBase, 1 / 0.42), gCBase = Math.max(0, 27.13 * Math.abs(gA) / (400 - Math.abs(gA))), gC = signum(gA) * (100 / viewingConditions.fl) * Math.pow(gCBase, 1 / 0.42), bCBase = Math.max(0, 27.13 * Math.abs(bA) / (400 - Math.abs(bA))), bC = signum(bA) * (100 / viewingConditions.fl) * Math.pow(bCBase, 1 / 0.42), rF = rC / viewingConditions.rgbD[0], gF = gC / viewingConditions.rgbD[1], bF = bC / viewingConditions.rgbD[2];
    return [1.86206786 * rF - 1.01125463 * gF + 0.14918677 * bF, 0.38752654 * rF + 0.62144744 * gF - 897398e-8 * bF, -0.0158415 * rF - 0.03412294 * gF + 1.04996444 * bF];
  }
}
class HctSolver {
  static sanitizeRadians(angle) {
    return (angle + 8 * Math.PI) % (2 * Math.PI);
  }
  static trueDelinearized(rgbComponent) {
    const normalized = rgbComponent / 100;
    let delinearized2 = 0;
    return delinearized2 = normalized <= 31308e-7 ? 12.92 * normalized : 1.055 * Math.pow(normalized, 1 / 2.4) - 0.055, 255 * delinearized2;
  }
  static chromaticAdaptation(component) {
    const af = Math.pow(Math.abs(component), 0.42);
    return 400 * signum(component) * af / (af + 27.13);
  }
  static hueOf(linrgb) {
    const scaledDiscount = matrixMultiply(linrgb, HctSolver.SCALED_DISCOUNT_FROM_LINRGB), rA = HctSolver.chromaticAdaptation(scaledDiscount[0]), gA = HctSolver.chromaticAdaptation(scaledDiscount[1]), bA = HctSolver.chromaticAdaptation(scaledDiscount[2]), a = (11 * rA + -12 * gA + bA) / 11, b = (rA + gA - 2 * bA) / 9;
    return Math.atan2(b, a);
  }
  static areInCyclicOrder(a, b, c) {
    return HctSolver.sanitizeRadians(b - a) < HctSolver.sanitizeRadians(c - a);
  }
  static intercept(source, mid, target) {
    return (mid - source) / (target - source);
  }
  static lerpPoint(source, t2, target) {
    return [source[0] + (target[0] - source[0]) * t2, source[1] + (target[1] - source[1]) * t2, source[2] + (target[2] - source[2]) * t2];
  }
  static setCoordinate(source, coordinate, target, axis) {
    const t2 = HctSolver.intercept(source[axis], coordinate, target[axis]);
    return HctSolver.lerpPoint(source, t2, target);
  }
  static isBounded(x) {
    return 0 <= x && x <= 100;
  }
  static nthVertex(y, n2) {
    const kR = HctSolver.Y_FROM_LINRGB[0], kG = HctSolver.Y_FROM_LINRGB[1], kB = HctSolver.Y_FROM_LINRGB[2], coordA = n2 % 4 <= 1 ? 0 : 100, coordB = n2 % 2 == 0 ? 0 : 100;
    if (n2 < 4) {
      const g = coordA, b = coordB, r = (y - g * kG - b * kB) / kR;
      return HctSolver.isBounded(r) ? [r, g, b] : [-1, -1, -1];
    }
    if (n2 < 8) {
      const b = coordA, r = coordB, g = (y - r * kR - b * kB) / kG;
      return HctSolver.isBounded(g) ? [r, g, b] : [-1, -1, -1];
    }
    {
      const r = coordA, g = coordB, b = (y - r * kR - g * kG) / kB;
      return HctSolver.isBounded(b) ? [r, g, b] : [-1, -1, -1];
    }
  }
  static bisectToSegment(y, targetHue) {
    let left = [-1, -1, -1], right = left, leftHue = 0, rightHue = 0, initialized = false, uncut = true;
    for (let n2 = 0; n2 < 12; n2++) {
      const mid = HctSolver.nthVertex(y, n2);
      if (mid[0] < 0) continue;
      const midHue = HctSolver.hueOf(mid);
      initialized ? (uncut || HctSolver.areInCyclicOrder(leftHue, midHue, rightHue)) && (uncut = false, HctSolver.areInCyclicOrder(leftHue, targetHue, midHue) ? (right = mid, rightHue = midHue) : (left = mid, leftHue = midHue)) : (left = mid, right = mid, leftHue = midHue, rightHue = midHue, initialized = true);
    }
    return [left, right];
  }
  static midpoint(a, b) {
    return [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2, (a[2] + b[2]) / 2];
  }
  static criticalPlaneBelow(x) {
    return Math.floor(x - 0.5);
  }
  static criticalPlaneAbove(x) {
    return Math.ceil(x - 0.5);
  }
  static bisectToLimit(y, targetHue) {
    const segment = HctSolver.bisectToSegment(y, targetHue);
    let left = segment[0], leftHue = HctSolver.hueOf(left), right = segment[1];
    for (let axis = 0; axis < 3; axis++) if (left[axis] !== right[axis]) {
      let lPlane = -1, rPlane = 255;
      left[axis] < right[axis] ? (lPlane = HctSolver.criticalPlaneBelow(HctSolver.trueDelinearized(left[axis])), rPlane = HctSolver.criticalPlaneAbove(HctSolver.trueDelinearized(right[axis]))) : (lPlane = HctSolver.criticalPlaneAbove(HctSolver.trueDelinearized(left[axis])), rPlane = HctSolver.criticalPlaneBelow(HctSolver.trueDelinearized(right[axis])));
      for (let i = 0; i < 8 && !(Math.abs(rPlane - lPlane) <= 1); i++) {
        const mPlane = Math.floor((lPlane + rPlane) / 2), midPlaneCoordinate = HctSolver.CRITICAL_PLANES[mPlane], mid = HctSolver.setCoordinate(left, midPlaneCoordinate, right, axis), midHue = HctSolver.hueOf(mid);
        HctSolver.areInCyclicOrder(leftHue, targetHue, midHue) ? (right = mid, rPlane = mPlane) : (left = mid, leftHue = midHue, lPlane = mPlane);
      }
    }
    return HctSolver.midpoint(left, right);
  }
  static inverseChromaticAdaptation(adapted) {
    const adaptedAbs = Math.abs(adapted), base = Math.max(0, 27.13 * adaptedAbs / (400 - adaptedAbs));
    return signum(adapted) * Math.pow(base, 1 / 0.42);
  }
  static findResultByJ(hueRadians, chroma, y) {
    let j = 11 * Math.sqrt(y);
    const viewingConditions = ViewingConditions.DEFAULT, tInnerCoeff = 1 / Math.pow(1.64 - Math.pow(0.29, viewingConditions.n), 0.73), p1 = 0.25 * (Math.cos(hueRadians + 2) + 3.8) * (5e4 / 13) * viewingConditions.nc * viewingConditions.ncb, hSin = Math.sin(hueRadians), hCos = Math.cos(hueRadians);
    for (let iterationRound = 0; iterationRound < 5; iterationRound++) {
      const jNormalized = j / 100, alpha = 0 === chroma || 0 === j ? 0 : chroma / Math.sqrt(jNormalized), t2 = Math.pow(alpha * tInnerCoeff, 1 / 0.9), p2 = viewingConditions.aw * Math.pow(jNormalized, 1 / viewingConditions.c / viewingConditions.z) / viewingConditions.nbb, gamma = 23 * (p2 + 0.305) * t2 / (23 * p1 + 11 * t2 * hCos + 108 * t2 * hSin), a = gamma * hCos, b = gamma * hSin, rA = (460 * p2 + 451 * a + 288 * b) / 1403, gA = (460 * p2 - 891 * a - 261 * b) / 1403, bA = (460 * p2 - 220 * a - 6300 * b) / 1403, linrgb = matrixMultiply([HctSolver.inverseChromaticAdaptation(rA), HctSolver.inverseChromaticAdaptation(gA), HctSolver.inverseChromaticAdaptation(bA)], HctSolver.LINRGB_FROM_SCALED_DISCOUNT);
      if (linrgb[0] < 0 || linrgb[1] < 0 || linrgb[2] < 0) return 0;
      const kR = HctSolver.Y_FROM_LINRGB[0], kG = HctSolver.Y_FROM_LINRGB[1], kB = HctSolver.Y_FROM_LINRGB[2], fnj = kR * linrgb[0] + kG * linrgb[1] + kB * linrgb[2];
      if (fnj <= 0) return 0;
      if (4 === iterationRound || Math.abs(fnj - y) < 2e-3) return linrgb[0] > 100.01 || linrgb[1] > 100.01 || linrgb[2] > 100.01 ? 0 : argbFromLinrgb(linrgb);
      j -= (fnj - y) * j / (2 * fnj);
    }
    return 0;
  }
  static solveToInt(hueDegrees, chroma, lstar) {
    if (chroma < 1e-4 || lstar < 1e-4 || lstar > 99.9999) return argbFromLstar(lstar);
    const hueRadians = (hueDegrees = sanitizeDegreesDouble(hueDegrees)) / 180 * Math.PI, y = yFromLstar(lstar), exactAnswer = HctSolver.findResultByJ(hueRadians, chroma, y);
    if (0 !== exactAnswer) return exactAnswer;
    return argbFromLinrgb(HctSolver.bisectToLimit(y, hueRadians));
  }
  static solveToCam(hueDegrees, chroma, lstar) {
    return Cam16.fromInt(HctSolver.solveToInt(hueDegrees, chroma, lstar));
  }
}
HctSolver.SCALED_DISCOUNT_FROM_LINRGB = [[0.001200833568784504, 0.002389694492170889, 2795742885861124e-19], [5891086651375999e-19, 0.0029785502573438758, 3270666104008398e-19], [10146692491640572e-20, 5364214359186694e-19, 0.0032979401770712076]], HctSolver.LINRGB_FROM_SCALED_DISCOUNT = [[1373.2198709594231, -1100.4251190754821, -7.278681089101213], [-271.815969077903, 559.6580465940733, -32.46047482791194], [1.9622899599665666, -57.173814538844006, 308.7233197812385]], HctSolver.Y_FROM_LINRGB = [0.2126, 0.7152, 0.0722], HctSolver.CRITICAL_PLANES = [0.015176349177441876, 0.045529047532325624, 0.07588174588720938, 0.10623444424209313, 0.13658714259697685, 0.16693984095186062, 0.19729253930674434, 0.2276452376616281, 0.2579979360165119, 0.28835063437139563, 0.3188300904430532, 0.350925934958123, 0.3848314933096426, 0.42057480301049466, 0.458183274052838, 0.4976837250274023, 0.5391024159806381, 0.5824650784040898, 0.6277969426914107, 0.6751227633498623, 0.7244668422128921, 0.775853049866786, 0.829304845476233, 0.8848452951698498, 0.942497089126609, 1.0022825574869039, 1.0642236851973577, 1.1283421258858297, 1.1946592148522128, 1.2631959812511864, 1.3339731595349034, 1.407011200216447, 1.4823302800086415, 1.5599503113873272, 1.6398909516233677, 1.7221716113234105, 1.8068114625156377, 1.8938294463134073, 1.9832442801866852, 2.075074464868551, 2.1693382909216234, 2.2660538449872063, 2.36523901573795, 2.4669114995532007, 2.5710888059345764, 2.6777882626779785, 2.7870270208169257, 2.898822059350997, 3.0131901897720907, 3.1301480604002863, 3.2497121605402226, 3.3718988244681087, 3.4967242352587946, 3.624204428461639, 3.754355295633311, 3.887192587735158, 4.022731918402185, 4.160988767090289, 4.301978482107941, 4.445716283538092, 4.592217266055746, 4.741496401646282, 4.893568542229298, 5.048448422192488, 5.20615066083972, 5.3666897647573375, 5.5300801301023865, 5.696336044816294, 5.865471690767354, 6.037501145825082, 6.212438385869475, 6.390297286737924, 6.571091626112461, 6.7548350853498045, 6.941541251256611, 7.131223617812143, 7.323895587840543, 7.5195704746346665, 7.7182615035334345, 7.919981813454504, 8.124744458384042, 8.332562408825165, 8.543448553206703, 8.757415699253682, 8.974476575321063, 9.194643831691977, 9.417930041841839, 9.644347703669503, 9.873909240696694, 10.106627003236781, 10.342513269534024, 10.58158024687427, 10.8238400726681, 11.069304815507364, 11.317986476196008, 11.569896988756009, 11.825048221409341, 12.083451977536606, 12.345119996613247, 12.610063955123938, 12.878295467455942, 13.149826086772048, 13.42466730586372, 13.702830557985108, 13.984327217668513, 14.269168601521828, 14.55736596900856, 14.848930523210871, 15.143873411576273, 15.44220572664832, 15.743938506781891, 16.04908273684337, 16.35764934889634, 16.66964922287304, 16.985093187232053, 17.30399201960269, 17.62635644741625, 17.95219714852476, 18.281524751807332, 18.614349837764564, 18.95068293910138, 19.290534541298456, 19.633915083172692, 19.98083495742689, 20.331304511189067, 20.685334046541502, 21.042933821039977, 21.404114048223256, 21.76888489811322, 22.137256497705877, 22.50923893145328, 22.884842241736916, 23.264076429332462, 23.6469514538663, 24.033477234264016, 24.42366364919083, 24.817520537484558, 25.21505769858089, 25.61628489293138, 26.021211842414342, 26.429848230738664, 26.842203703840827, 27.258287870275353, 27.678110301598522, 28.10168053274597, 28.529008062403893, 28.96010235337422, 29.39497283293396, 29.83362889318845, 30.276079891419332, 30.722335150426627, 31.172403958865512, 31.62629557157785, 32.08401920991837, 32.54558406207592, 33.010999283389665, 33.4802739966603, 33.953417292456834, 34.430438229418264, 34.911345834551085, 35.39614910352207, 35.88485700094671, 36.37747846067349, 36.87402238606382, 37.37449765026789, 37.87891309649659, 38.38727753828926, 38.89959975977785, 39.41588851594697, 39.93615253289054, 40.460400508064545, 40.98864111053629, 41.520882981230194, 42.05713473317016, 42.597404951718396, 43.141702194811224, 43.6900349931913, 44.24241185063697, 44.798841244188324, 45.35933162437017, 45.92389141541209, 46.49252901546552, 47.065252796817916, 47.64207110610409, 48.22299226451468, 48.808024568002054, 49.3971762874833, 49.9904556690408, 50.587870934119984, 51.189430279724725, 51.79514187861014, 52.40501387947288, 53.0190544071392, 53.637271562750364, 54.259673423945976, 54.88626804504493, 55.517063457223934, 56.15206766869424, 56.79128866487574, 57.43473440856916, 58.08241284012621, 58.734331877617365, 59.39049941699807, 60.05092333227251, 60.715611475655585, 61.38457167773311, 62.057811747619894, 62.7353394731159, 63.417162620860914, 64.10328893648692, 64.79372614476921, 65.48848194977529, 66.18756403501224, 66.89098006357258, 67.59873767827808, 68.31084450182222, 69.02730813691093, 69.74813616640164, 70.47333615344107, 71.20291564160104, 71.93688215501312, 72.67524319850172, 73.41800625771542, 74.16517879925733, 74.9167682708136, 75.67278210128072, 76.43322770089146, 77.1981124613393, 77.96744375590167, 78.74122893956174, 79.51947534912904, 80.30219030335869, 81.08938110306934, 81.88105503125999, 82.67721935322541, 83.4778813166706, 84.28304815182372, 85.09272707154808, 85.90692527145302, 86.72564993000343, 87.54890820862819, 88.3767072518277, 89.2090541872801, 90.04595612594655, 90.88742016217518, 91.73345337380438, 92.58406282226491, 93.43925555268066, 94.29903859396902, 95.16341895893969, 96.03240364439274, 96.9059996312159, 97.78421388448044, 98.6670533535366, 99.55452497210776];
class Hct {
  static from(hue, chroma, tone) {
    return new Hct(HctSolver.solveToInt(hue, chroma, tone));
  }
  static fromInt(argb) {
    return new Hct(argb);
  }
  toInt() {
    return this.argb;
  }
  get hue() {
    return this.internalHue;
  }
  set hue(newHue) {
    this.setInternalState(HctSolver.solveToInt(newHue, this.internalChroma, this.internalTone));
  }
  get chroma() {
    return this.internalChroma;
  }
  set chroma(newChroma) {
    this.setInternalState(HctSolver.solveToInt(this.internalHue, newChroma, this.internalTone));
  }
  get tone() {
    return this.internalTone;
  }
  set tone(newTone) {
    this.setInternalState(HctSolver.solveToInt(this.internalHue, this.internalChroma, newTone));
  }
  constructor(argb) {
    this.argb = argb;
    const cam = Cam16.fromInt(argb);
    this.internalHue = cam.hue, this.internalChroma = cam.chroma, this.internalTone = lstarFromArgb(argb), this.argb = argb;
  }
  setInternalState(argb) {
    const cam = Cam16.fromInt(argb);
    this.internalHue = cam.hue, this.internalChroma = cam.chroma, this.internalTone = lstarFromArgb(argb), this.argb = argb;
  }
  inViewingConditions(vc) {
    const viewedInVc = Cam16.fromInt(this.toInt()).xyzInViewingConditions(vc), recastInVc = Cam16.fromXyzInViewingConditions(viewedInVc[0], viewedInVc[1], viewedInVc[2], ViewingConditions.make());
    return Hct.from(recastInVc.hue, recastInVc.chroma, lstarFromY(viewedInVc[1]));
  }
}
class Blend {
  static harmonize(designColor, sourceColor) {
    const fromHct = Hct.fromInt(designColor), toHct = Hct.fromInt(sourceColor), differenceDegrees$1 = differenceDegrees(fromHct.hue, toHct.hue), rotationDegrees = Math.min(0.5 * differenceDegrees$1, 15), outputHue = sanitizeDegreesDouble(fromHct.hue + rotationDegrees * rotationDirection(fromHct.hue, toHct.hue));
    return Hct.from(outputHue, fromHct.chroma, fromHct.tone).toInt();
  }
  static hctHue(from, to, amount) {
    const ucs = Blend.cam16Ucs(from, to, amount), ucsCam = Cam16.fromInt(ucs), fromCam = Cam16.fromInt(from);
    return Hct.from(ucsCam.hue, fromCam.chroma, lstarFromArgb(from)).toInt();
  }
  static cam16Ucs(from, to, amount) {
    const fromCam = Cam16.fromInt(from), toCam = Cam16.fromInt(to), fromJ = fromCam.jstar, fromA = fromCam.astar, fromB = fromCam.bstar, jstar = fromJ + (toCam.jstar - fromJ) * amount, astar = fromA + (toCam.astar - fromA) * amount, bstar = fromB + (toCam.bstar - fromB) * amount;
    return Cam16.fromUcs(jstar, astar, bstar).toInt();
  }
}
class Contrast {
  static ratioOfTones(toneA, toneB) {
    return toneA = clampDouble(0, 100, toneA), toneB = clampDouble(0, 100, toneB), Contrast.ratioOfYs(yFromLstar(toneA), yFromLstar(toneB));
  }
  static ratioOfYs(y1, y2) {
    const lighter = y1 > y2 ? y1 : y2;
    return (lighter + 5) / ((lighter === y2 ? y1 : y2) + 5);
  }
  static lighter(tone, ratio) {
    if (tone < 0 || tone > 100) return -1;
    const darkY = yFromLstar(tone), lightY = ratio * (darkY + 5) - 5, realContrast = Contrast.ratioOfYs(lightY, darkY), delta = Math.abs(realContrast - ratio);
    if (realContrast < ratio && delta > 0.04) return -1;
    const returnValue = lstarFromY(lightY) + 0.4;
    return returnValue < 0 || returnValue > 100 ? -1 : returnValue;
  }
  static darker(tone, ratio) {
    if (tone < 0 || tone > 100) return -1;
    const lightY = yFromLstar(tone), darkY = (lightY + 5) / ratio - 5, realContrast = Contrast.ratioOfYs(lightY, darkY), delta = Math.abs(realContrast - ratio);
    if (realContrast < ratio && delta > 0.04) return -1;
    const returnValue = lstarFromY(darkY) - 0.4;
    return returnValue < 0 || returnValue > 100 ? -1 : returnValue;
  }
  static lighterUnsafe(tone, ratio) {
    const lighterSafe = Contrast.lighter(tone, ratio);
    return lighterSafe < 0 ? 100 : lighterSafe;
  }
  static darkerUnsafe(tone, ratio) {
    const darkerSafe = Contrast.darker(tone, ratio);
    return darkerSafe < 0 ? 0 : darkerSafe;
  }
}
class DislikeAnalyzer {
  static isDisliked(hct) {
    const huePasses = Math.round(hct.hue) >= 90 && Math.round(hct.hue) <= 111, chromaPasses = Math.round(hct.chroma) > 16, tonePasses = Math.round(hct.tone) < 65;
    return huePasses && chromaPasses && tonePasses;
  }
  static fixIfDisliked(hct) {
    return DislikeAnalyzer.isDisliked(hct) ? Hct.from(hct.hue, hct.chroma, 70) : hct;
  }
}
class DynamicColor {
  static fromPalette(args) {
    return new DynamicColor(args.name ?? "", args.palette, args.tone, args.isBackground ?? false, args.background, args.secondBackground, args.contrastCurve, args.toneDeltaPair);
  }
  constructor(name, palette, tone, isBackground, background, secondBackground, contrastCurve, toneDeltaPair) {
    if (this.name = name, this.palette = palette, this.tone = tone, this.isBackground = isBackground, this.background = background, this.secondBackground = secondBackground, this.contrastCurve = contrastCurve, this.toneDeltaPair = toneDeltaPair, this.hctCache = /* @__PURE__ */ new Map(), !background && secondBackground) throw new Error(`Color ${name} has secondBackgrounddefined, but background is not defined.`);
    if (!background && contrastCurve) throw new Error(`Color ${name} has contrastCurvedefined, but background is not defined.`);
    if (background && !contrastCurve) throw new Error(`Color ${name} has backgrounddefined, but contrastCurve is not defined.`);
  }
  getArgb(scheme) {
    return this.getHct(scheme).toInt();
  }
  getHct(scheme) {
    const cachedAnswer = this.hctCache.get(scheme);
    if (null != cachedAnswer) return cachedAnswer;
    const tone = this.getTone(scheme), answer = this.palette(scheme).getHct(tone);
    return this.hctCache.size > 4 && this.hctCache.clear(), this.hctCache.set(scheme, answer), answer;
  }
  getTone(scheme) {
    const decreasingContrast = scheme.contrastLevel < 0;
    if (this.toneDeltaPair) {
      const toneDeltaPair = this.toneDeltaPair(scheme), roleA = toneDeltaPair.roleA, roleB = toneDeltaPair.roleB, delta = toneDeltaPair.delta, polarity = toneDeltaPair.polarity, stayTogether = toneDeltaPair.stayTogether, bgTone = this.background(scheme).getTone(scheme), aIsNearer = "nearer" === polarity || "lighter" === polarity && !scheme.isDark || "darker" === polarity && scheme.isDark, nearer = aIsNearer ? roleA : roleB, farther = aIsNearer ? roleB : roleA, amNearer = this.name === nearer.name, expansionDir = scheme.isDark ? 1 : -1, nContrast = nearer.contrastCurve.getContrast(scheme.contrastLevel), fContrast = farther.contrastCurve.getContrast(scheme.contrastLevel), nInitialTone = nearer.tone(scheme);
      let nTone = Contrast.ratioOfTones(bgTone, nInitialTone) >= nContrast ? nInitialTone : DynamicColor.foregroundTone(bgTone, nContrast);
      const fInitialTone = farther.tone(scheme);
      let fTone = Contrast.ratioOfTones(bgTone, fInitialTone) >= fContrast ? fInitialTone : DynamicColor.foregroundTone(bgTone, fContrast);
      return decreasingContrast && (nTone = DynamicColor.foregroundTone(bgTone, nContrast), fTone = DynamicColor.foregroundTone(bgTone, fContrast)), (fTone - nTone) * expansionDir >= delta || (fTone = clampDouble(0, 100, nTone + delta * expansionDir), (fTone - nTone) * expansionDir >= delta || (nTone = clampDouble(0, 100, fTone - delta * expansionDir))), 50 <= nTone && nTone < 60 ? expansionDir > 0 ? (nTone = 60, fTone = Math.max(fTone, nTone + delta * expansionDir)) : (nTone = 49, fTone = Math.min(fTone, nTone + delta * expansionDir)) : 50 <= fTone && fTone < 60 && (stayTogether ? expansionDir > 0 ? (nTone = 60, fTone = Math.max(fTone, nTone + delta * expansionDir)) : (nTone = 49, fTone = Math.min(fTone, nTone + delta * expansionDir)) : fTone = expansionDir > 0 ? 60 : 49), amNearer ? nTone : fTone;
    }
    {
      let answer = this.tone(scheme);
      if (null == this.background) return answer;
      const bgTone = this.background(scheme).getTone(scheme), desiredRatio = this.contrastCurve.getContrast(scheme.contrastLevel);
      if (Contrast.ratioOfTones(bgTone, answer) >= desiredRatio || (answer = DynamicColor.foregroundTone(bgTone, desiredRatio)), decreasingContrast && (answer = DynamicColor.foregroundTone(bgTone, desiredRatio)), this.isBackground && 50 <= answer && answer < 60 && (answer = Contrast.ratioOfTones(49, bgTone) >= desiredRatio ? 49 : 60), this.secondBackground) {
        const [bg1, bg2] = [this.background, this.secondBackground], [bgTone1, bgTone2] = [bg1(scheme).getTone(scheme), bg2(scheme).getTone(scheme)], [upper, lower] = [Math.max(bgTone1, bgTone2), Math.min(bgTone1, bgTone2)];
        if (Contrast.ratioOfTones(upper, answer) >= desiredRatio && Contrast.ratioOfTones(lower, answer) >= desiredRatio) return answer;
        const lightOption = Contrast.lighter(upper, desiredRatio), darkOption = Contrast.darker(lower, desiredRatio), availables = [];
        -1 !== lightOption && availables.push(lightOption), -1 !== darkOption && availables.push(darkOption);
        return DynamicColor.tonePrefersLightForeground(bgTone1) || DynamicColor.tonePrefersLightForeground(bgTone2) ? lightOption < 0 ? 100 : lightOption : 1 === availables.length ? availables[0] : darkOption < 0 ? 0 : darkOption;
      }
      return answer;
    }
  }
  static foregroundTone(bgTone, ratio) {
    const lighterTone = Contrast.lighterUnsafe(bgTone, ratio), darkerTone = Contrast.darkerUnsafe(bgTone, ratio), lighterRatio = Contrast.ratioOfTones(lighterTone, bgTone), darkerRatio = Contrast.ratioOfTones(darkerTone, bgTone);
    if (DynamicColor.tonePrefersLightForeground(bgTone)) {
      const negligibleDifference = Math.abs(lighterRatio - darkerRatio) < 0.1 && lighterRatio < ratio && darkerRatio < ratio;
      return lighterRatio >= ratio || lighterRatio >= darkerRatio || negligibleDifference ? lighterTone : darkerTone;
    }
    return darkerRatio >= ratio || darkerRatio >= lighterRatio ? darkerTone : lighterTone;
  }
  static tonePrefersLightForeground(tone) {
    return Math.round(tone) < 60;
  }
  static toneAllowsLightForeground(tone) {
    return Math.round(tone) <= 49;
  }
  static enableLightForeground(tone) {
    return DynamicColor.tonePrefersLightForeground(tone) && !DynamicColor.toneAllowsLightForeground(tone) ? 49 : tone;
  }
}
var Variant;
!function(Variant2) {
  Variant2[Variant2.MONOCHROME = 0] = "MONOCHROME", Variant2[Variant2.NEUTRAL = 1] = "NEUTRAL", Variant2[Variant2.TONAL_SPOT = 2] = "TONAL_SPOT", Variant2[Variant2.VIBRANT = 3] = "VIBRANT", Variant2[Variant2.EXPRESSIVE = 4] = "EXPRESSIVE", Variant2[Variant2.FIDELITY = 5] = "FIDELITY", Variant2[Variant2.CONTENT = 6] = "CONTENT", Variant2[Variant2.RAINBOW = 7] = "RAINBOW", Variant2[Variant2.FRUIT_SALAD = 8] = "FRUIT_SALAD";
}(Variant || (Variant = {}));
class ContrastCurve {
  constructor(low, normal, medium, high) {
    this.low = low, this.normal = normal, this.medium = medium, this.high = high;
  }
  getContrast(contrastLevel) {
    return contrastLevel <= -1 ? this.low : contrastLevel < 0 ? lerp(this.low, this.normal, (contrastLevel - -1) / 1) : contrastLevel < 0.5 ? lerp(this.normal, this.medium, (contrastLevel - 0) / 0.5) : contrastLevel < 1 ? lerp(this.medium, this.high, (contrastLevel - 0.5) / 0.5) : this.high;
  }
}
class ToneDeltaPair {
  constructor(roleA, roleB, delta, polarity, stayTogether) {
    this.roleA = roleA, this.roleB = roleB, this.delta = delta, this.polarity = polarity, this.stayTogether = stayTogether;
  }
}
function isFidelity(scheme) {
  return scheme.variant === Variant.FIDELITY || scheme.variant === Variant.CONTENT;
}
function isMonochrome(scheme) {
  return scheme.variant === Variant.MONOCHROME;
}
function findDesiredChromaByTone(hue, chroma, tone, byDecreasingTone) {
  let answer = tone, closestToChroma = Hct.from(hue, chroma, tone);
  if (closestToChroma.chroma < chroma) {
    let chromaPeak = closestToChroma.chroma;
    for (; closestToChroma.chroma < chroma; ) {
      answer += byDecreasingTone ? -1 : 1;
      const potentialSolution = Hct.from(hue, chroma, answer);
      if (chromaPeak > potentialSolution.chroma) break;
      if (Math.abs(potentialSolution.chroma - chroma) < 0.4) break;
      Math.abs(potentialSolution.chroma - chroma) < Math.abs(closestToChroma.chroma - chroma) && (closestToChroma = potentialSolution), chromaPeak = Math.max(chromaPeak, potentialSolution.chroma);
    }
  }
  return answer;
}
function viewingConditionsForAlbers(scheme) {
  return ViewingConditions.make(void 0, void 0, scheme.isDark ? 30 : 80, void 0, void 0);
}
function performAlbers(prealbers, scheme) {
  const albersd = prealbers.inViewingConditions(viewingConditionsForAlbers(scheme));
  return DynamicColor.tonePrefersLightForeground(prealbers.tone) && !DynamicColor.toneAllowsLightForeground(albersd.tone) ? DynamicColor.enableLightForeground(prealbers.tone) : DynamicColor.enableLightForeground(albersd.tone);
}
class MaterialDynamicColors {
  static highestSurface(s) {
    return s.isDark ? MaterialDynamicColors.surfaceBright : MaterialDynamicColors.surfaceDim;
  }
}
MaterialDynamicColors.contentAccentToneDelta = 15, MaterialDynamicColors.primaryPaletteKeyColor = DynamicColor.fromPalette({
  name: "primary_palette_key_color",
  palette: (s) => s.primaryPalette,
  tone: (s) => s.primaryPalette.keyColor.tone
}), MaterialDynamicColors.secondaryPaletteKeyColor = DynamicColor.fromPalette({
  name: "secondary_palette_key_color",
  palette: (s) => s.secondaryPalette,
  tone: (s) => s.secondaryPalette.keyColor.tone
}), MaterialDynamicColors.tertiaryPaletteKeyColor = DynamicColor.fromPalette({
  name: "tertiary_palette_key_color",
  palette: (s) => s.tertiaryPalette,
  tone: (s) => s.tertiaryPalette.keyColor.tone
}), MaterialDynamicColors.neutralPaletteKeyColor = DynamicColor.fromPalette({
  name: "neutral_palette_key_color",
  palette: (s) => s.neutralPalette,
  tone: (s) => s.neutralPalette.keyColor.tone
}), MaterialDynamicColors.neutralVariantPaletteKeyColor = DynamicColor.fromPalette({
  name: "neutral_variant_palette_key_color",
  palette: (s) => s.neutralVariantPalette,
  tone: (s) => s.neutralVariantPalette.keyColor.tone
}), MaterialDynamicColors.background = DynamicColor.fromPalette({
  name: "background",
  palette: (s) => s.neutralPalette,
  tone: (s) => s.isDark ? 6 : 98,
  isBackground: true
}), MaterialDynamicColors.onBackground = DynamicColor.fromPalette({
  name: "on_background",
  palette: (s) => s.neutralPalette,
  tone: (s) => s.isDark ? 90 : 10,
  background: (s) => MaterialDynamicColors.background,
  contrastCurve: new ContrastCurve(3, 3, 4.5, 7)
}), MaterialDynamicColors.surface = DynamicColor.fromPalette({
  name: "surface",
  palette: (s) => s.neutralPalette,
  tone: (s) => s.isDark ? 6 : 98,
  isBackground: true
}), MaterialDynamicColors.surfaceDim = DynamicColor.fromPalette({
  name: "surface_dim",
  palette: (s) => s.neutralPalette,
  tone: (s) => s.isDark ? 6 : 87,
  isBackground: true
}), MaterialDynamicColors.surfaceBright = DynamicColor.fromPalette({
  name: "surface_bright",
  palette: (s) => s.neutralPalette,
  tone: (s) => s.isDark ? 24 : 98,
  isBackground: true
}), MaterialDynamicColors.surfaceContainerLowest = DynamicColor.fromPalette({
  name: "surface_container_lowest",
  palette: (s) => s.neutralPalette,
  tone: (s) => s.isDark ? 4 : 100,
  isBackground: true
}), MaterialDynamicColors.surfaceContainerLow = DynamicColor.fromPalette({
  name: "surface_container_low",
  palette: (s) => s.neutralPalette,
  tone: (s) => s.isDark ? 10 : 96,
  isBackground: true
}), MaterialDynamicColors.surfaceContainer = DynamicColor.fromPalette({
  name: "surface_container",
  palette: (s) => s.neutralPalette,
  tone: (s) => s.isDark ? 12 : 94,
  isBackground: true
}), MaterialDynamicColors.surfaceContainerHigh = DynamicColor.fromPalette({
  name: "surface_container_high",
  palette: (s) => s.neutralPalette,
  tone: (s) => s.isDark ? 17 : 92,
  isBackground: true
}), MaterialDynamicColors.surfaceContainerHighest = DynamicColor.fromPalette({
  name: "surface_container_highest",
  palette: (s) => s.neutralPalette,
  tone: (s) => s.isDark ? 22 : 90,
  isBackground: true
}), MaterialDynamicColors.onSurface = DynamicColor.fromPalette({
  name: "on_surface",
  palette: (s) => s.neutralPalette,
  tone: (s) => s.isDark ? 90 : 10,
  background: (s) => MaterialDynamicColors.highestSurface(s),
  contrastCurve: new ContrastCurve(4.5, 7, 11, 21)
}), MaterialDynamicColors.surfaceVariant = DynamicColor.fromPalette({
  name: "surface_variant",
  palette: (s) => s.neutralVariantPalette,
  tone: (s) => s.isDark ? 30 : 90,
  isBackground: true
}), MaterialDynamicColors.onSurfaceVariant = DynamicColor.fromPalette({
  name: "on_surface_variant",
  palette: (s) => s.neutralVariantPalette,
  tone: (s) => s.isDark ? 80 : 30,
  background: (s) => MaterialDynamicColors.highestSurface(s),
  contrastCurve: new ContrastCurve(3, 4.5, 7, 11)
}), MaterialDynamicColors.inverseSurface = DynamicColor.fromPalette({
  name: "inverse_surface",
  palette: (s) => s.neutralPalette,
  tone: (s) => s.isDark ? 90 : 20
}), MaterialDynamicColors.inverseOnSurface = DynamicColor.fromPalette({
  name: "inverse_on_surface",
  palette: (s) => s.neutralPalette,
  tone: (s) => s.isDark ? 20 : 95,
  background: (s) => MaterialDynamicColors.inverseSurface,
  contrastCurve: new ContrastCurve(4.5, 7, 11, 21)
}), MaterialDynamicColors.outline = DynamicColor.fromPalette({
  name: "outline",
  palette: (s) => s.neutralVariantPalette,
  tone: (s) => s.isDark ? 60 : 50,
  background: (s) => MaterialDynamicColors.highestSurface(s),
  contrastCurve: new ContrastCurve(1.5, 3, 4.5, 7)
}), MaterialDynamicColors.outlineVariant = DynamicColor.fromPalette({
  name: "outline_variant",
  palette: (s) => s.neutralVariantPalette,
  tone: (s) => s.isDark ? 30 : 80,
  background: (s) => MaterialDynamicColors.highestSurface(s),
  contrastCurve: new ContrastCurve(1, 1, 3, 7)
}), MaterialDynamicColors.shadow = DynamicColor.fromPalette({
  name: "shadow",
  palette: (s) => s.neutralPalette,
  tone: (s) => 0
}), MaterialDynamicColors.scrim = DynamicColor.fromPalette({
  name: "scrim",
  palette: (s) => s.neutralPalette,
  tone: (s) => 0
}), MaterialDynamicColors.surfaceTint = DynamicColor.fromPalette({
  name: "surface_tint",
  palette: (s) => s.primaryPalette,
  tone: (s) => s.isDark ? 80 : 40,
  isBackground: true
}), MaterialDynamicColors.primary = DynamicColor.fromPalette({
  name: "primary",
  palette: (s) => s.primaryPalette,
  tone: (s) => isMonochrome(s) ? s.isDark ? 100 : 0 : s.isDark ? 80 : 40,
  isBackground: true,
  background: (s) => MaterialDynamicColors.highestSurface(s),
  contrastCurve: new ContrastCurve(3, 4.5, 7, 11),
  toneDeltaPair: (s) => new ToneDeltaPair(MaterialDynamicColors.primaryContainer, MaterialDynamicColors.primary, 15, "nearer", false)
}), MaterialDynamicColors.onPrimary = DynamicColor.fromPalette({
  name: "on_primary",
  palette: (s) => s.primaryPalette,
  tone: (s) => isMonochrome(s) ? s.isDark ? 10 : 90 : s.isDark ? 20 : 100,
  background: (s) => MaterialDynamicColors.primary,
  contrastCurve: new ContrastCurve(4.5, 7, 11, 21)
}), MaterialDynamicColors.primaryContainer = DynamicColor.fromPalette({
  name: "primary_container",
  palette: (s) => s.primaryPalette,
  tone: (s) => isFidelity(s) ? performAlbers(s.sourceColorHct, s) : isMonochrome(s) ? s.isDark ? 85 : 25 : s.isDark ? 30 : 90,
  isBackground: true,
  background: (s) => MaterialDynamicColors.highestSurface(s),
  contrastCurve: new ContrastCurve(1, 1, 3, 7),
  toneDeltaPair: (s) => new ToneDeltaPair(MaterialDynamicColors.primaryContainer, MaterialDynamicColors.primary, 15, "nearer", false)
}), MaterialDynamicColors.onPrimaryContainer = DynamicColor.fromPalette({
  name: "on_primary_container",
  palette: (s) => s.primaryPalette,
  tone: (s) => isFidelity(s) ? DynamicColor.foregroundTone(MaterialDynamicColors.primaryContainer.tone(s), 4.5) : isMonochrome(s) ? s.isDark ? 0 : 100 : s.isDark ? 90 : 10,
  background: (s) => MaterialDynamicColors.primaryContainer,
  contrastCurve: new ContrastCurve(4.5, 7, 11, 21)
}), MaterialDynamicColors.inversePrimary = DynamicColor.fromPalette({
  name: "inverse_primary",
  palette: (s) => s.primaryPalette,
  tone: (s) => s.isDark ? 40 : 80,
  background: (s) => MaterialDynamicColors.inverseSurface,
  contrastCurve: new ContrastCurve(3, 4.5, 7, 11)
}), MaterialDynamicColors.secondary = DynamicColor.fromPalette({
  name: "secondary",
  palette: (s) => s.secondaryPalette,
  tone: (s) => s.isDark ? 80 : 40,
  isBackground: true,
  background: (s) => MaterialDynamicColors.highestSurface(s),
  contrastCurve: new ContrastCurve(3, 4.5, 7, 11),
  toneDeltaPair: (s) => new ToneDeltaPair(MaterialDynamicColors.secondaryContainer, MaterialDynamicColors.secondary, 15, "nearer", false)
}), MaterialDynamicColors.onSecondary = DynamicColor.fromPalette({
  name: "on_secondary",
  palette: (s) => s.secondaryPalette,
  tone: (s) => isMonochrome(s) ? s.isDark ? 10 : 100 : s.isDark ? 20 : 100,
  background: (s) => MaterialDynamicColors.secondary,
  contrastCurve: new ContrastCurve(4.5, 7, 11, 21)
}), MaterialDynamicColors.secondaryContainer = DynamicColor.fromPalette({
  name: "secondary_container",
  palette: (s) => s.secondaryPalette,
  tone: (s) => {
    const initialTone = s.isDark ? 30 : 90;
    if (isMonochrome(s)) return s.isDark ? 30 : 85;
    if (!isFidelity(s)) return initialTone;
    let answer = findDesiredChromaByTone(s.secondaryPalette.hue, s.secondaryPalette.chroma, initialTone, !s.isDark);
    return answer = performAlbers(s.secondaryPalette.getHct(answer), s), answer;
  },
  isBackground: true,
  background: (s) => MaterialDynamicColors.highestSurface(s),
  contrastCurve: new ContrastCurve(1, 1, 3, 7),
  toneDeltaPair: (s) => new ToneDeltaPair(MaterialDynamicColors.secondaryContainer, MaterialDynamicColors.secondary, 15, "nearer", false)
}), MaterialDynamicColors.onSecondaryContainer = DynamicColor.fromPalette({
  name: "on_secondary_container",
  palette: (s) => s.secondaryPalette,
  tone: (s) => isFidelity(s) ? DynamicColor.foregroundTone(MaterialDynamicColors.secondaryContainer.tone(s), 4.5) : s.isDark ? 90 : 10,
  background: (s) => MaterialDynamicColors.secondaryContainer,
  contrastCurve: new ContrastCurve(4.5, 7, 11, 21)
}), MaterialDynamicColors.tertiary = DynamicColor.fromPalette({
  name: "tertiary",
  palette: (s) => s.tertiaryPalette,
  tone: (s) => isMonochrome(s) ? s.isDark ? 90 : 25 : s.isDark ? 80 : 40,
  isBackground: true,
  background: (s) => MaterialDynamicColors.highestSurface(s),
  contrastCurve: new ContrastCurve(3, 4.5, 7, 11),
  toneDeltaPair: (s) => new ToneDeltaPair(MaterialDynamicColors.tertiaryContainer, MaterialDynamicColors.tertiary, 15, "nearer", false)
}), MaterialDynamicColors.onTertiary = DynamicColor.fromPalette({
  name: "on_tertiary",
  palette: (s) => s.tertiaryPalette,
  tone: (s) => isMonochrome(s) ? s.isDark ? 10 : 90 : s.isDark ? 20 : 100,
  background: (s) => MaterialDynamicColors.tertiary,
  contrastCurve: new ContrastCurve(4.5, 7, 11, 21)
}), MaterialDynamicColors.tertiaryContainer = DynamicColor.fromPalette({
  name: "tertiary_container",
  palette: (s) => s.tertiaryPalette,
  tone: (s) => {
    if (isMonochrome(s)) return s.isDark ? 60 : 49;
    if (!isFidelity(s)) return s.isDark ? 30 : 90;
    const albersTone = performAlbers(s.tertiaryPalette.getHct(s.sourceColorHct.tone), s), proposedHct = s.tertiaryPalette.getHct(albersTone);
    return DislikeAnalyzer.fixIfDisliked(proposedHct).tone;
  },
  isBackground: true,
  background: (s) => MaterialDynamicColors.highestSurface(s),
  contrastCurve: new ContrastCurve(1, 1, 3, 7),
  toneDeltaPair: (s) => new ToneDeltaPair(MaterialDynamicColors.tertiaryContainer, MaterialDynamicColors.tertiary, 15, "nearer", false)
}), MaterialDynamicColors.onTertiaryContainer = DynamicColor.fromPalette({
  name: "on_tertiary_container",
  palette: (s) => s.tertiaryPalette,
  tone: (s) => isMonochrome(s) ? s.isDark ? 0 : 100 : isFidelity(s) ? DynamicColor.foregroundTone(MaterialDynamicColors.tertiaryContainer.tone(s), 4.5) : s.isDark ? 90 : 10,
  background: (s) => MaterialDynamicColors.tertiaryContainer,
  contrastCurve: new ContrastCurve(4.5, 7, 11, 21)
}), MaterialDynamicColors.error = DynamicColor.fromPalette({
  name: "error",
  palette: (s) => s.errorPalette,
  tone: (s) => s.isDark ? 80 : 40,
  isBackground: true,
  background: (s) => MaterialDynamicColors.highestSurface(s),
  contrastCurve: new ContrastCurve(3, 4.5, 7, 11),
  toneDeltaPair: (s) => new ToneDeltaPair(MaterialDynamicColors.errorContainer, MaterialDynamicColors.error, 15, "nearer", false)
}), MaterialDynamicColors.onError = DynamicColor.fromPalette({
  name: "on_error",
  palette: (s) => s.errorPalette,
  tone: (s) => s.isDark ? 20 : 100,
  background: (s) => MaterialDynamicColors.error,
  contrastCurve: new ContrastCurve(4.5, 7, 11, 21)
}), MaterialDynamicColors.errorContainer = DynamicColor.fromPalette({
  name: "error_container",
  palette: (s) => s.errorPalette,
  tone: (s) => s.isDark ? 30 : 90,
  isBackground: true,
  background: (s) => MaterialDynamicColors.highestSurface(s),
  contrastCurve: new ContrastCurve(1, 1, 3, 7),
  toneDeltaPair: (s) => new ToneDeltaPair(MaterialDynamicColors.errorContainer, MaterialDynamicColors.error, 15, "nearer", false)
}), MaterialDynamicColors.onErrorContainer = DynamicColor.fromPalette({
  name: "on_error_container",
  palette: (s) => s.errorPalette,
  tone: (s) => s.isDark ? 90 : 10,
  background: (s) => MaterialDynamicColors.errorContainer,
  contrastCurve: new ContrastCurve(4.5, 7, 11, 21)
}), MaterialDynamicColors.primaryFixed = DynamicColor.fromPalette({
  name: "primary_fixed",
  palette: (s) => s.primaryPalette,
  tone: (s) => isMonochrome(s) ? 40 : 90,
  isBackground: true,
  background: (s) => MaterialDynamicColors.highestSurface(s),
  contrastCurve: new ContrastCurve(1, 1, 3, 7),
  toneDeltaPair: (s) => new ToneDeltaPair(MaterialDynamicColors.primaryFixed, MaterialDynamicColors.primaryFixedDim, 10, "lighter", true)
}), MaterialDynamicColors.primaryFixedDim = DynamicColor.fromPalette({
  name: "primary_fixed_dim",
  palette: (s) => s.primaryPalette,
  tone: (s) => isMonochrome(s) ? 30 : 80,
  isBackground: true,
  background: (s) => MaterialDynamicColors.highestSurface(s),
  contrastCurve: new ContrastCurve(1, 1, 3, 7),
  toneDeltaPair: (s) => new ToneDeltaPair(MaterialDynamicColors.primaryFixed, MaterialDynamicColors.primaryFixedDim, 10, "lighter", true)
}), MaterialDynamicColors.onPrimaryFixed = DynamicColor.fromPalette({
  name: "on_primary_fixed",
  palette: (s) => s.primaryPalette,
  tone: (s) => isMonochrome(s) ? 100 : 10,
  background: (s) => MaterialDynamicColors.primaryFixedDim,
  secondBackground: (s) => MaterialDynamicColors.primaryFixed,
  contrastCurve: new ContrastCurve(4.5, 7, 11, 21)
}), MaterialDynamicColors.onPrimaryFixedVariant = DynamicColor.fromPalette({
  name: "on_primary_fixed_variant",
  palette: (s) => s.primaryPalette,
  tone: (s) => isMonochrome(s) ? 90 : 30,
  background: (s) => MaterialDynamicColors.primaryFixedDim,
  secondBackground: (s) => MaterialDynamicColors.primaryFixed,
  contrastCurve: new ContrastCurve(3, 4.5, 7, 11)
}), MaterialDynamicColors.secondaryFixed = DynamicColor.fromPalette({
  name: "secondary_fixed",
  palette: (s) => s.secondaryPalette,
  tone: (s) => isMonochrome(s) ? 80 : 90,
  isBackground: true,
  background: (s) => MaterialDynamicColors.highestSurface(s),
  contrastCurve: new ContrastCurve(1, 1, 3, 7),
  toneDeltaPair: (s) => new ToneDeltaPair(MaterialDynamicColors.secondaryFixed, MaterialDynamicColors.secondaryFixedDim, 10, "lighter", true)
}), MaterialDynamicColors.secondaryFixedDim = DynamicColor.fromPalette({
  name: "secondary_fixed_dim",
  palette: (s) => s.secondaryPalette,
  tone: (s) => isMonochrome(s) ? 70 : 80,
  isBackground: true,
  background: (s) => MaterialDynamicColors.highestSurface(s),
  contrastCurve: new ContrastCurve(1, 1, 3, 7),
  toneDeltaPair: (s) => new ToneDeltaPair(MaterialDynamicColors.secondaryFixed, MaterialDynamicColors.secondaryFixedDim, 10, "lighter", true)
}), MaterialDynamicColors.onSecondaryFixed = DynamicColor.fromPalette({
  name: "on_secondary_fixed",
  palette: (s) => s.secondaryPalette,
  tone: (s) => 10,
  background: (s) => MaterialDynamicColors.secondaryFixedDim,
  secondBackground: (s) => MaterialDynamicColors.secondaryFixed,
  contrastCurve: new ContrastCurve(4.5, 7, 11, 21)
}), MaterialDynamicColors.onSecondaryFixedVariant = DynamicColor.fromPalette({
  name: "on_secondary_fixed_variant",
  palette: (s) => s.secondaryPalette,
  tone: (s) => isMonochrome(s) ? 25 : 30,
  background: (s) => MaterialDynamicColors.secondaryFixedDim,
  secondBackground: (s) => MaterialDynamicColors.secondaryFixed,
  contrastCurve: new ContrastCurve(3, 4.5, 7, 11)
}), MaterialDynamicColors.tertiaryFixed = DynamicColor.fromPalette({
  name: "tertiary_fixed",
  palette: (s) => s.tertiaryPalette,
  tone: (s) => isMonochrome(s) ? 40 : 90,
  isBackground: true,
  background: (s) => MaterialDynamicColors.highestSurface(s),
  contrastCurve: new ContrastCurve(1, 1, 3, 7),
  toneDeltaPair: (s) => new ToneDeltaPair(MaterialDynamicColors.tertiaryFixed, MaterialDynamicColors.tertiaryFixedDim, 10, "lighter", true)
}), MaterialDynamicColors.tertiaryFixedDim = DynamicColor.fromPalette({
  name: "tertiary_fixed_dim",
  palette: (s) => s.tertiaryPalette,
  tone: (s) => isMonochrome(s) ? 30 : 80,
  isBackground: true,
  background: (s) => MaterialDynamicColors.highestSurface(s),
  contrastCurve: new ContrastCurve(1, 1, 3, 7),
  toneDeltaPair: (s) => new ToneDeltaPair(MaterialDynamicColors.tertiaryFixed, MaterialDynamicColors.tertiaryFixedDim, 10, "lighter", true)
}), MaterialDynamicColors.onTertiaryFixed = DynamicColor.fromPalette({
  name: "on_tertiary_fixed",
  palette: (s) => s.tertiaryPalette,
  tone: (s) => isMonochrome(s) ? 100 : 10,
  background: (s) => MaterialDynamicColors.tertiaryFixedDim,
  secondBackground: (s) => MaterialDynamicColors.tertiaryFixed,
  contrastCurve: new ContrastCurve(4.5, 7, 11, 21)
}), MaterialDynamicColors.onTertiaryFixedVariant = DynamicColor.fromPalette({
  name: "on_tertiary_fixed_variant",
  palette: (s) => s.tertiaryPalette,
  tone: (s) => isMonochrome(s) ? 90 : 30,
  background: (s) => MaterialDynamicColors.tertiaryFixedDim,
  secondBackground: (s) => MaterialDynamicColors.tertiaryFixed,
  contrastCurve: new ContrastCurve(3, 4.5, 7, 11)
});
class TonalPalette {
  static fromInt(argb) {
    const hct = Hct.fromInt(argb);
    return TonalPalette.fromHct(hct);
  }
  static fromHct(hct) {
    return new TonalPalette(hct.hue, hct.chroma, hct);
  }
  static fromHueAndChroma(hue, chroma) {
    return new TonalPalette(hue, chroma, TonalPalette.createKeyColor(hue, chroma));
  }
  constructor(hue, chroma, keyColor) {
    this.hue = hue, this.chroma = chroma, this.keyColor = keyColor, this.cache = /* @__PURE__ */ new Map();
  }
  static createKeyColor(hue, chroma) {
    let smallestDeltaHct = Hct.from(hue, chroma, 50), smallestDelta = Math.abs(smallestDeltaHct.chroma - chroma);
    for (let delta = 1; delta < 50; delta += 1) {
      if (Math.round(chroma) === Math.round(smallestDeltaHct.chroma)) return smallestDeltaHct;
      const hctAdd = Hct.from(hue, chroma, 50 + delta), hctAddDelta = Math.abs(hctAdd.chroma - chroma);
      hctAddDelta < smallestDelta && (smallestDelta = hctAddDelta, smallestDeltaHct = hctAdd);
      const hctSubtract = Hct.from(hue, chroma, 50 - delta), hctSubtractDelta = Math.abs(hctSubtract.chroma - chroma);
      hctSubtractDelta < smallestDelta && (smallestDelta = hctSubtractDelta, smallestDeltaHct = hctSubtract);
    }
    return smallestDeltaHct;
  }
  tone(tone) {
    let argb = this.cache.get(tone);
    return void 0 === argb && (argb = Hct.from(this.hue, this.chroma, tone).toInt(), this.cache.set(tone, argb)), argb;
  }
  getHct(tone) {
    return Hct.fromInt(this.tone(tone));
  }
}
class CorePalette {
  static of(argb) {
    return new CorePalette(argb, false);
  }
  static contentOf(argb) {
    return new CorePalette(argb, true);
  }
  static fromColors(colors) {
    return CorePalette.createPaletteFromColors(false, colors);
  }
  static contentFromColors(colors) {
    return CorePalette.createPaletteFromColors(true, colors);
  }
  static createPaletteFromColors(content, colors) {
    const palette = new CorePalette(colors.primary, content);
    if (colors.secondary) {
      const p = new CorePalette(colors.secondary, content);
      palette.a2 = p.a1;
    }
    if (colors.tertiary) {
      const p = new CorePalette(colors.tertiary, content);
      palette.a3 = p.a1;
    }
    if (colors.error) {
      const p = new CorePalette(colors.error, content);
      palette.error = p.a1;
    }
    if (colors.neutral) {
      const p = new CorePalette(colors.neutral, content);
      palette.n1 = p.n1;
    }
    if (colors.neutralVariant) {
      const p = new CorePalette(colors.neutralVariant, content);
      palette.n2 = p.n2;
    }
    return palette;
  }
  constructor(argb, isContent) {
    const hct = Hct.fromInt(argb), hue = hct.hue, chroma = hct.chroma;
    isContent ? (this.a1 = TonalPalette.fromHueAndChroma(hue, chroma), this.a2 = TonalPalette.fromHueAndChroma(hue, chroma / 3), this.a3 = TonalPalette.fromHueAndChroma(hue + 60, chroma / 2), this.n1 = TonalPalette.fromHueAndChroma(hue, Math.min(chroma / 12, 4)), this.n2 = TonalPalette.fromHueAndChroma(hue, Math.min(chroma / 6, 8))) : (this.a1 = TonalPalette.fromHueAndChroma(hue, Math.max(48, chroma)), this.a2 = TonalPalette.fromHueAndChroma(hue, 16), this.a3 = TonalPalette.fromHueAndChroma(hue + 60, 24), this.n1 = TonalPalette.fromHueAndChroma(hue, 4), this.n2 = TonalPalette.fromHueAndChroma(hue, 8)), this.error = TonalPalette.fromHueAndChroma(25, 84);
  }
}
class Scheme {
  get primary() {
    return this.props.primary;
  }
  get onPrimary() {
    return this.props.onPrimary;
  }
  get primaryContainer() {
    return this.props.primaryContainer;
  }
  get onPrimaryContainer() {
    return this.props.onPrimaryContainer;
  }
  get secondary() {
    return this.props.secondary;
  }
  get onSecondary() {
    return this.props.onSecondary;
  }
  get secondaryContainer() {
    return this.props.secondaryContainer;
  }
  get onSecondaryContainer() {
    return this.props.onSecondaryContainer;
  }
  get tertiary() {
    return this.props.tertiary;
  }
  get onTertiary() {
    return this.props.onTertiary;
  }
  get tertiaryContainer() {
    return this.props.tertiaryContainer;
  }
  get onTertiaryContainer() {
    return this.props.onTertiaryContainer;
  }
  get error() {
    return this.props.error;
  }
  get onError() {
    return this.props.onError;
  }
  get errorContainer() {
    return this.props.errorContainer;
  }
  get onErrorContainer() {
    return this.props.onErrorContainer;
  }
  get background() {
    return this.props.background;
  }
  get onBackground() {
    return this.props.onBackground;
  }
  get surface() {
    return this.props.surface;
  }
  get onSurface() {
    return this.props.onSurface;
  }
  get surfaceVariant() {
    return this.props.surfaceVariant;
  }
  get onSurfaceVariant() {
    return this.props.onSurfaceVariant;
  }
  get outline() {
    return this.props.outline;
  }
  get outlineVariant() {
    return this.props.outlineVariant;
  }
  get shadow() {
    return this.props.shadow;
  }
  get scrim() {
    return this.props.scrim;
  }
  get inverseSurface() {
    return this.props.inverseSurface;
  }
  get inverseOnSurface() {
    return this.props.inverseOnSurface;
  }
  get inversePrimary() {
    return this.props.inversePrimary;
  }
  static light(argb) {
    return Scheme.lightFromCorePalette(CorePalette.of(argb));
  }
  static dark(argb) {
    return Scheme.darkFromCorePalette(CorePalette.of(argb));
  }
  static lightContent(argb) {
    return Scheme.lightFromCorePalette(CorePalette.contentOf(argb));
  }
  static darkContent(argb) {
    return Scheme.darkFromCorePalette(CorePalette.contentOf(argb));
  }
  static lightFromCorePalette(core) {
    return new Scheme({
      primary: core.a1.tone(40),
      onPrimary: core.a1.tone(100),
      primaryContainer: core.a1.tone(90),
      onPrimaryContainer: core.a1.tone(10),
      secondary: core.a2.tone(40),
      onSecondary: core.a2.tone(100),
      secondaryContainer: core.a2.tone(90),
      onSecondaryContainer: core.a2.tone(10),
      tertiary: core.a3.tone(40),
      onTertiary: core.a3.tone(100),
      tertiaryContainer: core.a3.tone(90),
      onTertiaryContainer: core.a3.tone(10),
      error: core.error.tone(40),
      onError: core.error.tone(100),
      errorContainer: core.error.tone(90),
      onErrorContainer: core.error.tone(10),
      background: core.n1.tone(99),
      onBackground: core.n1.tone(10),
      surface: core.n1.tone(99),
      onSurface: core.n1.tone(10),
      surfaceVariant: core.n2.tone(90),
      onSurfaceVariant: core.n2.tone(30),
      outline: core.n2.tone(50),
      outlineVariant: core.n2.tone(80),
      shadow: core.n1.tone(0),
      scrim: core.n1.tone(0),
      inverseSurface: core.n1.tone(20),
      inverseOnSurface: core.n1.tone(95),
      inversePrimary: core.a1.tone(80)
    });
  }
  static darkFromCorePalette(core) {
    return new Scheme({
      primary: core.a1.tone(80),
      onPrimary: core.a1.tone(20),
      primaryContainer: core.a1.tone(30),
      onPrimaryContainer: core.a1.tone(90),
      secondary: core.a2.tone(80),
      onSecondary: core.a2.tone(20),
      secondaryContainer: core.a2.tone(30),
      onSecondaryContainer: core.a2.tone(90),
      tertiary: core.a3.tone(80),
      onTertiary: core.a3.tone(20),
      tertiaryContainer: core.a3.tone(30),
      onTertiaryContainer: core.a3.tone(90),
      error: core.error.tone(80),
      onError: core.error.tone(20),
      errorContainer: core.error.tone(30),
      onErrorContainer: core.error.tone(80),
      background: core.n1.tone(10),
      onBackground: core.n1.tone(90),
      surface: core.n1.tone(10),
      onSurface: core.n1.tone(90),
      surfaceVariant: core.n2.tone(30),
      onSurfaceVariant: core.n2.tone(80),
      outline: core.n2.tone(60),
      outlineVariant: core.n2.tone(30),
      shadow: core.n1.tone(0),
      scrim: core.n1.tone(0),
      inverseSurface: core.n1.tone(90),
      inverseOnSurface: core.n1.tone(20),
      inversePrimary: core.a1.tone(40)
    });
  }
  constructor(props) {
    this.props = props;
  }
  toJSON() {
    return {
      ...this.props
    };
  }
}
function hexFromArgb(argb) {
  const r = redFromArgb(argb), g = greenFromArgb(argb), b = blueFromArgb(argb), outParts = [r.toString(16), g.toString(16), b.toString(16)];
  for (const [i, part] of outParts.entries()) 1 === part.length && (outParts[i] = "0" + part);
  return "#" + outParts.join("");
}
function argbFromHex(hex) {
  const isThree = 3 === (hex = hex.replace("#", "")).length, isSix = 6 === hex.length, isEight = 8 === hex.length;
  if (!isThree && !isSix && !isEight) throw new Error("unexpected hex " + hex);
  let r = 0, g = 0, b = 0;
  return isThree ? (r = parseIntHex(hex.slice(0, 1).repeat(2)), g = parseIntHex(hex.slice(1, 2).repeat(2)), b = parseIntHex(hex.slice(2, 3).repeat(2))) : isSix ? (r = parseIntHex(hex.slice(0, 2)), g = parseIntHex(hex.slice(2, 4)), b = parseIntHex(hex.slice(4, 6))) : isEight && (r = parseIntHex(hex.slice(2, 4)), g = parseIntHex(hex.slice(4, 6)), b = parseIntHex(hex.slice(6, 8))), (255 << 24 | (255 & r) << 16 | (255 & g) << 8 | 255 & b) >>> 0;
}
function parseIntHex(value2) {
  return parseInt(value2, 16);
}
function themeFromSourceColor(source, customColors) {
  if (customColors === void 0) {
    customColors = [];
  }
  const palette = CorePalette.of(source);
  return {
    source,
    schemes: {
      light: Scheme.light(source),
      dark: Scheme.dark(source)
    },
    palettes: {
      primary: palette.a1,
      secondary: palette.a2,
      tertiary: palette.a3,
      neutral: palette.n1,
      neutralVariant: palette.n2,
      error: palette.error
    },
    customColors: customColors.map((c) => customColor(source, c))
  };
}
function customColor(source, color) {
  let value2 = color.value;
  const from = value2, to = source;
  color.blend && (value2 = Blend.harmonize(from, to));
  const tones = CorePalette.of(value2).a1;
  return {
    color,
    value: value2,
    light: {
      color: tones.tone(40),
      onColor: tones.tone(100),
      colorContainer: tones.tone(90),
      onColorContainer: tones.tone(10)
    },
    dark: {
      color: tones.tone(80),
      onColor: tones.tone(20),
      colorContainer: tones.tone(30),
      onColorContainer: tones.tone(90)
    }
  };
}
function toRGBA(d) {
  const r = Math.round;
  const l = d.length;
  const rgba = {};
  if (d.slice(0, 3).toLowerCase() === "rgb") {
    d = d.replace(" ", "").split(",");
    rgba[0] = parseInt(d[0].slice(d[3].toLowerCase() === "a" ? 5 : 4), 10);
    rgba[1] = parseInt(d[1], 10);
    rgba[2] = parseInt(d[2], 10);
    rgba[3] = d[3] ? parseFloat(d[3]) : -1;
  } else {
    if (l < 6) d = parseInt(String(d[1]) + d[1] + d[2] + d[2] + d[3] + d[3] + (l > 4 ? String(d[4]) + d[4] : ""), 16);
    else d = parseInt(d.slice(1), 16);
    rgba[0] = d >> 16 & 255;
    rgba[1] = d >> 8 & 255;
    rgba[2] = d & 255;
    rgba[3] = l === 9 || l === 5 ? r((d >> 24 & 255) / 255 * 1e4) / 1e4 : -1;
  }
  return rgba;
}
function blend(from, to, p) {
  if (p === void 0) {
    p = 0.5;
  }
  const r = Math.round;
  from = from.trim();
  to = to.trim();
  const b = p < 0;
  p = b ? p * -1 : p;
  const f = toRGBA(from);
  const t2 = toRGBA(to);
  if (to[0] === "r") {
    return "rgb" + (to[3] === "a" ? "a(" : "(") + r((t2[0] - f[0]) * p + f[0]) + "," + r((t2[1] - f[1]) * p + f[1]) + "," + r((t2[2] - f[2]) * p + f[2]) + (f[3] < 0 && t2[3] < 0 ? "" : "," + (f[3] > -1 && t2[3] > -1 ? r(((t2[3] - f[3]) * p + f[3]) * 1e4) / 1e4 : t2[3] < 0 ? f[3] : t2[3])) + ")";
  }
  return "#" + (4294967296 + (f[3] > -1 && t2[3] > -1 ? r(((t2[3] - f[3]) * p + f[3]) * 255) : t2[3] > -1 ? r(t2[3] * 255) : f[3] > -1 ? r(f[3] * 255) : 255) * 16777216 + r((t2[0] - f[0]) * p + f[0]) * 65536 + r((t2[1] - f[1]) * p + f[1]) * 256 + r((t2[2] - f[2]) * p + f[2])).toString(16).slice(f[3] > -1 || t2[3] > -1 ? 1 : 3);
}
const materialColors = function(hexColor) {
  if (hexColor === void 0) {
    hexColor = "";
  }
  const theme = themeFromSourceColor(argbFromHex(`#${hexColor.replace("#", "")}`));
  [0.05, 0.08, 0.11, 0.12, 0.14].forEach((amount, index2) => {
    theme.schemes.light.props[`surface${index2 + 1}`] = argbFromHex(blend(hexFromArgb(theme.schemes.light.props.surface), hexFromArgb(theme.schemes.light.props.primary), amount));
    theme.schemes.dark.props[`surface${index2 + 1}`] = argbFromHex(blend(hexFromArgb(theme.schemes.dark.props.surface), hexFromArgb(theme.schemes.dark.props.primary), amount));
  });
  const name = (n2) => {
    return n2.split("").map((char) => char.toUpperCase() === char && char !== "-" && char !== "7" ? `-${char.toLowerCase()}` : char).join("");
  };
  const shouldSkip = (prop2) => {
    const skip = ["tertiary", "shadow", "scrim", "error", "background"];
    return skip.filter((v) => prop2.toLowerCase().includes(v)).length > 0;
  };
  const light = {};
  const dark = {};
  Object.keys(theme.schemes.light.props).forEach((prop2) => {
    if (shouldSkip(prop2)) return;
    light[name(`--f7-md-${prop2}`)] = hexFromArgb(theme.schemes.light.props[prop2]);
  });
  Object.keys(theme.schemes.dark.props).forEach((prop2) => {
    if (shouldSkip(prop2)) return;
    dark[name(`--f7-md-${prop2}`)] = hexFromArgb(theme.schemes.dark.props[prop2]);
  });
  return {
    light,
    dark
  };
};
let uniqueNum = 0;
function uniqueNumber() {
  uniqueNum += 1;
  return uniqueNum;
}
function id(mask, map) {
  if (mask === void 0) {
    mask = "xxxxxxxxxx";
  }
  if (map === void 0) {
    map = "0123456789abcdef";
  }
  const length = map.length;
  return mask.replace(/x/g, () => map[Math.floor(Math.random() * length)]);
}
const mdPreloaderContent = `
  <span class="preloader-inner">
    <svg viewBox="0 0 36 36">
      <circle cx="18" cy="18" r="16"></circle>
    </svg>
  </span>
`.trim();
const iosPreloaderContent = `
  <span class="preloader-inner">
    ${[0, 1, 2, 3, 4, 5, 6, 7].map(() => '<span class="preloader-inner-line"></span>').join("")}
  </span>
`.trim();
function eventNameToColonCase(eventName) {
  let hasColon;
  return eventName.split("").map((char, index2) => {
    if (char.match(/[A-Z]/) && index2 !== 0 && !hasColon) {
      hasColon = true;
      return `:${char.toLowerCase()}`;
    }
    return char.toLowerCase();
  }).join("");
}
function deleteProps(obj) {
  const object = obj;
  Object.keys(object).forEach((key) => {
    try {
      object[key] = null;
    } catch (e) {
    }
    try {
      delete object[key];
    } catch (e) {
    }
  });
}
function requestAnimationFrame(callback) {
  const window2 = getWindow();
  return window2.requestAnimationFrame(callback);
}
function cancelAnimationFrame(frameId) {
  const window2 = getWindow();
  return window2.cancelAnimationFrame(frameId);
}
function nextTick(callback, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return setTimeout(callback, delay);
}
function nextFrame$1(callback) {
  return requestAnimationFrame(() => {
    requestAnimationFrame(callback);
  });
}
function now$1() {
  return Date.now();
}
function parseUrlQuery(url) {
  const window2 = getWindow();
  const query = {};
  let urlToParse = url || window2.location.href;
  let i;
  let params;
  let param;
  let length;
  if (typeof urlToParse === "string" && urlToParse.length) {
    urlToParse = urlToParse.indexOf("?") > -1 ? urlToParse.replace(/\S*\?/, "") : "";
    params = urlToParse.split("&").filter((paramsPart) => paramsPart !== "");
    length = params.length;
    for (i = 0; i < length; i += 1) {
      param = params[i].replace(/#\S+/g, "").split("=");
      query[decodeURIComponent(param[0])] = typeof param[1] === "undefined" ? void 0 : decodeURIComponent(param.slice(1).join("=")) || "";
    }
  }
  return query;
}
function getTranslate(el, axis) {
  if (axis === void 0) {
    axis = "x";
  }
  const window2 = getWindow();
  let matrix;
  let curTransform;
  let transformMatrix;
  const curStyle = window2.getComputedStyle(el, null);
  if (window2.WebKitCSSMatrix) {
    curTransform = curStyle.transform || curStyle.webkitTransform;
    if (curTransform.split(",").length > 6) {
      curTransform = curTransform.split(", ").map((a) => a.replace(",", ".")).join(", ");
    }
    transformMatrix = new window2.WebKitCSSMatrix(curTransform === "none" ? "" : curTransform);
  } else {
    transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,");
    matrix = transformMatrix.toString().split(",");
  }
  if (axis === "x") {
    if (window2.WebKitCSSMatrix) curTransform = transformMatrix.m41;
    else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);
    else curTransform = parseFloat(matrix[4]);
  }
  if (axis === "y") {
    if (window2.WebKitCSSMatrix) curTransform = transformMatrix.m42;
    else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);
    else curTransform = parseFloat(matrix[5]);
  }
  return curTransform || 0;
}
function serializeObject(obj, parents2) {
  if (parents2 === void 0) {
    parents2 = [];
  }
  if (typeof obj === "string") return obj;
  const resultArray = [];
  const separator = "&";
  let newParents;
  function varName(name) {
    if (parents2.length > 0) {
      let parentParts = "";
      for (let j = 0; j < parents2.length; j += 1) {
        if (j === 0) parentParts += parents2[j];
        else parentParts += `[${encodeURIComponent(parents2[j])}]`;
      }
      return `${parentParts}[${encodeURIComponent(name)}]`;
    }
    return encodeURIComponent(name);
  }
  function varValue(value2) {
    return encodeURIComponent(value2);
  }
  Object.keys(obj).forEach((prop2) => {
    let toPush;
    if (Array.isArray(obj[prop2])) {
      toPush = [];
      for (let i = 0; i < obj[prop2].length; i += 1) {
        if (!Array.isArray(obj[prop2][i]) && typeof obj[prop2][i] === "object") {
          newParents = parents2.slice();
          newParents.push(prop2);
          newParents.push(String(i));
          toPush.push(serializeObject(obj[prop2][i], newParents));
        } else {
          toPush.push(`${varName(prop2)}[]=${varValue(obj[prop2][i])}`);
        }
      }
      if (toPush.length > 0) resultArray.push(toPush.join(separator));
    } else if (obj[prop2] === null || obj[prop2] === "") {
      resultArray.push(`${varName(prop2)}=`);
    } else if (typeof obj[prop2] === "object") {
      newParents = parents2.slice();
      newParents.push(prop2);
      toPush = serializeObject(obj[prop2], newParents);
      if (toPush !== "") resultArray.push(toPush);
    } else if (typeof obj[prop2] !== "undefined" && obj[prop2] !== "") {
      resultArray.push(`${varName(prop2)}=${varValue(obj[prop2])}`);
    } else if (obj[prop2] === "") resultArray.push(varName(prop2));
  });
  return resultArray.join(separator);
}
function isObject$1(o) {
  return typeof o === "object" && o !== null && o.constructor && o.constructor === Object;
}
function merge() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  const to = args[0];
  args.splice(0, 1);
  const from = args;
  for (let i = 0; i < from.length; i += 1) {
    const nextSource = args[i];
    if (nextSource !== void 0 && nextSource !== null) {
      const keysArray = Object.keys(Object(nextSource));
      for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
        const nextKey = keysArray[nextIndex];
        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
        if (desc !== void 0 && desc.enumerable) {
          to[nextKey] = nextSource[nextKey];
        }
      }
    }
  }
  return to;
}
function extend$1() {
  let deep = true;
  let to;
  let from;
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }
  if (typeof args[0] === "boolean") {
    deep = args[0];
    to = args[1];
    args.splice(0, 2);
    from = args;
  } else {
    to = args[0];
    args.splice(0, 1);
    from = args;
  }
  for (let i = 0; i < from.length; i += 1) {
    const nextSource = args[i];
    if (nextSource !== void 0 && nextSource !== null) {
      const keysArray = Object.keys(Object(nextSource));
      for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
        const nextKey = keysArray[nextIndex];
        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
        if (desc !== void 0 && desc.enumerable) {
          if (!deep) {
            to[nextKey] = nextSource[nextKey];
          } else if (isObject$1(to[nextKey]) && isObject$1(nextSource[nextKey])) {
            extend$1(to[nextKey], nextSource[nextKey]);
          } else if (!isObject$1(to[nextKey]) && isObject$1(nextSource[nextKey])) {
            to[nextKey] = {};
            extend$1(to[nextKey], nextSource[nextKey]);
          } else {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
  }
  return to;
}
function colorHexToRgb(hex) {
  const h2 = hex.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, (m, r, g, b) => r + r + g + g + b + b);
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(h2);
  return result ? result.slice(1).map((n2) => parseInt(n2, 16)) : null;
}
function colorRgbToHex(r, g, b) {
  const result = [r, g, b].map((n2) => {
    const hex = n2.toString(16);
    return hex.length === 1 ? `0${hex}` : hex;
  }).join("");
  return `#${result}`;
}
function colorRgbToHsl(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const d = max - min;
  let h2;
  if (d === 0) h2 = 0;
  else if (max === r) h2 = (g - b) / d % 6;
  else if (max === g) h2 = (b - r) / d + 2;
  else if (max === b) h2 = (r - g) / d + 4;
  const l = (min + max) / 2;
  const s = d === 0 ? 0 : d / (1 - Math.abs(2 * l - 1));
  if (h2 < 0) h2 = 360 / 60 + h2;
  return [h2 * 60, s, l];
}
function colorHslToRgb(h2, s, l) {
  const c = (1 - Math.abs(2 * l - 1)) * s;
  const hp = h2 / 60;
  const x = c * (1 - Math.abs(hp % 2 - 1));
  let rgb1;
  if (Number.isNaN(h2) || typeof h2 === "undefined") {
    rgb1 = [0, 0, 0];
  } else if (hp <= 1) rgb1 = [c, x, 0];
  else if (hp <= 2) rgb1 = [x, c, 0];
  else if (hp <= 3) rgb1 = [0, c, x];
  else if (hp <= 4) rgb1 = [0, x, c];
  else if (hp <= 5) rgb1 = [x, 0, c];
  else if (hp <= 6) rgb1 = [c, 0, x];
  const m = l - c / 2;
  return rgb1.map((n2) => Math.max(0, Math.min(255, Math.round(255 * (n2 + m)))));
}
function colorHsbToHsl(h2, s, b) {
  const HSL = {
    h: h2,
    s: 0,
    l: 0
  };
  const HSB = {
    h: h2,
    s,
    b
  };
  HSL.l = (2 - HSB.s) * HSB.b / 2;
  HSL.s = HSL.l && HSL.l < 1 ? HSB.s * HSB.b / (HSL.l < 0.5 ? HSL.l * 2 : 2 - HSL.l * 2) : HSL.s;
  return [HSL.h, HSL.s, HSL.l];
}
function colorHslToHsb(h2, s, l) {
  const HSB = {
    h: h2,
    s: 0,
    b: 0
  };
  const HSL = {
    h: h2,
    s,
    l
  };
  const t2 = HSL.s * (HSL.l < 0.5 ? HSL.l : 1 - HSL.l);
  HSB.b = HSL.l + t2;
  HSB.s = HSL.l > 0 ? 2 * t2 / HSB.b : HSB.s;
  return [HSB.h, HSB.s, HSB.b];
}
const getShadeTintColors = (rgb) => {
  const hsl = colorRgbToHsl(...rgb);
  const hslShade = [hsl[0], hsl[1], Math.max(0, hsl[2] - 0.08)];
  const hslTint = [hsl[0], hsl[1], Math.max(0, hsl[2] + 0.08)];
  const shade = colorRgbToHex(...colorHslToRgb(...hslShade));
  const tint = colorRgbToHex(...colorHslToRgb(...hslTint));
  return {
    shade,
    tint
  };
};
function colorThemeCSSProperties() {
  let hex;
  let rgb;
  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    args[_key3] = arguments[_key3];
  }
  if (args.length === 1) {
    hex = args[0];
    rgb = colorHexToRgb(hex);
  } else if (args.length === 3) {
    rgb = args;
    hex = colorRgbToHex(...rgb);
  }
  if (!rgb) return {};
  const {
    light,
    dark
  } = materialColors(hex);
  const shadeTintIos = getShadeTintColors(rgb);
  const shadeTintMdLight = getShadeTintColors(colorHexToRgb(light["--f7-md-primary"]));
  const shadeTintMdDark = getShadeTintColors(colorHexToRgb(dark["--f7-md-primary"]));
  Object.keys(light).forEach((key) => {
    if (key.includes("surface-")) {
      light[`${key}-rgb`] = colorHexToRgb(light[key]);
    }
  });
  Object.keys(dark).forEach((key) => {
    if (key.includes("surface-")) {
      dark[`${key}-rgb`] = colorHexToRgb(dark[key]);
    }
  });
  return {
    ios: {
      "--f7-theme-color": "var(--f7-ios-primary)",
      "--f7-theme-color-rgb": "var(--f7-ios-primary-rgb)",
      "--f7-theme-color-shade": "var(--f7-ios-primary-shade)",
      "--f7-theme-color-tint": "var(--f7-ios-primary-tint)"
    },
    md: {
      "--f7-theme-color": "var(--f7-md-primary)",
      "--f7-theme-color-rgb": "var(--f7-md-primary-rgb)",
      "--f7-theme-color-shade": "var(--f7-md-primary-shade)",
      "--f7-theme-color-tint": "var(--f7-md-primary-tint)"
    },
    light: {
      "--f7-ios-primary": hex,
      "--f7-ios-primary-shade": shadeTintIos.shade,
      "--f7-ios-primary-tint": shadeTintIos.tint,
      "--f7-ios-primary-rgb": rgb.join(", "),
      "--f7-md-primary-shade": shadeTintMdLight.shade,
      "--f7-md-primary-tint": shadeTintMdLight.tint,
      "--f7-md-primary-rgb": colorHexToRgb(light["--f7-md-primary"]).join(", "),
      ...light
    },
    dark: {
      "--f7-md-primary-shade": shadeTintMdDark.shade,
      "--f7-md-primary-tint": shadeTintMdDark.tint,
      "--f7-md-primary-rgb": colorHexToRgb(dark["--f7-md-primary"]).join(", "),
      ...dark
    }
  };
}
function bindMethods(instance2, obj) {
  Object.keys(obj).forEach((key) => {
    if (isObject$1(obj[key])) {
      Object.keys(obj[key]).forEach((subKey) => {
        if (typeof obj[key][subKey] === "function") {
          obj[key][subKey] = obj[key][subKey].bind(instance2);
        }
      });
    }
    instance2[key] = obj[key];
  });
}
function flattenArray() {
  const arr = [];
  for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    args[_key4] = arguments[_key4];
  }
  args.forEach((arg) => {
    if (Array.isArray(arg)) arr.push(...flattenArray(...arg));
    else arr.push(arg);
  });
  return arr;
}
function colorThemeCSSStyles(colors) {
  if (colors === void 0) {
    colors = {};
  }
  const stringifyObject = (obj) => {
    let res = "";
    Object.keys(obj).forEach((key) => {
      res += `${key}:${obj[key]};`;
    });
    return res;
  };
  const colorVars = colorThemeCSSProperties(colors.primary);
  const primary = [`:root{`, stringifyObject(colorVars.light), `--swiper-theme-color:var(--f7-theme-color);`, ...Object.keys(colors).map((colorName) => `--f7-color-${colorName}: ${colors[colorName]};`), `}`, `.dark{`, stringifyObject(colorVars.dark), `}`, `.ios, .ios .dark{`, stringifyObject(colorVars.ios), "}", `.md, .md .dark{`, stringifyObject(colorVars.md), "}"].join("");
  const restVars = {};
  Object.keys(colors).forEach((colorName) => {
    const colorValue = colors[colorName];
    restVars[colorName] = colorThemeCSSProperties(colorValue);
  });
  let rest = "";
  Object.keys(colors).forEach((colorName) => {
    const {
      light,
      dark,
      ios,
      md
    } = restVars[colorName];
    const whiteColorVars = `
    --f7-ios-primary: #ffffff;
    --f7-ios-primary-shade: #ebebeb;
    --f7-ios-primary-tint: #ffffff;
    --f7-ios-primary-rgb: 255, 255, 255;
    --f7-md-primary-shade: #eee;
    --f7-md-primary-tint: #fff;
    --f7-md-primary-rgb: 255, 255, 255;
    --f7-md-primary: #fff;
    --f7-md-on-primary: #000;
    --f7-md-primary-container: #fff;
    --f7-md-on-primary-container: #000;
    --f7-md-secondary: #fff;
    --f7-md-on-secondary: #000;
    --f7-md-secondary-container: #555;
    --f7-md-on-secondary-container: #fff;
    --f7-md-surface: #fff;
    --f7-md-on-surface: #000;
    --f7-md-surface-variant: #333;
    --f7-md-on-surface-variant: #fff;
    --f7-md-outline: #fff;
    --f7-md-outline-variant: #fff;
    --f7-md-inverse-surface: #000;
    --f7-md-inverse-on-surface: #fff;
    --f7-md-inverse-primary: #000;
    --f7-md-surface-1: #f8f8f8;
    --f7-md-surface-2: #f1f1f1;
    --f7-md-surface-3: #e7e7e7;
    --f7-md-surface-4: #e1e1e1;
    --f7-md-surface-5: #d7d7d7;
    --f7-md-surface-variant-rgb: 51, 51, 51;
    --f7-md-on-surface-variant-rgb: 255, 255, 255;
    --f7-md-surface-1-rgb: 248, 248, 248;
    --f7-md-surface-2-rgb: 241, 241, 241;
    --f7-md-surface-3-rgb: 231, 231, 231;
    --f7-md-surface-4-rgb: 225, 225, 225;
    --f7-md-surface-5-rgb: 215, 215, 215;
    `;
    const blackColorVars = `
    --f7-ios-primary: #000;
    --f7-ios-primary-shade: #000;
    --f7-ios-primary-tint: #232323;
    --f7-ios-primary-rgb: 0, 0, 0;
    --f7-md-primary-shade: #000;
    --f7-md-primary-tint: #232323;
    --f7-md-primary-rgb: 0, 0, 0;
    --f7-md-primary: #000;
    --f7-md-on-primary: #fff;
    --f7-md-primary-container: #000;
    --f7-md-on-primary-container: #fff;
    --f7-md-secondary: #000;
    --f7-md-on-secondary: #fff;
    --f7-md-secondary-container: #aaa;
    --f7-md-on-secondary-container: #000;
    --f7-md-surface: #000;
    --f7-md-on-surface: #fff;
    --f7-md-surface-variant: #ccc;
    --f7-md-on-surface-variant: #000;
    --f7-md-outline: #000;
    --f7-md-outline-variant: #000;
    --f7-md-inverse-surface: #fff;
    --f7-md-inverse-on-surface: #000;
    --f7-md-inverse-primary: #fff;
    --f7-md-surface-1: #070707;
    --f7-md-surface-2: #161616;
    --f7-md-surface-3: #232323;
    --f7-md-surface-4: #303030;
    --f7-md-surface-5: #373737;
    --f7-md-surface-variant-rgb: 204, 204, 204;
    --f7-md-on-surface-variant-rgb: 0, 0, 0;
    --f7-md-surface-1-rgb: 7, 7, 7;
    --f7-md-surface-2-rgb: 22, 22, 22;
    --f7-md-surface-3-rgb: 35, 35, 35;
    --f7-md-surface-4-rgb: 48, 48, 48;
    --f7-md-surface-5-rgb: 55, 55, 55;
    `;
    const lightString = colorName === "white" ? whiteColorVars : colorName === "black" ? blackColorVars : stringifyObject(light);
    const darkString = colorName === "white" ? whiteColorVars : colorName === "black" ? blackColorVars : stringifyObject(dark);
    rest += [
      `.color-${colorName} {`,
      lightString,
      `--swiper-theme-color: var(--f7-theme-color);`,
      `}`,
      `.color-${colorName}.dark, .color-${colorName} .dark, .dark .color-${colorName} {`,
      darkString,
      `--swiper-theme-color: var(--f7-theme-color);`,
      `}`,
      `.ios .color-${colorName}, .ios.color-${colorName}, .ios .dark .color-${colorName}, .ios .dark.color-${colorName} {`,
      stringifyObject(ios),
      `}`,
      `.md .color-${colorName}, .md.color-${colorName}, .md .dark .color-${colorName}, .md .dark.color-${colorName} {`,
      stringifyObject(md),
      `}`,
      // text color
      `.text-color-${colorName} {`,
      `--f7-theme-color-text-color: ${colors[colorName]};`,
      `}`,
      // bg color
      `.bg-color-${colorName} {`,
      `--f7-theme-color-bg-color: ${colors[colorName]};`,
      `}`,
      // border color
      `.border-color-${colorName} {`,
      `--f7-theme-color-border-color: ${colors[colorName]};`,
      `}`,
      // ripple color
      `.ripple-color-${colorName} {`,
      `--f7-theme-color-ripple-color: rgba(${light["--f7-ios-primary-rgb"]}, 0.3);`,
      `}`
    ].join("");
  });
  return `${primary}${rest}`;
}
const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bindMethods,
  cancelAnimationFrame,
  colorHexToRgb,
  colorHsbToHsl,
  colorHslToHsb,
  colorHslToRgb,
  colorRgbToHex,
  colorRgbToHsl,
  colorThemeCSSProperties,
  colorThemeCSSStyles,
  deleteProps,
  eventNameToColonCase,
  extend: extend$1,
  flattenArray,
  getTranslate,
  id,
  iosPreloaderContent,
  isObject: isObject$1,
  mdPreloaderContent,
  merge,
  nextFrame: nextFrame$1,
  nextTick,
  now: now$1,
  parseUrlQuery,
  requestAnimationFrame,
  serializeObject,
  uniqueNumber
}, Symbol.toStringTag, { value: "Module" }));
let support;
function calcSupport() {
  const window2 = getWindow();
  const document2 = getDocument();
  return {
    touch: !!("ontouchstart" in window2 || window2.DocumentTouch && document2 instanceof window2.DocumentTouch),
    pointerEvents: !!window2.PointerEvent && "maxTouchPoints" in window2.navigator && window2.navigator.maxTouchPoints >= 0,
    passiveListener: function checkPassiveListener() {
      let supportsPassive = false;
      try {
        const opts = Object.defineProperty({}, "passive", {
          // eslint-disable-next-line
          get() {
            supportsPassive = true;
          }
        });
        window2.addEventListener("testPassiveListener", null, opts);
      } catch (e) {
      }
      return supportsPassive;
    }(),
    intersectionObserver: function checkObserver() {
      return "IntersectionObserver" in window2;
    }()
  };
}
function getSupport() {
  if (!support) {
    support = calcSupport();
  }
  return support;
}
let deviceCalculated;
function calcDevice(_temp) {
  let {
    userAgent
  } = _temp === void 0 ? {} : _temp;
  const support2 = getSupport();
  const window2 = getWindow();
  const platform = window2.navigator.platform;
  const ua = userAgent || window2.navigator.userAgent;
  const device = {
    ios: false,
    android: false,
    androidChrome: false,
    desktop: false,
    iphone: false,
    ipod: false,
    ipad: false,
    edge: false,
    ie: false,
    firefox: false,
    macos: false,
    windows: false,
    cordova: !!window2.cordova,
    electron: false,
    capacitor: !!window2.Capacitor,
    nwjs: false
  };
  const screenWidth = window2.screen.width;
  const screenHeight = window2.screen.height;
  const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
  let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
  const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
  const iphone = !ipad && ua.match(/(iPhone\sOS|iOS|iPhone;\sCPU\sOS)\s([\d_]+)/);
  const ie = ua.indexOf("MSIE ") >= 0 || ua.indexOf("Trident/") >= 0;
  const edge = ua.indexOf("Edge/") >= 0;
  const firefox = ua.indexOf("Gecko/") >= 0 && ua.indexOf("Firefox/") >= 0;
  const windows = platform === "Win32";
  const electron = ua.toLowerCase().indexOf("electron") >= 0;
  const nwjs = typeof nw !== "undefined" && typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.nw !== "undefined";
  let macos = platform === "MacIntel";
  const iPadScreens = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
  if (!ipad && macos && support2.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
    ipad = ua.match(/(Version)\/([\d.]+)/);
    if (!ipad) ipad = [0, 1, "13_0_0"];
    macos = false;
  }
  device.ie = ie;
  device.edge = edge;
  device.firefox = firefox;
  if (android) {
    device.os = "android";
    device.osVersion = android[2];
    device.android = true;
    device.androidChrome = ua.toLowerCase().indexOf("chrome") >= 0;
  }
  if (ipad || iphone || ipod) {
    device.os = "ios";
    device.ios = true;
  }
  if (iphone && !ipod) {
    device.osVersion = iphone[2].replace(/_/g, ".");
    device.iphone = true;
  }
  if (ipad) {
    device.osVersion = ipad[2].replace(/_/g, ".");
    device.ipad = true;
  }
  if (ipod) {
    device.osVersion = ipod[3] ? ipod[3].replace(/_/g, ".") : null;
    device.ipod = true;
  }
  if (device.ios && device.osVersion && ua.indexOf("Version/") >= 0) {
    if (device.osVersion.split(".")[0] === "10") {
      device.osVersion = ua.toLowerCase().split("version/")[1].split(" ")[0];
    }
  }
  device.webView = !!((iphone || ipad || ipod) && (ua.match(/.*AppleWebKit(?!.*Safari)/i) || window2.navigator.standalone)) || window2.matchMedia && window2.matchMedia("(display-mode: standalone)").matches;
  device.webview = device.webView;
  device.standalone = device.webView;
  device.desktop = !(device.ios || device.android) || electron || nwjs;
  if (device.desktop) {
    device.electron = electron;
    device.nwjs = nwjs;
    device.macos = macos;
    device.windows = windows;
    if (device.macos) {
      device.os = "macos";
    }
    if (device.windows) {
      device.os = "windows";
    }
  }
  device.pixelRatio = window2.devicePixelRatio || 1;
  const DARK = "(prefers-color-scheme: dark)";
  const LIGHT = "(prefers-color-scheme: light)";
  device.prefersColorScheme = function prefersColorTheme() {
    let theme;
    if (window2.matchMedia && window2.matchMedia(LIGHT).matches) {
      theme = "light";
    }
    if (window2.matchMedia && window2.matchMedia(DARK).matches) {
      theme = "dark";
    }
    return theme;
  };
  return device;
}
const IS_BROWSER = (() => {
  const document2 = getDocument();
  try {
    return Boolean(document2 && document2.body && document2.body.getBoundingClientRect && document2.body.getBoundingClientRect().width > 0);
  } catch (e) {
    return false;
  }
})();
function getDevice(overrides, reset) {
  if (overrides === void 0) {
    overrides = {};
  }
  if (reset === void 0) {
    reset = IS_BROWSER;
  }
  if (!deviceCalculated || reset) {
    deviceCalculated = calcDevice(overrides);
  }
  return deviceCalculated;
}
class EventsClass {
  constructor(parents2) {
    if (parents2 === void 0) {
      parents2 = [];
    }
    const self = this;
    self.eventsParents = parents2;
    self.eventsListeners = {};
  }
  on(events, handler, priority) {
    const self = this;
    if (typeof handler !== "function") return self;
    const method = priority ? "unshift" : "push";
    events.split(" ").forEach((event) => {
      if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
      self.eventsListeners[event][method](handler);
    });
    return self;
  }
  once(events, handler, priority) {
    const self = this;
    if (typeof handler !== "function") return self;
    function onceHandler() {
      self.off(events, onceHandler);
      if (onceHandler.f7proxy) {
        delete onceHandler.f7proxy;
      }
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      handler.apply(self, args);
    }
    onceHandler.f7proxy = handler;
    return self.on(events, onceHandler, priority);
  }
  off(events, handler) {
    const self = this;
    if (!self.eventsListeners) return self;
    events.split(" ").forEach((event) => {
      if (typeof handler === "undefined") {
        self.eventsListeners[event] = [];
      } else if (self.eventsListeners[event]) {
        self.eventsListeners[event].forEach((eventHandler, index2) => {
          if (eventHandler === handler || eventHandler.f7proxy && eventHandler.f7proxy === handler) {
            self.eventsListeners[event].splice(index2, 1);
          }
        });
      }
    });
    return self;
  }
  emit() {
    const self = this;
    if (!self.eventsListeners) return self;
    let events;
    let data2;
    let context;
    let eventsParents;
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    if (typeof args[0] === "string" || Array.isArray(args[0])) {
      events = args[0];
      data2 = args.slice(1, args.length);
      context = self;
      eventsParents = self.eventsParents;
    } else {
      events = args[0].events;
      data2 = args[0].data;
      context = args[0].context || self;
      eventsParents = args[0].local ? [] : args[0].parents || self.eventsParents;
    }
    const eventsArray = Array.isArray(events) ? events : events.split(" ");
    const localEvents = eventsArray.map((eventName) => eventName.replace("local::", ""));
    const parentEvents = eventsArray.filter((eventName) => eventName.indexOf("local::") < 0);
    localEvents.forEach((event) => {
      if (self.eventsListeners && self.eventsListeners[event]) {
        const handlers = [];
        self.eventsListeners[event].forEach((eventHandler) => {
          handlers.push(eventHandler);
        });
        handlers.forEach((eventHandler) => {
          eventHandler.apply(context, data2);
        });
      }
    });
    if (eventsParents && eventsParents.length > 0) {
      eventsParents.forEach((eventsParent) => {
        eventsParent.emit(parentEvents, ...data2);
      });
    }
    return self;
  }
}
class Framework7Class extends EventsClass {
  constructor(params, parents2) {
    if (params === void 0) {
      params = {};
    }
    if (parents2 === void 0) {
      parents2 = [];
    }
    super(parents2);
    const self = this;
    self.params = params;
    if (self.params && self.params.on) {
      Object.keys(self.params.on).forEach((eventName) => {
        self.on(eventName, self.params.on[eventName]);
      });
    }
  }
  // eslint-disable-next-line
  useModuleParams(module, instanceParams) {
    if (module.params) {
      const originalParams = {};
      Object.keys(module.params).forEach((paramKey) => {
        if (typeof instanceParams[paramKey] === "undefined") return;
        originalParams[paramKey] = extend$1({}, instanceParams[paramKey]);
      });
      extend$1(instanceParams, module.params);
      Object.keys(originalParams).forEach((paramKey) => {
        extend$1(instanceParams[paramKey], originalParams[paramKey]);
      });
    }
  }
  useModulesParams(instanceParams) {
    const instance2 = this;
    if (!instance2.modules) return;
    Object.keys(instance2.modules).forEach((moduleName) => {
      const module = instance2.modules[moduleName];
      if (module.params) {
        extend$1(instanceParams, module.params);
      }
    });
  }
  useModule(moduleName, moduleParams) {
    if (moduleName === void 0) {
      moduleName = "";
    }
    if (moduleParams === void 0) {
      moduleParams = {};
    }
    const instance2 = this;
    if (!instance2.modules) return;
    const module = typeof moduleName === "string" ? instance2.modules[moduleName] : moduleName;
    if (!module) return;
    if (module.instance) {
      Object.keys(module.instance).forEach((modulePropName) => {
        const moduleProp = module.instance[modulePropName];
        if (typeof moduleProp === "function") {
          instance2[modulePropName] = moduleProp.bind(instance2);
        } else {
          instance2[modulePropName] = moduleProp;
        }
      });
    }
    if (module.on && instance2.on) {
      Object.keys(module.on).forEach((moduleEventName) => {
        instance2.on(moduleEventName, module.on[moduleEventName]);
      });
    }
    if (module.vnode) {
      if (!instance2.vnodeHooks) instance2.vnodeHooks = {};
      Object.keys(module.vnode).forEach((vnodeId) => {
        Object.keys(module.vnode[vnodeId]).forEach((hookName) => {
          const handler = module.vnode[vnodeId][hookName];
          if (!instance2.vnodeHooks[hookName]) instance2.vnodeHooks[hookName] = {};
          if (!instance2.vnodeHooks[hookName][vnodeId]) instance2.vnodeHooks[hookName][vnodeId] = [];
          instance2.vnodeHooks[hookName][vnodeId].push(handler.bind(instance2));
        });
      });
    }
    if (module.create) {
      module.create.bind(instance2)(moduleParams);
    }
  }
  useModules(modulesParams) {
    if (modulesParams === void 0) {
      modulesParams = {};
    }
    const instance2 = this;
    if (!instance2.modules) return;
    Object.keys(instance2.modules).forEach((moduleName) => {
      const moduleParams = modulesParams[moduleName] || {};
      instance2.useModule(moduleName, moduleParams);
    });
  }
  static set components(components) {
    const Class = this;
    if (!Class.use) return;
    Class.use(components);
  }
  static installModule(module) {
    const Class = this;
    if (!Class.prototype.modules) Class.prototype.modules = {};
    const name = module.name || `${Object.keys(Class.prototype.modules).length}_${now$1()}`;
    Class.prototype.modules[name] = module;
    if (module.proto) {
      Object.keys(module.proto).forEach((key) => {
        Class.prototype[key] = module.proto[key];
      });
    }
    if (module.static) {
      Object.keys(module.static).forEach((key) => {
        Class[key] = module.static[key];
      });
    }
    if (module.install) {
      for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        params[_key - 1] = arguments[_key];
      }
      module.install.apply(Class, params);
    }
    return Class;
  }
  static use(module) {
    const Class = this;
    if (Array.isArray(module)) {
      module.forEach((m) => Class.installModule(m));
      return Class;
    }
    for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      params[_key2 - 1] = arguments[_key2];
    }
    return Class.installModule(module, ...params);
  }
}
function ConstructorMethods(parameters) {
  if (parameters === void 0) {
    parameters = {};
  }
  const {
    defaultSelector,
    constructor: Constructor,
    domProp,
    app: app2,
    addMethods
  } = parameters;
  const methods2 = {
    create() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (app2) return new Constructor(app2, ...args);
      return new Constructor(...args);
    },
    get(el) {
      if (el === void 0) {
        el = defaultSelector;
      }
      if (el instanceof Constructor) return el;
      const $el = $(el);
      if ($el.length === 0) return void 0;
      return $el[0][domProp];
    },
    destroy(el) {
      const instance2 = methods2.get(el);
      if (instance2 && instance2.destroy) return instance2.destroy();
      return void 0;
    }
  };
  if (addMethods && Array.isArray(addMethods)) {
    addMethods.forEach((methodName) => {
      methods2[methodName] = function(el) {
        if (el === void 0) {
          el = defaultSelector;
        }
        const instance2 = methods2.get(el);
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        if (instance2 && instance2[methodName]) return instance2[methodName](...args);
        return void 0;
      };
    });
  }
  return methods2;
}
function ModalMethods(parameters) {
  if (parameters === void 0) {
    parameters = {};
  }
  const {
    defaultSelector,
    constructor: Constructor,
    app: app2
  } = parameters;
  const methods2 = extend$1(ConstructorMethods({
    defaultSelector,
    constructor: Constructor,
    app: app2,
    domProp: "f7Modal"
  }), {
    open(el, animate2, targetEl) {
      let $el = $(el);
      if ($el.length > 1 && targetEl) {
        const $targetPage = $(targetEl).parents(".page");
        if ($targetPage.length) {
          $el.each((modalEl) => {
            const $modalEl = $(modalEl);
            if ($modalEl.parents($targetPage)[0] === $targetPage[0]) {
              $el = $modalEl;
            }
          });
        }
      }
      if ($el.length > 1) {
        $el = $el.eq($el.length - 1);
      }
      if (!$el.length) return void 0;
      let instance2 = $el[0].f7Modal;
      if (!instance2) {
        const params = $el.dataset();
        instance2 = new Constructor(app2, {
          el: $el,
          ...params
        });
      }
      return instance2.open(animate2);
    },
    close(el, animate2, targetEl) {
      if (el === void 0) {
        el = defaultSelector;
      }
      let $el = $(el);
      if (!$el.length) return void 0;
      if ($el.length > 1) {
        let $parentEl;
        if (targetEl) {
          const $targetEl = $(targetEl);
          if ($targetEl.length) {
            $parentEl = $targetEl.parents($el);
          }
        }
        if ($parentEl && $parentEl.length > 0) {
          $el = $parentEl;
        } else {
          $el = $el.eq($el.length - 1);
        }
      }
      let instance2 = $el[0].f7Modal;
      if (!instance2) {
        const params = $el.dataset();
        instance2 = new Constructor(app2, {
          el: $el,
          ...params
        });
      }
      return instance2.close(animate2);
    }
  });
  return methods2;
}
const fetchedModules = [];
function loadModule(moduleToLoad) {
  const Framework72 = this;
  const window2 = getWindow();
  const document2 = getDocument();
  return new Promise((resolve, reject) => {
    const app2 = Framework72.instance;
    let modulePath;
    let moduleObj;
    let moduleFunc;
    if (!moduleToLoad) {
      reject(new Error("Framework7: Lazy module must be specified"));
      return;
    }
    function install(module) {
      Framework72.use(module);
      if (app2) {
        app2.useModuleParams(module, app2.params);
        app2.useModule(module);
      }
    }
    if (typeof moduleToLoad === "string") {
      const matchNamePattern = moduleToLoad.match(/([a-z0-9-]*)/i);
      if (moduleToLoad.indexOf(".") < 0 && matchNamePattern && matchNamePattern[0].length === moduleToLoad.length) {
        if (!app2 || app2 && !app2.params.lazyModulesPath) {
          reject(new Error('Framework7: "lazyModulesPath" app parameter must be specified to fetch module by name'));
          return;
        }
        modulePath = `${app2.params.lazyModulesPath}/${moduleToLoad}/${moduleToLoad}.lazy.js`;
      } else {
        modulePath = moduleToLoad;
      }
    } else if (typeof moduleToLoad === "function") {
      moduleFunc = moduleToLoad;
    } else {
      moduleObj = moduleToLoad;
    }
    if (moduleFunc) {
      const module = moduleFunc(Framework72, false);
      if (!module) {
        reject(new Error("Framework7: Can't find Framework7 component in specified component function"));
        return;
      }
      if (Framework72.prototype.modules && Framework72.prototype.modules[module.name]) {
        resolve();
        return;
      }
      install(module);
      resolve();
    }
    if (moduleObj) {
      const module = moduleObj;
      if (!module) {
        reject(new Error("Framework7: Can't find Framework7 component in specified component"));
        return;
      }
      if (Framework72.prototype.modules && Framework72.prototype.modules[module.name]) {
        resolve();
        return;
      }
      install(module);
      resolve();
    }
    if (modulePath) {
      if (fetchedModules.indexOf(modulePath) >= 0) {
        resolve();
        return;
      }
      fetchedModules.push(modulePath);
      const scriptLoad = new Promise((resolveScript, rejectScript) => {
        fetch(modulePath).then((res) => res.text()).then((scriptContent) => {
          const callbackId = id();
          const callbackLoadName = `f7_component_loader_callback_${callbackId}`;
          const scriptEl = document2.createElement("script");
          scriptEl.innerHTML = `window.${callbackLoadName} = function (Framework7, Framework7AutoInstallComponent) {return ${scriptContent.trim()}}`;
          $("head").append(scriptEl);
          const componentLoader = window2[callbackLoadName];
          delete window2[callbackLoadName];
          $(scriptEl).remove();
          const module = componentLoader(Framework72, false);
          if (!module) {
            rejectScript(new Error(`Framework7: Can't find Framework7 component in ${modulePath} file`));
            return;
          }
          if (Framework72.prototype.modules && Framework72.prototype.modules[module.name]) {
            resolveScript();
            return;
          }
          install(module);
          resolveScript();
        }).catch((err) => {
          rejectScript(err);
        });
      });
      const styleLoad = new Promise((resolveStyle) => {
        fetch(modulePath.replace(".lazy.js", app2.rtl ? ".rtl.css" : ".css").replace(".js", app2.rtl ? ".rtl.css" : ".css")).then((res) => res.text()).then((styleContent) => {
          const styleEl = document2.createElement("style");
          styleEl.innerHTML = styleContent;
          $("head").append(styleEl);
          resolveStyle();
        }).catch(() => {
          resolveStyle();
        });
      });
      Promise.all([scriptLoad, styleLoad]).then(() => {
        resolve();
      }).catch((err) => {
        reject(err);
      });
    }
  });
}
const $jsx$1 = function(tag, props) {
  const attrs = props || {};
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
  const children2 = args || [];
  const attrsString = Object.keys(attrs).map((attr2) => {
    if (attr2[0] === "_") {
      if (attrs[attr2]) return attr2.replace("_", "");
      return "";
    }
    return `${attr2}="${attrs[attr2]}"`;
  }).filter((attr2) => !!attr2).join(" ");
  if (["path", "img", "circle", "polygon", "line", "input"].indexOf(tag) >= 0) {
    return `<${tag} ${attrsString} />`.trim();
  }
  const childrenContent = children2.filter((c) => !!c).map((c) => Array.isArray(c) ? c.join("") : c).join("");
  return `<${tag} ${attrsString}>${childrenContent}</${tag}>`.trim();
};
class Framework7 extends Framework7Class {
  constructor(params) {
    if (params === void 0) {
      params = {};
    }
    super(params);
    if (Framework7.instance && typeof window !== "undefined") {
      throw new Error("Framework7 is already initialized and can't be initialized more than once");
    }
    const device = getDevice({
      userAgent: params.userAgent || void 0
    });
    const support2 = getSupport();
    const passedParams = extend$1({}, params);
    const app2 = this;
    app2.device = device;
    app2.support = support2;
    const w = getWindow();
    const d = getDocument();
    Framework7.instance = app2;
    const defaults2 = {
      el: "body",
      theme: "auto",
      routes: [],
      name: "Framework7",
      lazyModulesPath: null,
      initOnDeviceReady: true,
      init: true,
      darkMode: void 0,
      iosTranslucentBars: true,
      iosTranslucentModals: true,
      component: void 0,
      componentUrl: void 0,
      userAgent: null,
      url: null,
      colors: {
        primary: "#007aff",
        red: "#ff3b30",
        green: "#4cd964",
        blue: "#2196f3",
        pink: "#ff2d55",
        yellow: "#ffcc00",
        orange: "#ff9500",
        purple: "#9c27b0",
        deeppurple: "#673ab7",
        lightblue: "#5ac8fa",
        teal: "#009688",
        lime: "#cddc39",
        deeporange: "#ff6b22",
        white: "#ffffff",
        black: "#000000"
      }
    };
    app2.useModulesParams(defaults2);
    app2.params = extend$1(defaults2, params);
    extend$1(app2, {
      // App Name
      name: app2.params.name,
      // Routes
      routes: app2.params.routes,
      // Theme
      theme: function getTheme() {
        if (app2.params.theme === "auto") {
          if (device.ios) return "ios";
          return "md";
        }
        return app2.params.theme;
      }(),
      // Initially passed parameters
      passedParams,
      online: w.navigator.onLine,
      colors: app2.params.colors,
      darkMode: app2.params.darkMode
    });
    if (params.store) app2.params.store = params.store;
    if (app2.$el && app2.$el[0]) {
      app2.$el[0].f7 = app2;
    }
    app2.useModules();
    app2.initStore();
    if (app2.params.init) {
      if (device.cordova && app2.params.initOnDeviceReady) {
        $(d).on("deviceready", () => {
          app2.init();
        });
      } else {
        app2.init();
      }
    }
    return app2;
  }
  setColorTheme(color) {
    if (!color) return;
    const app2 = this;
    app2.colors.primary = color;
    app2.setColors();
  }
  setColors() {
    const app2 = this;
    const document2 = getDocument();
    if (!app2.colorsStyleEl) {
      app2.colorsStyleEl = document2.createElement("style");
      document2.head.prepend(app2.colorsStyleEl);
    }
    app2.colorsStyleEl.textContent = app2.utils.colorThemeCSSStyles(app2.colors);
  }
  mount(rootEl) {
    const app2 = this;
    const window2 = getWindow();
    const document2 = getDocument();
    const $rootEl = $(rootEl || app2.params.el).eq(0);
    app2.$el = $rootEl;
    if (app2.$el && app2.$el[0]) {
      app2.el = app2.$el[0];
      app2.el.f7 = app2;
      app2.rtl = $rootEl.css("direction") === "rtl";
    }
    const DARK = "(prefers-color-scheme: dark)";
    const LIGHT = "(prefers-color-scheme: light)";
    app2.mq = {};
    if (window2.matchMedia) {
      app2.mq.dark = window2.matchMedia(DARK);
      app2.mq.light = window2.matchMedia(LIGHT);
    }
    app2.colorSchemeListener = function colorSchemeListener(_ref) {
      let {
        matches,
        media
      } = _ref;
      if (!matches) {
        return;
      }
      const html2 = document2.querySelector("html");
      if (media === DARK) {
        html2.classList.add("dark");
        app2.darkMode = true;
        app2.emit("darkModeChange", true);
      } else if (media === LIGHT) {
        html2.classList.remove("dark");
        app2.darkMode = false;
        app2.emit("darkModeChange", false);
      }
    };
    app2.emit("mount");
  }
  initStore() {
    const app2 = this;
    if (typeof app2.params.store !== "undefined" && app2.params.store.__store) {
      app2.store = app2.params.store;
    } else {
      app2.store = app2.createStore(app2.params.store);
    }
  }
  enableAutoDarkMode() {
    const window2 = getWindow();
    const document2 = getDocument();
    if (!window2.matchMedia) return;
    const app2 = this;
    const html2 = document2.querySelector("html");
    if (app2.mq.dark && app2.mq.light) {
      app2.mq.dark.addEventListener("change", app2.colorSchemeListener);
      app2.mq.light.addEventListener("change", app2.colorSchemeListener);
    }
    if (app2.mq.dark && app2.mq.dark.matches) {
      html2.classList.add("dark");
      app2.darkMode = true;
      app2.emit("darkModeChange", true);
    } else if (app2.mq.light && app2.mq.light.matches) {
      html2.classList.remove("dark");
      app2.darkMode = false;
      app2.emit("darkModeChange", false);
    }
  }
  disableAutoDarkMode() {
    const window2 = getWindow();
    if (!window2.matchMedia) return;
    const app2 = this;
    if (app2.mq.dark) app2.mq.dark.removeEventListener("change", app2.colorSchemeListener);
    if (app2.mq.light) app2.mq.light.removeEventListener("change", app2.colorSchemeListener);
  }
  setDarkMode(mode) {
    const app2 = this;
    if (mode === "auto") {
      app2.enableAutoDarkMode();
    } else {
      app2.disableAutoDarkMode();
      $("html")[mode ? "addClass" : "removeClass"]("dark");
      app2.darkMode = mode;
    }
  }
  initAppComponent(callback) {
    const app2 = this;
    app2.router.componentLoader(app2.params.component, app2.params.componentUrl, {
      componentOptions: {
        el: app2.$el[0]
      }
    }, (el) => {
      app2.$el = $(el);
      app2.$el[0].f7 = app2;
      app2.$elComponent = el.f7Component;
      app2.el = app2.$el[0];
      if (callback) callback();
    }, () => {
    });
  }
  init(rootEl) {
    const app2 = this;
    app2.setColors();
    app2.mount(rootEl);
    const init2 = () => {
      if (app2.initialized) return;
      app2.$el.addClass("framework7-initializing");
      if (app2.rtl) {
        $("html").attr("dir", "rtl");
      }
      if (typeof app2.params.darkMode === "undefined") {
        app2.darkMode = $("html").hasClass("dark");
      } else {
        app2.setDarkMode(app2.params.darkMode);
      }
      const window2 = getWindow();
      window2.addEventListener("offline", () => {
        app2.online = false;
        app2.emit("offline");
        app2.emit("connection", false);
      });
      window2.addEventListener("online", () => {
        app2.online = true;
        app2.emit("online");
        app2.emit("connection", true);
      });
      app2.$el.addClass("framework7-root");
      $("html").removeClass("ios md").addClass(app2.theme);
      if (app2.params.iosTranslucentBars && app2.theme === "ios") {
        $("html").addClass("ios-translucent-bars");
      }
      if (app2.params.iosTranslucentModals && app2.theme === "ios") {
        $("html").addClass("ios-translucent-modals");
      }
      nextFrame$1(() => {
        app2.$el.removeClass("framework7-initializing");
      });
      app2.initialized = true;
      app2.emit("init");
    };
    if (app2.params.component || app2.params.componentUrl) {
      app2.initAppComponent(() => {
        init2();
      });
    } else {
      init2();
    }
    return app2;
  }
  // eslint-disable-next-line
  loadModule() {
    return Framework7.loadModule(...arguments);
  }
  // eslint-disable-next-line
  loadModules() {
    return Framework7.loadModules(...arguments);
  }
  getVnodeHooks(hook, id2) {
    const app2 = this;
    if (!app2.vnodeHooks || !app2.vnodeHooks[hook]) return [];
    return app2.vnodeHooks[hook][id2] || [];
  }
  // eslint-disable-next-line
  get $() {
    return $;
  }
  static get Dom7() {
    return $;
  }
  static get $() {
    return $;
  }
  static get device() {
    return getDevice();
  }
  static get support() {
    return getSupport();
  }
  static get Class() {
    return Framework7Class;
  }
  static get Events() {
    return EventsClass;
  }
}
Framework7.$jsx = $jsx$1;
Framework7.ModalMethods = ModalMethods;
Framework7.ConstructorMethods = ConstructorMethods;
Framework7.loadModule = loadModule;
Framework7.loadModules = function loadModules(modules) {
  return Promise.all(modules.map((module) => Framework7.loadModule(module)));
};
const DeviceModule = {
  name: "device",
  static: {
    getDevice
  },
  on: {
    init() {
      const document2 = getDocument();
      const device = getDevice();
      const classNames2 = [];
      const html2 = document2.querySelector("html");
      const metaStatusbar = document2.querySelector('meta[name="apple-mobile-web-app-status-bar-style"]');
      if (!html2) return;
      if (device.standalone && device.ios && metaStatusbar && metaStatusbar.content === "black-translucent") {
        classNames2.push("device-full-viewport");
      }
      classNames2.push(`device-pixel-ratio-${Math.floor(device.pixelRatio)}`);
      if (device.os && !device.desktop) {
        classNames2.push(`device-${device.os}`);
      } else if (device.desktop) {
        classNames2.push("device-desktop");
        if (device.os) {
          classNames2.push(`device-${device.os}`);
        }
      }
      if (device.cordova) {
        classNames2.push("device-cordova");
      }
      if (device.capacitor) {
        classNames2.push("device-capacitor");
      }
      classNames2.forEach((className) => {
        html2.classList.add(className);
      });
    }
  }
};
const SupportModule = {
  name: "support",
  static: {
    getSupport
  }
};
const UtilsModule = {
  name: "utils",
  proto: {
    utils
  },
  static: {
    utils
  }
};
const ResizeModule = {
  name: "resize",
  create() {
    const app2 = this;
    app2.getSize = () => {
      if (!app2.el) return {
        width: 0,
        height: 0,
        left: 0,
        top: 0
      };
      const offset2 = app2.$el.offset();
      const [width2, height2, left, top] = [app2.el.offsetWidth, app2.el.offsetHeight, offset2.left, offset2.top];
      app2.width = width2;
      app2.height = height2;
      app2.left = left;
      app2.top = top;
      return {
        width: width2,
        height: height2,
        left,
        top
      };
    };
  },
  on: {
    init() {
      const app2 = this;
      const window2 = getWindow();
      app2.getSize();
      window2.addEventListener("resize", () => {
        app2.emit("resize");
      }, false);
      window2.addEventListener("orientationchange", () => {
        app2.emit("orientationchange");
      });
    },
    orientationchange() {
      const document2 = getDocument();
      const device = getDevice();
      if (device.ipad) {
        document2.body.scrollLeft = 0;
        setTimeout(() => {
          document2.body.scrollLeft = 0;
        }, 0);
      }
    },
    resize() {
      const app2 = this;
      app2.getSize();
    }
  }
};
function initTouch() {
  const app2 = this;
  const device = getDevice();
  const support2 = getSupport();
  const window2 = getWindow();
  const document2 = getDocument();
  const params = app2.params.touch;
  const useRipple = params[`${app2.theme}TouchRipple`];
  if (device.ios && device.webView) {
    window2.addEventListener("touchstart", () => {
    });
  }
  let touchStartX;
  let touchStartY;
  let targetElement;
  let isMoved;
  let tapHoldFired;
  let tapHoldTimeout;
  let preventClick;
  let activableElement;
  let activeTimeout;
  let rippleWave;
  let rippleTarget;
  let rippleTimeout;
  function findActivableElement(el) {
    const target = $(el);
    const parents2 = target.parents(params.activeStateElements);
    if (target.closest(".no-active-state").length) {
      return null;
    }
    let activable;
    if (target.is(params.activeStateElements)) {
      activable = target;
    }
    if (parents2.length > 0) {
      activable = activable ? activable.add(parents2) : parents2;
    }
    if (activable && activable.length > 1) {
      const newActivable = [];
      let preventPropagation;
      for (let i = 0; i < activable.length; i += 1) {
        if (!preventPropagation) {
          newActivable.push(activable[i]);
          if (activable.eq(i).hasClass("prevent-active-state-propagation") || activable.eq(i).hasClass("no-active-state-propagation")) {
            preventPropagation = true;
          }
        }
      }
      activable = $(newActivable);
    }
    return activable || target;
  }
  function isInsideScrollableView(el) {
    const pageContent = el.parents(".page-content");
    return pageContent.length > 0;
  }
  function addActive() {
    if (!activableElement) return;
    activableElement.addClass("active-state");
  }
  function removeActive() {
    if (!activableElement) return;
    activableElement.removeClass("active-state");
    activableElement = null;
  }
  function findRippleElement(el) {
    const rippleElements = params.touchRippleElements;
    const $el = $(el);
    if ($el.is(rippleElements)) {
      if ($el.hasClass("no-ripple")) {
        return false;
      }
      return $el;
    }
    if ($el.parents(rippleElements).length > 0) {
      const rippleParent = $el.parents(rippleElements).eq(0);
      if (rippleParent.hasClass("no-ripple")) {
        return false;
      }
      return rippleParent;
    }
    return false;
  }
  function createRipple($el, x, y) {
    if (!$el) return;
    rippleWave = app2.touchRipple.create(app2, $el, x, y);
  }
  function removeRipple() {
    if (!rippleWave) return;
    rippleWave.remove();
    rippleWave = void 0;
    rippleTarget = void 0;
  }
  function rippleTouchStart(el) {
    rippleTarget = findRippleElement(el);
    if (!rippleTarget || rippleTarget.length === 0) {
      rippleTarget = void 0;
      return;
    }
    const inScrollable = isInsideScrollableView(rippleTarget);
    if (!inScrollable) {
      removeRipple();
      createRipple(rippleTarget, touchStartX, touchStartY);
    } else {
      clearTimeout(rippleTimeout);
      rippleTimeout = setTimeout(() => {
        removeRipple();
        createRipple(rippleTarget, touchStartX, touchStartY);
      }, 80);
    }
  }
  function rippleTouchMove() {
    clearTimeout(rippleTimeout);
    removeRipple();
  }
  function rippleTouchEnd() {
    if (!rippleWave && rippleTarget && !isMoved) {
      clearTimeout(rippleTimeout);
      createRipple(rippleTarget, touchStartX, touchStartY);
      setTimeout(removeRipple, 0);
    } else {
      removeRipple();
    }
  }
  function handleMouseDown(e) {
    const $activableEl = findActivableElement(e.target);
    if ($activableEl) {
      $activableEl.addClass("active-state");
      if ("which" in e && e.which === 3) {
        setTimeout(() => {
          $(".active-state").removeClass("active-state");
        }, 0);
      }
    }
    if (useRipple) {
      touchStartX = e.pageX;
      touchStartY = e.pageY;
      rippleTouchStart(e.target, e.pageX, e.pageY);
    }
  }
  function handleMouseMove() {
    if (!params.activeStateOnMouseMove) {
      $(".active-state").removeClass("active-state");
    }
    if (useRipple) {
      rippleTouchMove();
    }
  }
  function handleMouseUp() {
    $(".active-state").removeClass("active-state");
    if (useRipple) {
      rippleTouchEnd();
    }
  }
  function handleTouchCancel() {
    targetElement = null;
    clearTimeout(activeTimeout);
    clearTimeout(tapHoldTimeout);
    if (params.activeState) {
      removeActive();
    }
    if (useRipple) {
      rippleTouchEnd();
    }
  }
  let isScrolling;
  let isSegmentedStrong = false;
  let segmentedStrongEl = null;
  const touchMoveActivableIos = ".dialog-button, .actions-button";
  let isTouchMoveActivable = false;
  let touchmoveActivableEl = null;
  function handleTouchStart(e) {
    if (!e.isTrusted) return true;
    isMoved = false;
    tapHoldFired = false;
    preventClick = false;
    isScrolling = void 0;
    if (e.targetTouches.length > 1) {
      if (activableElement) removeActive();
      return true;
    }
    if (e.touches.length > 1 && activableElement) {
      removeActive();
    }
    if (params.tapHold) {
      if (tapHoldTimeout) clearTimeout(tapHoldTimeout);
      tapHoldTimeout = setTimeout(() => {
        if (e && e.touches && e.touches.length > 1) return;
        tapHoldFired = true;
        e.preventDefault();
        preventClick = true;
        $(e.target).trigger("taphold", e);
        app2.emit("taphold", e);
      }, params.tapHoldDelay);
    }
    targetElement = e.target;
    touchStartX = e.targetTouches[0].pageX;
    touchStartY = e.targetTouches[0].pageY;
    isSegmentedStrong = e.target.closest(".segmented-strong .button-active, .segmented-strong .tab-link-active");
    isTouchMoveActivable = app2.theme === "ios" && e.target.closest(touchMoveActivableIos);
    if (isSegmentedStrong) {
      segmentedStrongEl = isSegmentedStrong.closest(".segmented-strong");
    }
    if (params.activeState) {
      activableElement = findActivableElement(targetElement);
      if (activableElement && !isInsideScrollableView(activableElement)) {
        addActive();
      } else if (activableElement) {
        activeTimeout = setTimeout(addActive, 80);
      }
    }
    if (useRipple) {
      rippleTouchStart(targetElement);
    }
    return true;
  }
  function handleTouchMove(e) {
    if (!e.isTrusted) return;
    let touch;
    let distance;
    let shouldRemoveActive = true;
    if (e.type === "touchmove") {
      touch = e.targetTouches[0];
      distance = params.touchClicksDistanceThreshold;
    }
    const touchCurrentX = e.targetTouches[0].pageX;
    const touchCurrentY = e.targetTouches[0].pageY;
    if (typeof isScrolling === "undefined") {
      isScrolling = !!(isScrolling || Math.abs(touchCurrentY - touchStartY) > Math.abs(touchCurrentX - touchStartX));
    }
    if (isTouchMoveActivable || !isScrolling && isSegmentedStrong && segmentedStrongEl) {
      if (e.cancelable) e.preventDefault();
    }
    if (!isScrolling && isSegmentedStrong && segmentedStrongEl) {
      const elementFromPoint = document2.elementFromPoint(e.targetTouches[0].clientX, e.targetTouches[0].clientY);
      const buttonEl = elementFromPoint.closest(".segmented-strong .button:not(.button-active):not(.tab-link-active)");
      if (buttonEl && segmentedStrongEl.contains(buttonEl)) {
        $(buttonEl).trigger("click", "f7Segmented");
        targetElement = buttonEl;
      }
    }
    if (distance && touch) {
      const pageX = touch.pageX;
      const pageY = touch.pageY;
      if (Math.abs(pageX - touchStartX) > distance || Math.abs(pageY - touchStartY) > distance) {
        isMoved = true;
      }
    } else {
      isMoved = true;
    }
    if (isMoved) {
      preventClick = true;
      if (isTouchMoveActivable) {
        const elementFromPoint = document2.elementFromPoint(e.targetTouches[0].clientX, e.targetTouches[0].clientY);
        touchmoveActivableEl = elementFromPoint.closest(touchMoveActivableIos);
        if (touchmoveActivableEl && activableElement && activableElement[0] === touchmoveActivableEl) {
          shouldRemoveActive = false;
        } else if (touchmoveActivableEl) {
          setTimeout(() => {
            activableElement = findActivableElement(touchmoveActivableEl);
            addActive();
          });
        }
      }
      if (params.tapHold) {
        clearTimeout(tapHoldTimeout);
      }
      if (params.activeState && shouldRemoveActive) {
        clearTimeout(activeTimeout);
        removeActive();
      }
      if (useRipple) {
        rippleTouchMove();
      }
    }
  }
  function handleTouchEnd(e) {
    if (!e.isTrusted) return true;
    isScrolling = void 0;
    isSegmentedStrong = false;
    segmentedStrongEl = null;
    isTouchMoveActivable = false;
    clearTimeout(activeTimeout);
    clearTimeout(tapHoldTimeout);
    if (touchmoveActivableEl) {
      $(touchmoveActivableEl).trigger("click", "f7TouchMoveActivable");
      touchmoveActivableEl = null;
    }
    if (document2.activeElement === e.target) {
      if (params.activeState) removeActive();
      if (useRipple) {
        rippleTouchEnd();
      }
      return true;
    }
    if (params.activeState) {
      addActive();
      setTimeout(removeActive, 0);
    }
    if (useRipple) {
      rippleTouchEnd();
    }
    if (params.tapHoldPreventClicks && tapHoldFired || preventClick) {
      if (e.cancelable) e.preventDefault();
      preventClick = true;
      return false;
    }
    return true;
  }
  function handleClick(e) {
    const isOverswipe = e && e.detail && e.detail === "f7Overswipe";
    const isSegmented = e && e.detail && e.detail === "f7Segmented";
    const isTouchMoveActivable2 = e && e.detail && e.detail === "f7TouchMoveActivable";
    let localPreventClick = preventClick;
    if (targetElement && e.target !== targetElement) {
      if (isOverswipe || isSegmented || isTouchMoveActivable2) {
        localPreventClick = false;
      } else {
        localPreventClick = true;
      }
    } else if (isTouchMoveActivable2) {
      localPreventClick = false;
    }
    if (params.tapHold && params.tapHoldPreventClicks && tapHoldFired) {
      localPreventClick = true;
    }
    if (localPreventClick) {
      e.stopImmediatePropagation();
      e.stopPropagation();
      e.preventDefault();
    }
    if (params.tapHold) {
      tapHoldTimeout = setTimeout(() => {
        tapHoldFired = false;
      }, device.ios || device.androidChrome ? 100 : 400);
    }
    preventClick = false;
    targetElement = null;
    return !localPreventClick;
  }
  function emitAppTouchEvent(name, e) {
    app2.emit({
      events: name,
      data: [e]
    });
  }
  function appClick(e) {
    emitAppTouchEvent("click", e);
  }
  function appTouchStartActive(e) {
    emitAppTouchEvent("touchstart touchstart:active", e);
  }
  function appTouchMoveActive(e) {
    emitAppTouchEvent("touchmove touchmove:active", e);
  }
  function appTouchEndActive(e) {
    emitAppTouchEvent("touchend touchend:active", e);
  }
  function appTouchStartPassive(e) {
    emitAppTouchEvent("touchstart:passive", e);
  }
  function appTouchMovePassive(e) {
    emitAppTouchEvent("touchmove:passive", e);
  }
  function appTouchEndPassive(e) {
    emitAppTouchEvent("touchend:passive", e);
  }
  const passiveListener = support2.passiveListener ? {
    passive: true
  } : false;
  const passiveListenerCapture = support2.passiveListener ? {
    passive: true,
    capture: true
  } : true;
  const activeListener = support2.passiveListener ? {
    passive: false
  } : false;
  const activeListenerCapture = support2.passiveListener ? {
    passive: false,
    capture: true
  } : true;
  document2.addEventListener("click", appClick, true);
  if (support2.passiveListener) {
    document2.addEventListener(app2.touchEvents.start, appTouchStartActive, activeListenerCapture);
    document2.addEventListener(app2.touchEvents.move, appTouchMoveActive, activeListener);
    document2.addEventListener(app2.touchEvents.end, appTouchEndActive, activeListener);
    document2.addEventListener(app2.touchEvents.start, appTouchStartPassive, passiveListenerCapture);
    document2.addEventListener(app2.touchEvents.move, appTouchMovePassive, passiveListener);
    document2.addEventListener(app2.touchEvents.end, appTouchEndPassive, passiveListener);
  } else {
    document2.addEventListener(app2.touchEvents.start, (e) => {
      appTouchStartActive(e);
      appTouchStartPassive(e);
    }, true);
    document2.addEventListener(app2.touchEvents.move, (e) => {
      appTouchMoveActive(e);
      appTouchMovePassive(e);
    }, false);
    document2.addEventListener(app2.touchEvents.end, (e) => {
      appTouchEndActive(e);
      appTouchEndPassive(e);
    }, false);
  }
  if (support2.touch) {
    app2.on("click", handleClick);
    app2.on("touchstart", handleTouchStart);
    app2.on("touchmove", handleTouchMove);
    app2.on("touchend", handleTouchEnd);
    document2.addEventListener("touchcancel", handleTouchCancel, {
      passive: true
    });
  } else if (params.activeState) {
    app2.on("touchstart", handleMouseDown);
    app2.on("touchmove", handleMouseMove);
    app2.on("touchend", handleMouseUp);
    document2.addEventListener("pointercancel", handleMouseUp, {
      passive: true
    });
  }
  document2.addEventListener("contextmenu", (e) => {
    if (params.disableContextMenu && (device.ios || device.android || device.cordova || window2.Capacitor && window2.Capacitor.isNative)) {
      e.preventDefault();
    }
    if (useRipple) {
      if (activableElement) removeActive();
      rippleTouchEnd();
    }
  });
}
const TouchModule = {
  name: "touch",
  params: {
    touch: {
      // Clicks
      touchClicksDistanceThreshold: 5,
      // ContextMenu
      disableContextMenu: false,
      // Tap Hold
      tapHold: false,
      tapHoldDelay: 750,
      tapHoldPreventClicks: true,
      // Active State
      activeState: true,
      activeStateElements: "a, button, label, span, .actions-button, .stepper-button, .stepper-button-plus, .stepper-button-minus, .card-expandable, .link, .item-link, .accordion-item-toggle",
      activeStateOnMouseMove: false,
      mdTouchRipple: true,
      iosTouchRipple: false,
      touchRippleElements: ".ripple, .link, .item-link, .list label.item-content, .list-button, .links-list a, .button, button, .input-clear-button, .dialog-button, .tab-link, .item-radio, .item-checkbox, .actions-button, .searchbar-disable-button, .fab a, .checkbox, .radio, .data-table .sortable-cell:not(.input-cell), .notification-close-button, .stepper-button, .stepper-button-minus, .stepper-button-plus, .list.accordion-list .accordion-item-toggle",
      touchRippleInsetElements: ".ripple-inset, .icon-only, .searchbar-disable-button, .input-clear-button, .notification-close-button, .md .navbar .link.back"
    }
  },
  create() {
    const app2 = this;
    const support2 = getSupport();
    extend$1(app2, {
      touchEvents: {
        start: support2.touch ? "touchstart" : support2.pointerEvents ? "pointerdown" : "mousedown",
        move: support2.touch ? "touchmove" : support2.pointerEvents ? "pointermove" : "mousemove",
        end: support2.touch ? "touchend" : support2.pointerEvents ? "pointerup" : "mouseup"
      }
    });
  },
  on: {
    init: initTouch
  }
};
function lexer(str) {
  var tokens = [];
  var i = 0;
  while (i < str.length) {
    var char = str[i];
    if (char === "*" || char === "+" || char === "?") {
      tokens.push({ type: "MODIFIER", index: i, value: str[i++] });
      continue;
    }
    if (char === "\\") {
      tokens.push({ type: "ESCAPED_CHAR", index: i++, value: str[i++] });
      continue;
    }
    if (char === "{") {
      tokens.push({ type: "OPEN", index: i, value: str[i++] });
      continue;
    }
    if (char === "}") {
      tokens.push({ type: "CLOSE", index: i, value: str[i++] });
      continue;
    }
    if (char === ":") {
      var name = "";
      var j = i + 1;
      while (j < str.length) {
        var code = str.charCodeAt(j);
        if (
          // `0-9`
          code >= 48 && code <= 57 || // `A-Z`
          code >= 65 && code <= 90 || // `a-z`
          code >= 97 && code <= 122 || // `_`
          code === 95
        ) {
          name += str[j++];
          continue;
        }
        break;
      }
      if (!name)
        throw new TypeError("Missing parameter name at ".concat(i));
      tokens.push({ type: "NAME", index: i, value: name });
      i = j;
      continue;
    }
    if (char === "(") {
      var count = 1;
      var pattern = "";
      var j = i + 1;
      if (str[j] === "?") {
        throw new TypeError('Pattern cannot start with "?" at '.concat(j));
      }
      while (j < str.length) {
        if (str[j] === "\\") {
          pattern += str[j++] + str[j++];
          continue;
        }
        if (str[j] === ")") {
          count--;
          if (count === 0) {
            j++;
            break;
          }
        } else if (str[j] === "(") {
          count++;
          if (str[j + 1] !== "?") {
            throw new TypeError("Capturing groups are not allowed at ".concat(j));
          }
        }
        pattern += str[j++];
      }
      if (count)
        throw new TypeError("Unbalanced pattern at ".concat(i));
      if (!pattern)
        throw new TypeError("Missing pattern at ".concat(i));
      tokens.push({ type: "PATTERN", index: i, value: pattern });
      i = j;
      continue;
    }
    tokens.push({ type: "CHAR", index: i, value: str[i++] });
  }
  tokens.push({ type: "END", index: i, value: "" });
  return tokens;
}
function parse(str, options) {
  if (options === void 0) {
    options = {};
  }
  var tokens = lexer(str);
  var _a = options.prefixes, prefixes = _a === void 0 ? "./" : _a, _b = options.delimiter, delimiter = _b === void 0 ? "/#?" : _b;
  var result = [];
  var key = 0;
  var i = 0;
  var path2 = "";
  var tryConsume = function(type) {
    if (i < tokens.length && tokens[i].type === type)
      return tokens[i++].value;
  };
  var mustConsume = function(type) {
    var value3 = tryConsume(type);
    if (value3 !== void 0)
      return value3;
    var _a2 = tokens[i], nextType = _a2.type, index2 = _a2.index;
    throw new TypeError("Unexpected ".concat(nextType, " at ").concat(index2, ", expected ").concat(type));
  };
  var consumeText = function() {
    var result2 = "";
    var value3;
    while (value3 = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR")) {
      result2 += value3;
    }
    return result2;
  };
  var isSafe = function(value3) {
    for (var _i = 0, delimiter_1 = delimiter; _i < delimiter_1.length; _i++) {
      var char2 = delimiter_1[_i];
      if (value3.indexOf(char2) > -1)
        return true;
    }
    return false;
  };
  var safePattern = function(prefix2) {
    var prev2 = result[result.length - 1];
    var prevText = prefix2 || (prev2 && typeof prev2 === "string" ? prev2 : "");
    if (prev2 && !prevText) {
      throw new TypeError('Must have text between two parameters, missing text after "'.concat(prev2.name, '"'));
    }
    if (!prevText || isSafe(prevText))
      return "[^".concat(escapeString(delimiter), "]+?");
    return "(?:(?!".concat(escapeString(prevText), ")[^").concat(escapeString(delimiter), "])+?");
  };
  while (i < tokens.length) {
    var char = tryConsume("CHAR");
    var name = tryConsume("NAME");
    var pattern = tryConsume("PATTERN");
    if (name || pattern) {
      var prefix = char || "";
      if (prefixes.indexOf(prefix) === -1) {
        path2 += prefix;
        prefix = "";
      }
      if (path2) {
        result.push(path2);
        path2 = "";
      }
      result.push({
        name: name || key++,
        prefix,
        suffix: "",
        pattern: pattern || safePattern(prefix),
        modifier: tryConsume("MODIFIER") || ""
      });
      continue;
    }
    var value2 = char || tryConsume("ESCAPED_CHAR");
    if (value2) {
      path2 += value2;
      continue;
    }
    if (path2) {
      result.push(path2);
      path2 = "";
    }
    var open3 = tryConsume("OPEN");
    if (open3) {
      var prefix = consumeText();
      var name_1 = tryConsume("NAME") || "";
      var pattern_1 = tryConsume("PATTERN") || "";
      var suffix = consumeText();
      mustConsume("CLOSE");
      result.push({
        name: name_1 || (pattern_1 ? key++ : ""),
        pattern: name_1 && !pattern_1 ? safePattern(prefix) : pattern_1,
        prefix,
        suffix,
        modifier: tryConsume("MODIFIER") || ""
      });
      continue;
    }
    mustConsume("END");
  }
  return result;
}
function compile(str, options) {
  return tokensToFunction(parse(str, options), options);
}
function tokensToFunction(tokens, options) {
  if (options === void 0) {
    options = {};
  }
  var reFlags = flags(options);
  var _a = options.encode, encode = _a === void 0 ? function(x) {
    return x;
  } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;
  var matches = tokens.map(function(token) {
    if (typeof token === "object") {
      return new RegExp("^(?:".concat(token.pattern, ")$"), reFlags);
    }
  });
  return function(data2) {
    var path2 = "";
    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];
      if (typeof token === "string") {
        path2 += token;
        continue;
      }
      var value2 = data2 ? data2[token.name] : void 0;
      var optional = token.modifier === "?" || token.modifier === "*";
      var repeat = token.modifier === "*" || token.modifier === "+";
      if (Array.isArray(value2)) {
        if (!repeat) {
          throw new TypeError('Expected "'.concat(token.name, '" to not repeat, but got an array'));
        }
        if (value2.length === 0) {
          if (optional)
            continue;
          throw new TypeError('Expected "'.concat(token.name, '" to not be empty'));
        }
        for (var j = 0; j < value2.length; j++) {
          var segment = encode(value2[j], token);
          if (validate && !matches[i].test(segment)) {
            throw new TypeError('Expected all "'.concat(token.name, '" to match "').concat(token.pattern, '", but got "').concat(segment, '"'));
          }
          path2 += token.prefix + segment + token.suffix;
        }
        continue;
      }
      if (typeof value2 === "string" || typeof value2 === "number") {
        var segment = encode(String(value2), token);
        if (validate && !matches[i].test(segment)) {
          throw new TypeError('Expected "'.concat(token.name, '" to match "').concat(token.pattern, '", but got "').concat(segment, '"'));
        }
        path2 += token.prefix + segment + token.suffix;
        continue;
      }
      if (optional)
        continue;
      var typeOfMessage = repeat ? "an array" : "a string";
      throw new TypeError('Expected "'.concat(token.name, '" to be ').concat(typeOfMessage));
    }
    return path2;
  };
}
function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
}
function flags(options) {
  return options && options.sensitive ? "" : "i";
}
function regexpToRegexp(path2, keys) {
  if (!keys)
    return path2;
  var groupsRegex = /\((?:\?<(.*?)>)?(?!\?)/g;
  var index2 = 0;
  var execResult = groupsRegex.exec(path2.source);
  while (execResult) {
    keys.push({
      // Use parenthesized substring match if available, index otherwise
      name: execResult[1] || index2++,
      prefix: "",
      suffix: "",
      modifier: "",
      pattern: ""
    });
    execResult = groupsRegex.exec(path2.source);
  }
  return path2;
}
function arrayToRegexp(paths, keys, options) {
  var parts = paths.map(function(path2) {
    return pathToRegexp(path2, keys, options).source;
  });
  return new RegExp("(?:".concat(parts.join("|"), ")"), flags(options));
}
function stringToRegexp(path2, keys, options) {
  return tokensToRegexp(parse(path2, options), keys, options);
}
function tokensToRegexp(tokens, keys, options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function(x) {
    return x;
  } : _d, _e = options.delimiter, delimiter = _e === void 0 ? "/#?" : _e, _f = options.endsWith, endsWith = _f === void 0 ? "" : _f;
  var endsWithRe = "[".concat(escapeString(endsWith), "]|$");
  var delimiterRe = "[".concat(escapeString(delimiter), "]");
  var route = start ? "^" : "";
  for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
    var token = tokens_1[_i];
    if (typeof token === "string") {
      route += escapeString(encode(token));
    } else {
      var prefix = escapeString(encode(token.prefix));
      var suffix = escapeString(encode(token.suffix));
      if (token.pattern) {
        if (keys)
          keys.push(token);
        if (prefix || suffix) {
          if (token.modifier === "+" || token.modifier === "*") {
            var mod = token.modifier === "*" ? "?" : "";
            route += "(?:".concat(prefix, "((?:").concat(token.pattern, ")(?:").concat(suffix).concat(prefix, "(?:").concat(token.pattern, "))*)").concat(suffix, ")").concat(mod);
          } else {
            route += "(?:".concat(prefix, "(").concat(token.pattern, ")").concat(suffix, ")").concat(token.modifier);
          }
        } else {
          if (token.modifier === "+" || token.modifier === "*") {
            throw new TypeError('Can not repeat "'.concat(token.name, '" without a prefix and suffix'));
          }
          route += "(".concat(token.pattern, ")").concat(token.modifier);
        }
      } else {
        route += "(?:".concat(prefix).concat(suffix, ")").concat(token.modifier);
      }
    }
  }
  if (end) {
    if (!strict)
      route += "".concat(delimiterRe, "?");
    route += !options.endsWith ? "$" : "(?=".concat(endsWithRe, ")");
  } else {
    var endToken = tokens[tokens.length - 1];
    var isEndDelimited = typeof endToken === "string" ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1 : endToken === void 0;
    if (!strict) {
      route += "(?:".concat(delimiterRe, "(?=").concat(endsWithRe, "))?");
    }
    if (!isEndDelimited) {
      route += "(?=".concat(delimiterRe, "|").concat(endsWithRe, ")");
    }
  }
  return new RegExp(route, flags(options));
}
function pathToRegexp(path2, keys, options) {
  if (path2 instanceof RegExp)
    return regexpToRegexp(path2, keys);
  if (Array.isArray(path2))
    return arrayToRegexp(path2, keys, options);
  return stringToRegexp(path2, keys, options);
}
const History = {
  queue: [],
  clearQueue() {
    if (History.queue.length === 0) return;
    const currentQueue = History.queue.shift();
    currentQueue();
  },
  routerQueue: [],
  clearRouterQueue() {
    if (History.routerQueue.length === 0) return;
    const currentQueue = History.routerQueue.pop();
    const {
      router,
      stateUrl,
      action
    } = currentQueue;
    let animate2 = router.params.animate;
    if (router.params.browserHistoryAnimate === false) animate2 = false;
    if (action === "back") {
      router.back({
        animate: animate2,
        browserHistory: false
      });
    }
    if (action === "load") {
      router.navigate(stateUrl, {
        animate: animate2,
        browserHistory: false
      });
    }
  },
  handle(e) {
    if (History.blockPopstate) return;
    const app2 = this;
    let state = e.state;
    History.previousState = History.state;
    History.state = state;
    History.allowChange = true;
    History.clearQueue();
    state = History.state;
    if (!state) state = {};
    app2.views.forEach((view) => {
      const router = view.router;
      let viewState = state[view.id];
      if (!viewState && view.params.browserHistory) {
        viewState = {
          url: view.router.history[0]
        };
      }
      if (!viewState) return;
      const stateUrl = viewState.url || void 0;
      let animate2 = router.params.animate;
      if (router.params.browserHistoryAnimate === false) animate2 = false;
      if (stateUrl !== router.url) {
        if (router.history.indexOf(stateUrl) >= 0) {
          if (router.allowPageChange) {
            router.back({
              animate: animate2,
              browserHistory: false
            });
          } else {
            History.routerQueue.push({
              action: "back",
              router
            });
          }
        } else if (router.allowPageChange) {
          router.navigate(stateUrl, {
            animate: animate2,
            browserHistory: false
          });
        } else {
          History.routerQueue.unshift({
            action: "load",
            stateUrl,
            router
          });
        }
      }
    });
  },
  initViewState(viewId, viewState) {
    const window2 = getWindow();
    const newState = extend$1({}, History.state || {}, {
      [viewId]: viewState
    });
    History.state = newState;
    window2.history.replaceState(newState, "");
  },
  push(viewId, viewState, url) {
    const window2 = getWindow();
    const document2 = getDocument();
    if (url.substr(-3) === "#!/") {
      url = url.replace("#!/", "");
      if (url === "") {
        url = document2.location.href;
        if (url.includes("#!/")) {
          url = document2.location.href.split("#!/")[0];
        }
      }
    }
    if (!History.allowChange) {
      History.queue.push(() => {
        History.push(viewId, viewState, url);
      });
      return;
    }
    History.previousState = History.state;
    const newState = extend$1({}, History.previousState || {}, {
      [viewId]: viewState
    });
    History.state = newState;
    window2.history.pushState(newState, "", url);
  },
  replace(viewId, viewState, url) {
    const window2 = getWindow();
    if (url.substr(-3) === "#!/") {
      url = url.replace("#!/", "");
    }
    if (!History.allowChange) {
      History.queue.push(() => {
        History.replace(viewId, viewState, url);
      });
      return;
    }
    History.previousState = History.state;
    const newState = extend$1({}, History.previousState || {}, {
      [viewId]: viewState
    });
    History.state = newState;
    window2.history.replaceState(newState, "", url);
  },
  go(index2) {
    const window2 = getWindow();
    History.allowChange = false;
    window2.history.go(index2);
  },
  back() {
    const window2 = getWindow();
    History.allowChange = false;
    window2.history.back();
  },
  allowChange: true,
  previousState: {},
  state: {},
  blockPopstate: true,
  init(app2) {
    const window2 = getWindow();
    const document2 = getDocument();
    History.state = window2.history.state;
    $(window2).on("load", () => {
      setTimeout(() => {
        History.blockPopstate = false;
      }, 0);
    });
    if (document2.readyState && document2.readyState === "complete") {
      History.blockPopstate = false;
    }
    $(window2).on("popstate", History.handle.bind(app2));
  }
};
function SwipeBack(r) {
  const router = r;
  const {
    $el,
    $navbarsEl,
    app: app2,
    params
  } = router;
  const support2 = getSupport();
  const device = getDevice();
  let isTouched = false;
  let isMoved = false;
  const touchesStart = {};
  let isScrolling;
  let $currentPageEl = [];
  let $previousPageEl = [];
  let viewContainerWidth;
  let touchesDiff;
  let allowViewTouchMove = true;
  let touchStartTime;
  let $currentNavbarEl = [];
  let $previousNavbarEl = [];
  let dynamicNavbar;
  let $pageShadowEl;
  let $pageOpacityEl;
  let animatableNavEls;
  const paramsSwipeBackAnimateShadow = params[`${app2.theme}SwipeBackAnimateShadow`];
  const paramsSwipeBackAnimateOpacity = params[`${app2.theme}SwipeBackAnimateOpacity`];
  const paramsSwipeBackActiveArea = params[`${app2.theme}SwipeBackActiveArea`];
  const paramsSwipeBackThreshold = params[`${app2.theme}SwipeBackThreshold`];
  const transformOrigin = app2.rtl ? "right center" : "left center";
  const transformOriginTitleLarge = app2.rtl ? "calc(100% - var(--f7-navbar-large-title-padding-left) - var(--f7-safe-area-left)) center" : "calc(var(--f7-navbar-large-title-padding-left) + var(--f7-safe-area-left)) center";
  function animatableNavElements() {
    const els = [];
    const inverter = app2.rtl ? -1 : 1;
    const currentNavIsTransparent = $currentNavbarEl.hasClass("navbar-transparent") && !$currentNavbarEl.hasClass("navbar-large") && !$currentNavbarEl.hasClass("navbar-transparent-visible");
    const currentNavIsLarge = $currentNavbarEl.hasClass("navbar-large");
    const currentNavIsCollapsed = $currentNavbarEl.hasClass("navbar-large-collapsed");
    const currentNavIsLargeTransparent = $currentNavbarEl.hasClass("navbar-large-transparent") || $currentNavbarEl.hasClass("navbar-large") && $currentNavbarEl.hasClass("navbar-transparent");
    const previousNavIsTransparent = $previousNavbarEl.hasClass("navbar-transparent") && !$previousNavbarEl.hasClass("navbar-large") && !$previousNavbarEl.hasClass("navbar-transparent-visible");
    const previousNavIsLarge = $previousNavbarEl.hasClass("navbar-large");
    const previousNavIsCollapsed = $previousNavbarEl.hasClass("navbar-large-collapsed");
    const previousNavIsLargeTransparent = $previousNavbarEl.hasClass("navbar-large-transparent") || $previousNavbarEl.hasClass("navbar-large") && $previousNavbarEl.hasClass("navbar-transparent");
    const fromLarge = currentNavIsLarge && !currentNavIsCollapsed;
    const toLarge = previousNavIsLarge && !previousNavIsCollapsed;
    const $currentNavElements = $currentNavbarEl.find(".left, .title, .right, .subnavbar, .fading, .title-large, .navbar-bg");
    const $previousNavElements = $previousNavbarEl.find(".left, .title, .right, .subnavbar, .fading, .title-large, .navbar-bg");
    let activeNavBackIconText;
    let previousNavBackIconText;
    if (params.iosAnimateNavbarBackIcon) {
      if ($currentNavbarEl.hasClass("sliding") || $currentNavbarEl.find(".navbar-inner.sliding").length) {
        activeNavBackIconText = $currentNavbarEl.find(".left").find(".back .icon + span").eq(0);
      } else {
        activeNavBackIconText = $currentNavbarEl.find(".left.sliding").find(".back .icon + span").eq(0);
      }
      if ($previousNavbarEl.hasClass("sliding") || $previousNavbarEl.find(".navbar-inner.sliding").length) {
        previousNavBackIconText = $previousNavbarEl.find(".left").find(".back .icon + span").eq(0);
      } else {
        previousNavBackIconText = $previousNavbarEl.find(".left.sliding").find(".back .icon + span").eq(0);
      }
      if (activeNavBackIconText.length) {
        $previousNavElements.each((el) => {
          if (!$(el).hasClass("title")) return;
          el.f7NavbarLeftOffset += activeNavBackIconText.prev(".icon")[0].offsetWidth;
        });
      }
    }
    $currentNavElements.each((navEl) => {
      const $navEl = $(navEl);
      const isSubnavbar = $navEl.hasClass("subnavbar");
      const isLeft = $navEl.hasClass("left");
      const isTitle = $navEl.hasClass("title");
      const isBg = $navEl.hasClass("navbar-bg");
      if ((isTitle || isBg) && currentNavIsTransparent) return;
      if (!fromLarge && $navEl.hasClass(".title-large")) return;
      const el = {
        el: navEl
      };
      if (fromLarge) {
        if (isTitle) return;
        if ($navEl.hasClass("title-large")) {
          if (els.indexOf(el) < 0) els.push(el);
          el.overflow = "visible";
          $navEl.find(".title-large-text").each((subNavEl) => {
            els.push({
              el: subNavEl,
              transform: (progress) => `translateX(${progress * 100 * inverter}%)`
            });
          });
          return;
        }
      }
      if (toLarge) {
        if (!fromLarge) {
          if ($navEl.hasClass("title-large")) {
            if (els.indexOf(el) < 0) els.push(el);
            el.opacity = 0;
          }
        }
        if (isLeft) {
          if (els.indexOf(el) < 0) els.push(el);
          el.opacity = (progress) => 1 - progress ** 0.33;
          $navEl.find(".back span").each((subNavEl) => {
            els.push({
              el: subNavEl,
              "transform-origin": transformOrigin,
              transform: (progress) => `translateX(calc(${progress} * (var(--f7-navbarTitleLargeOffset) - var(--f7-navbarLeftTextOffset)))) translateY(calc(${progress} * (var(--f7-navbar-large-title-height) - var(--f7-navbar-large-title-padding-vertical) / 2))) scale(${1 + 1 * progress})`
            });
          });
          return;
        }
      }
      if (isBg) {
        if (els.indexOf(el) < 0) els.push(el);
        if (!fromLarge && !toLarge) {
          if (currentNavIsCollapsed) {
            if (currentNavIsLargeTransparent) {
              el.className = "ios-swipeback-navbar-bg-large";
            }
            el.transform = (progress) => `translateX(${100 * progress * inverter}%) translateY(calc(-1 * var(--f7-navbar-large-title-height)))`;
          } else {
            el.transform = (progress) => `translateX(${100 * progress * inverter}%)`;
          }
        }
        if (!fromLarge && toLarge) {
          el.className = "ios-swipeback-navbar-bg-large";
          el.transform = (progress) => `translateX(${100 * progress * inverter}%) translateY(calc(-1 * ${1 - progress} * var(--f7-navbar-large-title-height)))`;
        }
        if (fromLarge && toLarge) {
          el.transform = (progress) => `translateX(${100 * progress * inverter}%)`;
        }
        if (fromLarge && !toLarge) {
          el.transform = (progress) => `translateX(${100 * progress * inverter}%) translateY(calc(-${progress} * var(--f7-navbar-large-title-height)))`;
        }
        return;
      }
      if ($navEl.hasClass("title-large")) return;
      const isSliding = $navEl.hasClass("sliding") || $navEl.parents(".navbar-inner.sliding").length;
      if (els.indexOf(el) < 0) els.push(el);
      if (!isSubnavbar || isSubnavbar && !isSliding) {
        el.opacity = (progress) => 1 - progress ** 0.33;
      }
      if (isSliding) {
        let transformTarget = el;
        if (isLeft && activeNavBackIconText.length && params.iosAnimateNavbarBackIcon) {
          const textEl = {
            el: activeNavBackIconText[0]
          };
          transformTarget = textEl;
          els.push(textEl);
        }
        transformTarget.transform = (progress) => {
          let activeNavTranslate = progress * transformTarget.el.f7NavbarRightOffset;
          if (device.pixelRatio === 1) activeNavTranslate = Math.round(activeNavTranslate);
          if (isSubnavbar && currentNavIsLarge) {
            return `translate3d(${activeNavTranslate}px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0)`;
          }
          return `translate3d(${activeNavTranslate}px,0,0)`;
        };
      }
    });
    $previousNavElements.each((navEl) => {
      const $navEl = $(navEl);
      const isSubnavbar = $navEl.hasClass("subnavbar");
      const isLeft = $navEl.hasClass("left");
      const isTitle = $navEl.hasClass("title");
      const isBg = $navEl.hasClass("navbar-bg");
      if ((isTitle || isBg) && previousNavIsTransparent) return;
      const el = {
        el: navEl
      };
      if (toLarge) {
        if (isTitle) return;
        if (els.indexOf(el) < 0) els.push(el);
        if ($navEl.hasClass("title-large")) {
          el.opacity = 1;
          el.overflow = "visible";
          $navEl.find(".title-large-text").each((subNavEl) => {
            els.push({
              el: subNavEl,
              "transform-origin": transformOriginTitleLarge,
              opacity: (progress) => progress ** 3,
              transform: (progress) => `translateX(calc(${1 - progress} * (var(--f7-navbarLeftTextOffset) - var(--f7-navbarTitleLargeOffset)))) translateY(calc(${progress - 1} * var(--f7-navbar-large-title-height) + ${1 - progress} * var(--f7-navbar-large-title-padding-vertical))) scale(${0.5 + progress * 0.5})`
            });
          });
          return;
        }
      }
      if (isBg) {
        if (els.indexOf(el) < 0) els.push(el);
        if (!fromLarge && !toLarge) {
          if (previousNavIsCollapsed) {
            if (previousNavIsLargeTransparent) {
              el.className = "ios-swipeback-navbar-bg-large";
            }
            el.transform = (progress) => `translateX(${(-100 + 100 * progress) * inverter}%) translateY(calc(-1 * var(--f7-navbar-large-title-height)))`;
          } else {
            el.transform = (progress) => `translateX(${(-100 + 100 * progress) * inverter}%)`;
          }
        }
        if (!fromLarge && toLarge) {
          el.transform = (progress) => `translateX(${(-100 + 100 * progress) * inverter}%) translateY(calc(-1 * ${1 - progress} * var(--f7-navbar-large-title-height)))`;
        }
        if (fromLarge && !toLarge) {
          el.className = "ios-swipeback-navbar-bg-large";
          el.transform = (progress) => `translateX(${(-100 + 100 * progress) * inverter}%) translateY(calc(-${progress} * var(--f7-navbar-large-title-height)))`;
        }
        if (fromLarge && toLarge) {
          el.transform = (progress) => `translateX(${(-100 + 100 * progress) * inverter}%)`;
        }
        return;
      }
      if ($navEl.hasClass("title-large")) return;
      const isSliding = $navEl.hasClass("sliding") || $previousNavbarEl.children(".navbar-inner.sliding").length;
      if (els.indexOf(el) < 0) els.push(el);
      if (!isSubnavbar || isSubnavbar && !isSliding) {
        el.opacity = (progress) => progress ** 3;
      }
      if (isSliding) {
        let transformTarget = el;
        if (isLeft && previousNavBackIconText.length && params.iosAnimateNavbarBackIcon) {
          const textEl = {
            el: previousNavBackIconText[0]
          };
          transformTarget = textEl;
          els.push(textEl);
        }
        transformTarget.transform = (progress) => {
          let previousNavTranslate = transformTarget.el.f7NavbarLeftOffset * (1 - progress);
          if (device.pixelRatio === 1) previousNavTranslate = Math.round(previousNavTranslate);
          if (isSubnavbar && previousNavIsLarge) {
            return `translate3d(${previousNavTranslate}px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0)`;
          }
          return `translate3d(${previousNavTranslate}px,0,0)`;
        };
      }
    });
    return els;
  }
  function setAnimatableNavElements(_temp) {
    let {
      progress,
      reset,
      transition: transition2,
      reflow
    } = _temp === void 0 ? {} : _temp;
    const styles2 = ["overflow", "transform", "transform-origin", "opacity"];
    if (transition2 === true || transition2 === false) {
      for (let i = 0; i < animatableNavEls.length; i += 1) {
        const el = animatableNavEls[i];
        if (el && el.el) {
          if (transition2 === true) el.el.classList.add("navbar-page-transitioning");
          if (transition2 === false) el.el.classList.remove("navbar-page-transitioning");
        }
      }
    }
    if (reflow && animatableNavEls.length && animatableNavEls[0] && animatableNavEls[0].el) {
      animatableNavEls[0].el._clientLeft = animatableNavEls[0].el.clientLeft;
    }
    for (let i = 0; i < animatableNavEls.length; i += 1) {
      const el = animatableNavEls[i];
      if (el && el.el) {
        if (el.className && !el.classNameSet && !reset) {
          el.el.classList.add(el.className);
          el.classNameSet = true;
        }
        if (el.className && reset) {
          el.el.classList.remove(el.className);
        }
        for (let j = 0; j < styles2.length; j += 1) {
          const styleProp = styles2[j];
          if (el[styleProp]) {
            if (reset) {
              el.el.style[styleProp] = "";
            } else if (typeof el[styleProp] === "function") {
              el.el.style[styleProp] = el[styleProp](progress);
            } else {
              el.el.style[styleProp] = el[styleProp];
            }
          }
        }
      }
    }
  }
  function handleTouchStart(e) {
    if (!e.isTrusted) return;
    const swipeBackEnabled = params[`${app2.theme}SwipeBack`];
    if (!allowViewTouchMove || !swipeBackEnabled || isTouched || app2.swipeout && app2.swipeout.el || !router.allowPageChange) return;
    if ($(e.target).closest(".range-slider, .calendar-months").length > 0) return;
    if ($(e.target).closest(".page-master, .page-master-detail").length > 0 && params.masterDetailBreakpoint > 0 && app2.width >= params.masterDetailBreakpoint) return;
    isMoved = false;
    isTouched = true;
    isScrolling = void 0;
    touchesStart.x = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
    touchesStart.y = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
    touchStartTime = now$1();
    dynamicNavbar = router.dynamicNavbar;
  }
  function handleTouchMove(e) {
    if (!e.isTrusted) return;
    if (!isTouched) return;
    const pageX = e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
    const pageY = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
    if (typeof isScrolling === "undefined") {
      isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x)) || pageX < touchesStart.x && !app2.rtl || pageX > touchesStart.x && app2.rtl;
    }
    if (isScrolling || e.f7PreventSwipeBack || app2.preventSwipeBack) {
      isTouched = false;
      return;
    }
    if (!isMoved) {
      let cancel = false;
      const target = $(e.target);
      const swipeout = target.closest(".swipeout");
      if (swipeout.length > 0) {
        if (!app2.rtl && swipeout.find(".swipeout-actions-left").length > 0) cancel = true;
        if (app2.rtl && swipeout.find(".swipeout-actions-right").length > 0) cancel = true;
      }
      $currentPageEl = target.closest(".page");
      if ($currentPageEl.hasClass("no-swipeback") || target.closest(".no-swipeback, .card-opened").length > 0) cancel = true;
      $previousPageEl = $el.find(".page-previous");
      if ($previousPageEl.length > 1) {
        $previousPageEl = $previousPageEl.eq($previousPageEl.length - 1);
      }
      let notFromBorder = touchesStart.x - $el.offset().left > paramsSwipeBackActiveArea;
      viewContainerWidth = $el.width();
      if (app2.rtl) {
        notFromBorder = touchesStart.x < $el.offset().left - $el[0].scrollLeft + (viewContainerWidth - paramsSwipeBackActiveArea);
      } else {
        notFromBorder = touchesStart.x - $el.offset().left > paramsSwipeBackActiveArea;
      }
      if (notFromBorder) cancel = true;
      if ($previousPageEl.length === 0 || $currentPageEl.length === 0) cancel = true;
      if (cancel) {
        isTouched = false;
        return;
      }
      if (paramsSwipeBackAnimateShadow) {
        $pageShadowEl = $currentPageEl.find(".page-shadow-effect");
        if ($pageShadowEl.length === 0) {
          $pageShadowEl = $('<div class="page-shadow-effect"></div>');
          $currentPageEl.append($pageShadowEl);
        }
      }
      if (paramsSwipeBackAnimateOpacity) {
        $pageOpacityEl = $previousPageEl.find(".page-opacity-effect");
        if ($pageOpacityEl.length === 0) {
          $pageOpacityEl = $('<div class="page-opacity-effect"></div>');
          $previousPageEl.append($pageOpacityEl);
        }
      }
      if (dynamicNavbar) {
        $currentNavbarEl = $navbarsEl.find(".navbar-current");
        $previousNavbarEl = $navbarsEl.find(".navbar-previous");
        if ($previousNavbarEl.length > 1) {
          $previousNavbarEl = $previousNavbarEl.eq($previousNavbarEl.length - 1);
        }
        animatableNavEls = animatableNavElements();
      }
      if ($(".sheet.modal-in").length > 0 && app2.sheet) {
        app2.sheet.close($(".sheet.modal-in"));
      }
    }
    e.f7PreventSwipePanel = true;
    isMoved = true;
    app2.preventSwipePanelBySwipeBack = true;
    e.preventDefault();
    const inverter = app2.rtl ? -1 : 1;
    touchesDiff = (pageX - touchesStart.x - paramsSwipeBackThreshold) * inverter;
    if (touchesDiff < 0) touchesDiff = 0;
    const percentage = Math.min(Math.max(touchesDiff / viewContainerWidth, 0), 1);
    const callbackData = {
      percentage,
      progress: percentage,
      currentPageEl: $currentPageEl[0],
      previousPageEl: $previousPageEl[0],
      currentNavbarEl: $currentNavbarEl[0],
      previousNavbarEl: $previousNavbarEl[0]
    };
    $el.trigger("swipeback:move", callbackData);
    router.emit("swipebackMove", callbackData);
    let currentPageTranslate = touchesDiff * inverter;
    let previousPageTranslate = (touchesDiff / 5 - viewContainerWidth / 5) * inverter;
    if (!app2.rtl) {
      currentPageTranslate = Math.min(currentPageTranslate, viewContainerWidth);
      previousPageTranslate = Math.min(previousPageTranslate, 0);
    } else {
      currentPageTranslate = Math.max(currentPageTranslate, -viewContainerWidth);
      previousPageTranslate = Math.max(previousPageTranslate, 0);
    }
    if (device.pixelRatio === 1) {
      currentPageTranslate = Math.round(currentPageTranslate);
      previousPageTranslate = Math.round(previousPageTranslate);
    }
    router.swipeBackActive = true;
    $([$currentPageEl[0], $previousPageEl[0]]).addClass("page-swipeback-active");
    $currentPageEl.transform(`translate3d(${currentPageTranslate}px,0,0)`);
    if (paramsSwipeBackAnimateShadow) $pageShadowEl[0].style.opacity = 1 - 1 * percentage;
    if (app2.theme === "ios") {
      $previousPageEl.transform(`translate3d(${previousPageTranslate}px,0,0)`);
    }
    if (paramsSwipeBackAnimateOpacity) $pageOpacityEl[0].style.opacity = 1 - 1 * percentage;
    if (!dynamicNavbar) return;
    setAnimatableNavElements({
      progress: percentage
    });
  }
  function handleTouchEnd(e) {
    if (!e.isTrusted) return;
    app2.preventSwipePanelBySwipeBack = false;
    if (!isTouched || !isMoved) {
      isTouched = false;
      isMoved = false;
      return;
    }
    isTouched = false;
    isMoved = false;
    router.swipeBackActive = false;
    const $pages = $([$currentPageEl[0], $previousPageEl[0]]);
    $pages.removeClass("page-swipeback-active");
    if (touchesDiff === 0) {
      $pages.transform("");
      if ($pageShadowEl && $pageShadowEl.length > 0) $pageShadowEl.remove();
      if ($pageOpacityEl && $pageOpacityEl.length > 0) $pageOpacityEl.remove();
      if (dynamicNavbar) {
        setAnimatableNavElements({
          reset: true
        });
      }
      return;
    }
    const timeDiff = now$1() - touchStartTime;
    let pageChanged = false;
    if (timeDiff < 300 && touchesDiff > 10 || timeDiff >= 300 && touchesDiff > viewContainerWidth / 2) {
      $currentPageEl.removeClass("page-current").addClass(`page-next${app2.theme !== "ios" ? " page-next-on-right" : ""}`);
      $previousPageEl.removeClass("page-previous").addClass("page-current").removeAttr("aria-hidden");
      if ($pageShadowEl) $pageShadowEl[0].style.opacity = "";
      if ($pageOpacityEl) $pageOpacityEl[0].style.opacity = "";
      if (dynamicNavbar) {
        router.setNavbarPosition($currentNavbarEl, "next");
        router.setNavbarPosition($previousNavbarEl, "current", false);
      }
      pageChanged = true;
    }
    $pages.addClass("page-transitioning page-transitioning-swipeback");
    if (device.ios) {
      $currentPageEl[0]._clientLeft = $currentPageEl[0].clientLeft;
    }
    $pages.transform("");
    if (dynamicNavbar) {
      setAnimatableNavElements({
        progress: pageChanged ? 1 : 0,
        transition: true,
        reflow: !!device.ios
      });
    }
    allowViewTouchMove = false;
    router.allowPageChange = false;
    const callbackData = {
      currentPageEl: $currentPageEl[0],
      previousPageEl: $previousPageEl[0],
      currentNavbarEl: $currentNavbarEl[0],
      previousNavbarEl: $previousNavbarEl[0]
    };
    if (pageChanged) {
      router.currentRoute = $previousPageEl[0].f7Page.route;
      router.currentPage = $previousPageEl[0];
      router.pageCallback("beforeOut", $currentPageEl, $currentNavbarEl, "current", "next", {
        route: $currentPageEl[0].f7Page.route,
        swipeBack: true
      });
      router.pageCallback("beforeIn", $previousPageEl, $previousNavbarEl, "previous", "current", {
        route: $previousPageEl[0].f7Page.route,
        swipeBack: true
      }, $currentPageEl[0]);
      $el.trigger("swipeback:beforechange", callbackData);
      router.emit("swipebackBeforeChange", callbackData);
    } else {
      $el.trigger("swipeback:beforereset", callbackData);
      router.emit("swipebackBeforeReset", callbackData);
    }
    $currentPageEl.transitionEnd(() => {
      $pages.removeClass("page-transitioning page-transitioning-swipeback");
      if (dynamicNavbar) {
        setAnimatableNavElements({
          reset: true,
          transition: false
        });
      }
      allowViewTouchMove = true;
      router.allowPageChange = true;
      if (pageChanged) {
        if (router.history.length === 1) {
          router.history.unshift(router.url);
        }
        router.history.pop();
        router.saveHistory();
        if (params.browserHistory) {
          History.back();
        }
        router.pageCallback("afterOut", $currentPageEl, $currentNavbarEl, "current", "next", {
          route: $currentPageEl[0].f7Page.route,
          swipeBack: true
        });
        router.pageCallback("afterIn", $previousPageEl, $previousNavbarEl, "previous", "current", {
          route: $previousPageEl[0].f7Page.route,
          swipeBack: true
        });
        router.pageCallback("beforeRemove", $currentPageEl, $currentNavbarEl, "next", {
          swipeBack: true
        });
        router.removePage($currentPageEl);
        if (dynamicNavbar) {
          router.removeNavbar($currentNavbarEl);
        }
        $el.trigger("swipeback:afterchange", callbackData);
        router.emit("swipebackAfterChange", callbackData);
        router.emit("routeChanged", router.currentRoute, router.previousRoute, router);
        if (params.preloadPreviousPage) {
          router.back(router.history[router.history.length - 2], {
            preload: true
          });
        }
      } else {
        $el.trigger("swipeback:afterreset", callbackData);
        router.emit("swipebackAfterReset", callbackData);
      }
      if ($pageShadowEl && $pageShadowEl.length > 0) $pageShadowEl.remove();
      if ($pageOpacityEl && $pageOpacityEl.length > 0) $pageOpacityEl.remove();
    });
  }
  function attachEvents() {
    const passiveListener = app2.touchEvents.start === "touchstart" && support2.passiveListener ? {
      passive: true,
      capture: false
    } : false;
    $el.on(app2.touchEvents.start, handleTouchStart, passiveListener);
    app2.on("touchmove:active", handleTouchMove);
    app2.on("touchend:passive", handleTouchEnd);
  }
  function detachEvents() {
    const passiveListener = app2.touchEvents.start === "touchstart" && support2.passiveListener ? {
      passive: true,
      capture: false
    } : false;
    $el.off(app2.touchEvents.start, handleTouchStart, passiveListener);
    app2.off("touchmove:active", handleTouchMove);
    app2.off("touchend:passive", handleTouchEnd);
  }
  attachEvents();
  router.on("routerDestroy", detachEvents);
}
function redirect(direction, route, options) {
  const router = this;
  const r = route.route.redirect;
  const method = direction === "forward" ? "navigate" : "back";
  if (options.initial && router.params.browserHistory) {
    options.replaceState = true;
    options.history = true;
  }
  function redirectResolve(redirectUrl, redirectOptions) {
    if (redirectOptions === void 0) {
      redirectOptions = {};
    }
    router.allowPageChange = true;
    router[method](redirectUrl, extend$1({}, options, redirectOptions));
  }
  function redirectReject() {
    router.allowPageChange = true;
  }
  if (typeof r === "function") {
    router.allowPageChange = false;
    const redirectUrl = r.call(router, {
      router,
      to: route,
      resolve: redirectResolve,
      reject: redirectReject,
      direction,
      app: router.app
    });
    if (redirectUrl && typeof redirectUrl === "string") {
      router.allowPageChange = true;
      return router[method](redirectUrl, options);
    }
    return router;
  }
  return router[method](r, options);
}
function processQueue(router, routerQueue, routeQueue, to, from, resolve, reject, direction) {
  const queue = [];
  if (Array.isArray(routeQueue)) {
    queue.push(...routeQueue);
  } else if (routeQueue && typeof routeQueue === "function") {
    queue.push(routeQueue);
  }
  if (routerQueue) {
    if (Array.isArray(routerQueue)) {
      queue.push(...routerQueue);
    } else {
      queue.push(routerQueue);
    }
  }
  function next2() {
    if (queue.length === 0) {
      resolve();
      return;
    }
    const queueItem = queue.shift();
    queueItem.call(router, {
      router,
      to,
      from,
      resolve() {
        next2();
      },
      reject() {
        reject();
      },
      direction,
      app: router.app
    });
  }
  next2();
}
function processRouteQueue(to, from, resolve, reject, direction) {
  const router = this;
  function enterNextRoute() {
    if (to && to.route && (router.params.routesBeforeEnter || to.route.beforeEnter)) {
      router.allowPageChange = false;
      processQueue(router, router.params.routesBeforeEnter, to.route.beforeEnter, to, from, () => {
        router.allowPageChange = true;
        resolve();
      }, () => {
        reject();
      }, direction);
    } else {
      resolve();
    }
  }
  function leaveCurrentRoute() {
    if (from && from.route && (router.params.routesBeforeLeave || from.route.beforeLeave)) {
      router.allowPageChange = false;
      processQueue(router, router.params.routesBeforeLeave, from.route.beforeLeave, to, from, () => {
        router.allowPageChange = true;
        enterNextRoute();
      }, () => {
        reject();
      }, direction);
    } else {
      enterNextRoute();
    }
  }
  leaveCurrentRoute();
}
function appRouterCheck(router, method) {
  if (!router.view) {
    throw new Error(`Framework7: it is not allowed to use router methods on global app router. Use router methods only on related View, e.g. app.views.main.router.${method}(...)`);
  }
}
function asyncComponent(router, component, resolve, reject) {
  function resolvePromise(componentPromise) {
    componentPromise.then((c) => {
      resolve({
        component: c.default || c._default || c
      });
    }).catch((err) => {
      reject();
      throw new Error(err, {
        cause: err
      });
    });
  }
  if (component instanceof Promise) {
    resolvePromise(component);
    return;
  }
  const asyncComponentResult = component.call(router);
  if (asyncComponentResult instanceof Promise) {
    resolvePromise(asyncComponentResult);
  } else {
    resolve({
      component: asyncComponentResult
    });
  }
}
function refreshPage(props) {
  if (props === void 0) {
    props = {};
  }
  const router = this;
  appRouterCheck(router, "refreshPage");
  return router.navigate(router.currentRoute.url, {
    ignoreCache: true,
    reloadCurrent: true,
    props
  });
}
function forward(router, el, forwardOptions) {
  if (forwardOptions === void 0) {
    forwardOptions = {};
  }
  const document2 = getDocument();
  const $el = $(el);
  const app2 = router.app;
  const view = router.view;
  const options = extend$1(false, {
    animate: router.params.animate,
    browserHistory: true,
    replaceState: false,
    history: true,
    reloadCurrent: router.params.reloadPages,
    reloadPrevious: false,
    reloadAll: false,
    clearPreviousHistory: false,
    reloadDetail: router.params.reloadDetail,
    on: {}
  }, forwardOptions);
  const masterDetailEnabled = router.params.masterDetailBreakpoint > 0;
  const isMaster = masterDetailEnabled && options.route && options.route.route && (options.route.route.master === true || typeof options.route.route.master === "function" && options.route.route.master(app2, router));
  let masterPageEl;
  let otherDetailPageEl;
  let detailsInBetweenRemoved = 0;
  let currentRouteIsModal = router.currentRoute.modal;
  let modalType;
  if (!currentRouteIsModal) {
    "popup popover sheet loginScreen actions customModal panel".split(" ").forEach((modalLoadProp) => {
      if (router.currentRoute && router.currentRoute.route && router.currentRoute.route[modalLoadProp]) {
        currentRouteIsModal = true;
        modalType = modalLoadProp;
      }
    });
  }
  if (currentRouteIsModal) {
    const modalToClose = router.currentRoute.modal || router.currentRoute.route.modalInstance || app2[modalType].get();
    const previousUrl = router.history[router.history.length - 2];
    let previousRoute = router.findMatchingRoute(previousUrl);
    if (!previousRoute && previousUrl) {
      previousRoute = {
        url: previousUrl,
        path: previousUrl.split("?")[0],
        query: parseUrlQuery(previousUrl),
        route: {
          path: previousUrl.split("?")[0],
          url: previousUrl
        }
      };
    }
    router.modalRemove(modalToClose);
  }
  const dynamicNavbar = router.dynamicNavbar;
  const $viewEl = router.$el;
  const $newPage = $el;
  const reload = options.reloadPrevious || options.reloadCurrent || options.reloadAll;
  let $oldPage;
  let $navbarsEl;
  let $newNavbarEl;
  let $oldNavbarEl;
  router.allowPageChange = false;
  if ($newPage.length === 0) {
    router.allowPageChange = true;
    return router;
  }
  if ($newPage.length) {
    router.removeThemeElements($newPage);
  }
  if (dynamicNavbar) {
    $newNavbarEl = $newPage.children(".navbar");
    $navbarsEl = router.$navbarsEl;
    if ($newNavbarEl.length === 0 && $newPage[0] && $newPage[0].f7Page) {
      $newNavbarEl = $newPage[0].f7Page.$navbarEl;
    }
  }
  if (options.route && options.route.route && options.route.route.keepAlive && !options.route.route.keepAliveData) {
    options.route.route.keepAliveData = {
      pageEl: $el[0]
    };
  }
  const $pagesInView = $viewEl.children(".page").filter((pageInView) => pageInView !== $newPage[0]);
  let $navbarsInView;
  if (dynamicNavbar) {
    $navbarsInView = $navbarsEl.children(".navbar").filter((navbarInView) => navbarInView !== $newNavbarEl[0]);
  }
  if (options.reloadPrevious && $pagesInView.length < 2) {
    router.allowPageChange = true;
    return router;
  }
  let isDetail;
  let reloadDetail;
  let isDetailRoot;
  if (masterDetailEnabled && !options.reloadAll) {
    for (let i = 0; i < $pagesInView.length; i += 1) {
      if (!masterPageEl && $pagesInView[i].classList.contains("page-master")) {
        masterPageEl = $pagesInView[i];
        continue;
      }
    }
    isDetail = !isMaster && masterPageEl;
    if (isDetail) {
      if (masterPageEl) {
        for (let i = 0; i < $pagesInView.length; i += 1) {
          if ($pagesInView[i].classList.contains("page-master-detail")) {
            otherDetailPageEl = $pagesInView[i];
            continue;
          }
        }
      }
    }
    reloadDetail = isDetail && options.reloadDetail && app2.width >= router.params.masterDetailBreakpoint && masterPageEl;
  }
  if (isDetail) {
    isDetailRoot = !otherDetailPageEl || reloadDetail || options.reloadAll || options.reloadCurrent;
  }
  let newPagePosition = "next";
  if (options.reloadCurrent || options.reloadAll || reloadDetail) {
    newPagePosition = "current";
  } else if (options.reloadPrevious) {
    newPagePosition = "previous";
  }
  $newPage.removeClass("page-previous page-current page-next").addClass(`page-${newPagePosition}${isMaster ? " page-master" : ""}${isDetail ? " page-master-detail" : ""}${isDetailRoot ? " page-master-detail-root" : ""}`).trigger("page:unstack").trigger("page:position", {
    position: newPagePosition
  });
  router.emit("pageUnstack", $newPage[0]);
  router.emit("pagePosition", $newPage[0], newPagePosition);
  if (isMaster || isDetail) {
    $newPage.trigger("page:role", {
      role: isMaster ? "master" : "detail",
      root: !!isDetailRoot
    });
    router.emit("pageRole", $newPage[0], {
      role: isMaster ? "master" : "detail",
      detailRoot: !!isDetailRoot
    });
  }
  if (dynamicNavbar && $newNavbarEl.length) {
    $newNavbarEl.removeClass("navbar-previous navbar-current navbar-next").addClass(`navbar-${newPagePosition}${isMaster ? " navbar-master" : ""}${isDetail ? " navbar-master-detail" : ""}${isDetailRoot ? " navbar-master-detail-root" : ""}`);
    $newNavbarEl.trigger("navbar:position", {
      position: newPagePosition
    });
    router.emit("navbarPosition", $newNavbarEl[0], newPagePosition);
    if (isMaster || isDetail) {
      router.emit("navbarRole", $newNavbarEl[0], {
        role: isMaster ? "master" : "detail",
        detailRoot: !!isDetailRoot
      });
    }
  }
  if (options.reloadCurrent || reloadDetail) {
    if (reloadDetail) {
      $oldPage = $pagesInView.filter((pageEl) => !pageEl.classList.contains("page-master"));
      if (dynamicNavbar) {
        $oldNavbarEl = $($oldPage.map((pageEl) => app2.navbar.getElByPage(pageEl)));
      }
      if ($oldPage.length > 1 && masterPageEl) {
        detailsInBetweenRemoved = $oldPage.length - 1;
        $(masterPageEl).removeClass("page-master-stacked").trigger("page:masterunstack");
        router.emit("pageMasterUnstack", masterPageEl);
        if (dynamicNavbar) {
          $(app2.navbar.getElByPage(masterPageEl)).removeClass("navbar-master-stacked");
          router.emit("navbarMasterUnstack", app2.navbar.getElByPage(masterPageEl));
        }
      }
    } else {
      $oldPage = $pagesInView.eq($pagesInView.length - 1);
      if (dynamicNavbar) {
        $oldNavbarEl = $(app2.navbar.getElByPage($oldPage));
      }
    }
  } else if (options.reloadPrevious) {
    $oldPage = $pagesInView.eq($pagesInView.length - 2);
    if (dynamicNavbar) {
      $oldNavbarEl = $(app2.navbar.getElByPage($oldPage));
    }
  } else if (options.reloadAll) {
    $oldPage = $pagesInView.filter((pageEl) => pageEl !== $newPage[0]);
    if (dynamicNavbar) {
      $oldNavbarEl = $navbarsInView.filter((navbarEl) => navbarEl !== $newNavbarEl[0]);
    }
  } else {
    let removedPageEls = [];
    let removedNavbarEls = [];
    if ($pagesInView.length > 1) {
      let i = 0;
      for (i = 0; i < $pagesInView.length - 1; i += 1) {
        if (masterPageEl && $pagesInView[i] === masterPageEl) {
          $pagesInView.eq(i).addClass("page-master-stacked");
          $pagesInView.eq(i).trigger("page:masterstack");
          router.emit("pageMasterStack", $pagesInView[i]);
          if (dynamicNavbar) {
            $(app2.navbar.getElByPage(masterPageEl)).addClass("navbar-master-stacked");
            router.emit("navbarMasterStack", app2.navbar.getElByPage(masterPageEl));
          }
          continue;
        }
        const oldNavbarEl = app2.navbar.getElByPage($pagesInView.eq(i));
        removedPageEls.push($pagesInView[i]);
        router.pageCallback("beforeRemove", $pagesInView[i], $navbarsInView && $navbarsInView[i], "previous", void 0, options);
        router.removePage($pagesInView[i]);
        if (dynamicNavbar && oldNavbarEl) {
          removedNavbarEls.push(oldNavbarEl);
          router.removeNavbar(oldNavbarEl);
        }
      }
    }
    $oldPage = $viewEl.children(".page").filter((pageEl) => pageEl !== $newPage[0] && removedPageEls.indexOf(pageEl) < 0);
    if (dynamicNavbar) {
      $oldNavbarEl = $navbarsEl.children(".navbar").filter((navbarEl) => navbarEl !== $newNavbarEl[0] && removedNavbarEls.indexOf(removedNavbarEls) < 0);
    }
    removedPageEls = [];
    removedNavbarEls = [];
  }
  if (isDetail && !options.reloadAll) {
    if ($oldPage.length > 1 || reloadDetail) {
      $oldPage = $oldPage.filter((pageEl) => !pageEl.classList.contains("page-master"));
    }
    if ($oldNavbarEl && ($oldNavbarEl.length > 1 || reloadDetail)) {
      $oldNavbarEl = $oldNavbarEl.filter((navbarEl) => !navbarEl.classList.contains("navbar-master"));
    }
  }
  if (router.params.browserHistory && (options.browserHistory || options.replaceState) && !options.reloadPrevious) {
    const browserHistoryRoot = router.params.browserHistoryRoot || "";
    History[options.reloadCurrent || reloadDetail && otherDetailPageEl || options.reloadAll || options.replaceState ? "replace" : "push"](view.id, {
      url: options.route.url
    }, browserHistoryRoot + router.params.browserHistorySeparator + options.route.url);
  }
  if (!options.reloadPrevious) {
    router.currentPageEl = $newPage[0];
    if (dynamicNavbar && $newNavbarEl.length) {
      router.currentNavbarEl = $newNavbarEl[0];
    } else {
      delete router.currentNavbarEl;
    }
    router.currentRoute = options.route;
  }
  const url = options.route.url;
  if (options.history) {
    if (((options.reloadCurrent || reloadDetail && otherDetailPageEl) && router.history.length) > 0 || options.replaceState) {
      if (reloadDetail && detailsInBetweenRemoved > 0) {
        router.history = router.history.slice(0, router.history.length - detailsInBetweenRemoved);
        router.propsHistory = router.propsHistory.slice(0, router.propsHistory.length - detailsInBetweenRemoved);
      }
      router.history[router.history.length - (options.reloadPrevious ? 2 : 1)] = url;
      router.propsHistory[router.propsHistory.length - (options.reloadPrevious ? 2 : 1)] = options.props || {};
    } else if (options.reloadPrevious) {
      router.history[router.history.length - 2] = url;
      router.propsHistory[router.propsHistory.length - 2] = options.props || {};
    } else if (options.reloadAll) {
      router.history = [url];
      router.propsHistory = [options.props || {}];
    } else {
      router.history.push(url);
      router.propsHistory.push(options.props || {});
    }
  }
  router.saveHistory();
  const newPageInDom = $newPage.parents(document2).length > 0;
  const f7Component = $newPage[0].f7Component;
  if (options.reloadPrevious) {
    if (f7Component && !newPageInDom) {
      f7Component.mount((componentEl) => {
        $(componentEl).insertBefore($oldPage);
      });
    } else {
      $newPage.insertBefore($oldPage);
    }
    if (dynamicNavbar && $newNavbarEl.length) {
      if ($newNavbarEl.find(".title-large").length) {
        $newNavbarEl.addClass("navbar-large");
      }
      if ($oldNavbarEl.length) {
        $newNavbarEl.insertBefore($oldNavbarEl);
      } else {
        if (!router.$navbarsEl.parents(document2).length) {
          router.$el.prepend(router.$navbarsEl);
        }
        $navbarsEl.append($newNavbarEl);
      }
    }
  } else {
    if ($oldPage.next(".page")[0] !== $newPage[0]) {
      if (f7Component && !newPageInDom) {
        f7Component.mount((componentEl) => {
          $viewEl.append(componentEl);
        });
      } else {
        $viewEl.append($newPage[0]);
      }
    }
    if (dynamicNavbar && $newNavbarEl.length) {
      if ($newNavbarEl.find(".title-large").length) {
        $newNavbarEl.addClass("navbar-large");
      }
      if (!router.$navbarsEl.parents(document2).length) {
        router.$el.prepend(router.$navbarsEl);
      }
      $navbarsEl.append($newNavbarEl[0]);
    }
  }
  if (!newPageInDom) {
    router.pageCallback("mounted", $newPage, $newNavbarEl, newPagePosition, reload ? newPagePosition : "current", options, $oldPage);
  } else if (options.route && options.route.route && options.route.route.keepAlive && !$newPage[0].f7PageMounted) {
    $newPage[0].f7PageMounted = true;
    router.pageCallback("mounted", $newPage, $newNavbarEl, newPagePosition, reload ? newPagePosition : "current", options, $oldPage);
  }
  if ((options.reloadCurrent || reloadDetail) && $oldPage.length > 0) {
    router.pageCallback("beforeOut", $oldPage, $oldNavbarEl, "current", void 0, options);
    router.pageCallback("afterOut", $oldPage, $oldNavbarEl, "current", void 0, options);
    router.pageCallback("beforeRemove", $oldPage, $oldNavbarEl, "current", void 0, options);
    router.removePage($oldPage);
    if (dynamicNavbar && $oldNavbarEl && $oldNavbarEl.length) {
      router.removeNavbar($oldNavbarEl);
    }
  } else if (options.reloadAll) {
    $oldPage.each((pageEl, index2) => {
      const $oldPageEl = $(pageEl);
      const $oldNavbarElEl = $(app2.navbar.getElByPage($oldPageEl));
      if ($oldPageEl.hasClass("page-current")) {
        router.pageCallback("beforeOut", $oldPage, $oldNavbarEl, "current", void 0, options);
        router.pageCallback("afterOut", $oldPage, $oldNavbarEl, "current", void 0, options);
      }
      router.pageCallback("beforeRemove", $oldPageEl, $oldNavbarEl && $oldNavbarEl.eq(index2), "previous", void 0, options);
      router.removePage($oldPageEl);
      if (dynamicNavbar && $oldNavbarElEl.length) {
        router.removeNavbar($oldNavbarElEl);
      }
    });
  } else if (options.reloadPrevious) {
    router.pageCallback("beforeRemove", $oldPage, $oldNavbarEl, "previous", void 0, options);
    router.removePage($oldPage);
    if (dynamicNavbar && $oldNavbarEl && $oldNavbarEl.length) {
      router.removeNavbar($oldNavbarEl);
    }
  }
  if (options.route.route.tab) {
    router.tabLoad(options.route.route.tab, extend$1({}, options, {
      history: false,
      browserHistory: false
    }));
  }
  if (masterDetailEnabled) {
    view.checkMasterDetailBreakpoint();
  }
  router.pageCallback("init", $newPage, $newNavbarEl, newPagePosition, reload ? newPagePosition : "current", options, $oldPage);
  if (options.reloadCurrent || options.reloadAll || reloadDetail) {
    router.allowPageChange = true;
    router.pageCallback("beforeIn", $newPage, $newNavbarEl, newPagePosition, "current", options);
    $newPage.removeAttr("aria-hidden");
    if (dynamicNavbar && $newNavbarEl) {
      $newNavbarEl.removeAttr("aria-hidden");
    }
    router.pageCallback("afterIn", $newPage, $newNavbarEl, newPagePosition, "current", options);
    if (options.reloadCurrent && options.clearPreviousHistory) router.clearPreviousHistory();
    if (reloadDetail) {
      router.setPagePosition($(masterPageEl), "previous");
      if (masterPageEl.f7Page && masterPageEl.f7Page.navbarEl) {
        router.setNavbarPosition($(masterPageEl.f7Page.navbarEl), "previous");
      }
    }
    return router;
  }
  if (options.reloadPrevious) {
    router.allowPageChange = true;
    return router;
  }
  router.pageCallback("beforeOut", $oldPage, $oldNavbarEl, "current", "previous", options);
  router.pageCallback("beforeIn", $newPage, $newNavbarEl, "next", "current", options);
  function afterAnimation() {
    router.setPagePosition($newPage, "current", false);
    router.setPagePosition($oldPage, "previous", !$oldPage.hasClass("page-master"));
    if (dynamicNavbar) {
      router.setNavbarPosition($newNavbarEl, "current", false);
      router.setNavbarPosition($oldNavbarEl, "previous", !$oldNavbarEl.hasClass("navbar-master"));
    }
    router.allowPageChange = true;
    router.pageCallback("afterOut", $oldPage, $oldNavbarEl, "current", "previous", options);
    router.pageCallback("afterIn", $newPage, $newNavbarEl, "next", "current", options);
    let keepOldPage = (router.params.preloadPreviousPage || router.params[`${app2.theme}SwipeBack`]) && !isMaster;
    if (!keepOldPage) {
      if ($newPage.hasClass("smart-select-page") || $newPage.hasClass("photo-browser-page") || $newPage.hasClass("autocomplete-page") || $newPage.hasClass("color-picker-page")) {
        keepOldPage = true;
      }
    }
    if (!keepOldPage) {
      if (!($newPage.attr("data-name") && $newPage.attr("data-name") === "smart-select-page")) {
        router.pageCallback("beforeRemove", $oldPage, $oldNavbarEl, "previous", void 0, options);
        router.removePage($oldPage);
        if (dynamicNavbar && $oldNavbarEl.length) {
          router.removeNavbar($oldNavbarEl);
        }
      }
    }
    if (options.clearPreviousHistory) router.clearPreviousHistory();
    router.emit("routeChanged", router.currentRoute, router.previousRoute, router);
    if (router.params.browserHistory) {
      History.clearRouterQueue();
    }
  }
  function setPositionClasses() {
    router.setPagePosition($oldPage, "current", false);
    router.setPagePosition($newPage, "next", false);
    if (dynamicNavbar) {
      router.setNavbarPosition($oldNavbarEl, "current", false);
      router.setNavbarPosition($newNavbarEl, "next", false);
    }
  }
  if (options.animate && !(isMaster && app2.width >= router.params.masterDetailBreakpoint)) {
    const delay = router.params[`${router.app.theme}PageLoadDelay`];
    let transition2 = router.params.transition;
    if (options.transition) transition2 = options.transition;
    if (!transition2 && router.currentRoute && router.currentRoute.route) {
      transition2 = router.currentRoute.route.transition;
    }
    if (!transition2 && router.currentRoute && router.currentRoute.route.options) {
      transition2 = router.currentRoute.route.options.transition;
    }
    if (transition2) {
      $newPage[0].f7PageTransition = transition2;
    }
    if (delay) {
      setTimeout(() => {
        setPositionClasses();
        router.animate($oldPage, $newPage, $oldNavbarEl, $newNavbarEl, "forward", transition2, () => {
          afterAnimation();
        });
      }, delay);
    } else {
      setPositionClasses();
      router.animate($oldPage, $newPage, $oldNavbarEl, $newNavbarEl, "forward", transition2, () => {
        afterAnimation();
      });
    }
  } else {
    afterAnimation();
  }
  return router;
}
function load(router, loadParams, loadOptions, ignorePageChange) {
  if (loadParams === void 0) {
    loadParams = {};
  }
  if (loadOptions === void 0) {
    loadOptions = {};
  }
  if (!router.allowPageChange && !ignorePageChange) return router;
  const params = loadParams;
  const options = loadOptions;
  const {
    url,
    content,
    el,
    pageName,
    component,
    componentUrl
  } = params;
  if (!options.reloadCurrent && options.route && options.route.route && options.route.route.parentPath && router.currentRoute.route && router.currentRoute.route.parentPath === options.route.route.parentPath) {
    if (options.route.url === router.url) {
      router.allowPageChange = true;
      return false;
    }
    let sameParams = Object.keys(options.route.params).length === Object.keys(router.currentRoute.params).length;
    if (sameParams) {
      Object.keys(options.route.params).forEach((paramName) => {
        if (!(paramName in router.currentRoute.params) || router.currentRoute.params[paramName] !== options.route.params[paramName]) {
          sameParams = false;
        }
      });
    }
    if (sameParams) {
      if (options.route.route.tab) {
        return router.tabLoad(options.route.route.tab, options);
      }
      return false;
    }
    if (!sameParams && options.route.route.tab && router.currentRoute.route.tab && router.currentRoute.parentPath === options.route.parentPath) {
      return router.tabLoad(options.route.route.tab, options);
    }
  }
  if (options.route && options.route.url && router.url === options.route.url && !(options.reloadCurrent || options.reloadPrevious) && !router.params.allowDuplicateUrls) {
    router.allowPageChange = true;
    return false;
  }
  if (!options.route && url) {
    options.route = router.parseRouteUrl(url);
    extend$1(options.route, {
      route: {
        url,
        path: url
      }
    });
  }
  function resolve(pageEl, newOptions) {
    return forward(router, pageEl, extend$1(options, newOptions));
  }
  function reject() {
    router.allowPageChange = true;
    return router;
  }
  if (url || componentUrl || component) {
    router.allowPageChange = false;
  }
  if (content) {
    forward(router, router.getPageEl(content), options);
  } else if (el) {
    forward(router, router.getPageEl(el), options);
  } else if (pageName) {
    forward(router, router.$el.children(`.page[data-name="${pageName}"]`).eq(0), options);
  } else if (component || componentUrl) {
    try {
      router.pageComponentLoader({
        routerEl: router.el,
        component,
        componentUrl,
        options,
        resolve,
        reject
      });
    } catch (err) {
      router.allowPageChange = true;
      throw err;
    }
  } else if (url) {
    if (router.xhrAbortController) {
      router.xhrAbortController.abort();
      router.xhrAbortController = false;
    }
    router.xhrRequest(url, options).then((pageContent) => {
      forward(router, router.getPageEl(pageContent), options);
    }).catch(() => {
      router.allowPageChange = true;
    });
  }
  return router;
}
function navigate(navigateParams, navigateOptions) {
  if (navigateOptions === void 0) {
    navigateOptions = {};
  }
  const router = this;
  if (router.swipeBackActive) return router;
  let url;
  let createRoute;
  let name;
  let path2;
  let query;
  let params;
  let route;
  if (typeof navigateParams === "string") {
    url = navigateParams;
  } else {
    url = navigateParams.url;
    createRoute = navigateParams.route;
    name = navigateParams.name;
    path2 = navigateParams.path;
    query = navigateParams.query;
    params = navigateParams.params;
  }
  if (name || path2) {
    url = router.generateUrl({
      path: path2,
      name,
      params,
      query
    });
    if (url) {
      return router.navigate(url, navigateOptions);
    }
    return router;
  }
  const app2 = router.app;
  appRouterCheck(router, "navigate");
  if (url === "#" || url === "") {
    return router;
  }
  let navigateUrl = url.replace("./", "");
  if (navigateUrl[0] !== "/" && navigateUrl.indexOf("#") !== 0) {
    const currentPath = router.currentRoute.parentPath || router.currentRoute.path;
    navigateUrl = ((currentPath ? `${currentPath}/` : "/") + navigateUrl).replace("///", "/").replace("//", "/");
  }
  if (createRoute) {
    route = extend$1(router.parseRouteUrl(navigateUrl), {
      route: extend$1({}, createRoute)
    });
  } else {
    route = router.findMatchingRoute(navigateUrl);
  }
  if (!route) {
    return router;
  }
  if (route.route && route.route.viewName) {
    const anotherViewName = route.route.viewName;
    const anotherView = app2.views[anotherViewName];
    if (!anotherView) {
      throw new Error(`Framework7: There is no View with "${anotherViewName}" name that was specified in this route`);
    }
    if (anotherView !== router.view) {
      return anotherView.router.navigate(navigateParams, navigateOptions);
    }
  }
  if (route.route.redirect) {
    return redirect.call(router, "forward", route, navigateOptions);
  }
  const options = {};
  if (route.route.options) {
    extend$1(options, route.route.options, navigateOptions);
  } else {
    extend$1(options, navigateOptions);
  }
  if (options.openIn && (!router.params.ignoreOpenIn || router.params.ignoreOpenIn && router.history.length > 0)) {
    return router.openIn(router, navigateUrl, options);
  }
  options.route = route;
  function resolve() {
    let routerLoaded = false;
    "popup popover sheet loginScreen actions customModal panel".split(" ").forEach((modalLoadProp) => {
      if (route.route[modalLoadProp] && !routerLoaded) {
        routerLoaded = true;
        router.modalLoad(modalLoadProp, route, options, "forward");
      }
    });
    if (route.route.keepAlive && route.route.keepAliveData) {
      load(router, {
        el: route.route.keepAliveData.pageEl
      }, options, false);
      routerLoaded = true;
    }
    "url content component pageName el componentUrl".split(" ").forEach((pageLoadProp) => {
      if (route.route[pageLoadProp] && !routerLoaded) {
        routerLoaded = true;
        load(router, {
          [pageLoadProp]: route.route[pageLoadProp]
        }, options, false);
      }
    });
    if (routerLoaded) return;
    function asyncResolve(resolveParams, resolveOptions) {
      router.allowPageChange = false;
      let resolvedAsModal = false;
      "popup popover sheet loginScreen actions customModal panel".split(" ").forEach((modalLoadProp) => {
        if (resolveParams[modalLoadProp]) {
          resolvedAsModal = true;
          const modalRoute = extend$1({}, route, {
            route: resolveParams
          });
          router.allowPageChange = true;
          router.modalLoad(modalLoadProp, modalRoute, extend$1(options, resolveOptions), "forward");
        }
      });
      if (resolvedAsModal) return;
      load(router, resolveParams, extend$1(options, resolveOptions), true);
    }
    function asyncReject() {
      router.allowPageChange = true;
    }
    if (route.route.async) {
      router.allowPageChange = false;
      route.route.async.call(router, {
        router,
        to: options.route,
        from: router.currentRoute,
        resolve: asyncResolve,
        reject: asyncReject,
        direction: "forward",
        app: app2
      });
    }
    if (route.route.asyncComponent) {
      asyncComponent(router, route.route.asyncComponent, asyncResolve, asyncReject);
    }
  }
  function reject() {
    router.allowPageChange = true;
  }
  if (router.params.masterDetailBreakpoint > 0 && route.route.masterRoute) {
    let preloadMaster = true;
    let masterLoaded = false;
    if (router.currentRoute && router.currentRoute.route) {
      if ((router.currentRoute.route.master === true || typeof router.currentRoute.route.master === "function" && router.currentRoute.route.master(app2, router)) && (router.currentRoute.route === route.route.masterRoute || router.currentRoute.route.path === route.route.masterRoute.path)) {
        preloadMaster = false;
      }
      if (router.currentRoute.route.masterRoute && (router.currentRoute.route.masterRoute === route.route.masterRoute || router.currentRoute.route.masterRoute.path === route.route.masterRoute.path)) {
        preloadMaster = false;
        masterLoaded = true;
      }
    }
    if (preloadMaster || masterLoaded && navigateOptions.reloadAll) {
      router.navigate({
        path: route.route.masterRoute.path,
        params: route.params || {}
      }, {
        animate: false,
        reloadAll: navigateOptions.reloadAll,
        reloadCurrent: navigateOptions.reloadCurrent,
        reloadPrevious: navigateOptions.reloadPrevious,
        browserHistory: !navigateOptions.initial,
        history: !navigateOptions.initial,
        once: {
          pageAfterIn() {
            router.navigate(navigateParams, extend$1({}, navigateOptions, {
              animate: false,
              reloadAll: false,
              reloadCurrent: false,
              reloadPrevious: false,
              history: !navigateOptions.initial,
              browserHistory: !navigateOptions.initial
            }));
          }
        }
      });
      return router;
    }
  }
  processRouteQueue.call(router, route, router.currentRoute, () => {
    if (route.route.modules) {
      app2.loadModules(Array.isArray(route.route.modules) ? route.route.modules : [route.route.modules]).then(() => {
        resolve();
      }).catch(() => {
        reject();
      });
    } else {
      resolve();
    }
  }, () => {
    reject();
  }, "forward");
  return router;
}
function tabLoad(tabRoute, loadOptions) {
  if (loadOptions === void 0) {
    loadOptions = {};
  }
  const router = this;
  const options = extend$1({
    animate: router.params.animate,
    browserHistory: true,
    history: true,
    parentPageEl: null,
    preload: false,
    on: {}
  }, loadOptions);
  let currentRoute;
  let previousRoute;
  if (options.route) {
    if (!options.preload && options.route !== router.currentRoute) {
      previousRoute = router.previousRoute;
      router.currentRoute = options.route;
    }
    if (options.preload) {
      currentRoute = options.route;
      previousRoute = router.currentRoute;
    } else {
      currentRoute = router.currentRoute;
      if (!previousRoute) previousRoute = router.previousRoute;
    }
    if (router.params.browserHistory && options.browserHistory && !options.reloadPrevious) {
      History[router.params.browserHistoryTabs](router.view.id, {
        url: options.route.url
      }, (router.params.browserHistoryRoot || "") + router.params.browserHistorySeparator + options.route.url);
    }
    if (options.history) {
      router.history[Math.max(router.history.length - 1, 0)] = options.route.url;
      router.saveHistory();
    }
  }
  const $parentPageEl = $(options.parentPageEl || router.currentPageEl);
  let tabEl;
  if ($parentPageEl.length && $parentPageEl.find(`#${tabRoute.id}`).length) {
    tabEl = $parentPageEl.find(`#${tabRoute.id}`).eq(0);
  } else if (router.view.selector) {
    tabEl = `${router.view.selector} #${tabRoute.id}`;
  } else {
    tabEl = `#${tabRoute.id}`;
  }
  const tabShowResult = router.app.tab.show({
    tabEl,
    animate: options.animate,
    tabRoute: options.route
  });
  const {
    $newTabEl,
    $oldTabEl,
    animated,
    onTabsChanged
  } = tabShowResult;
  if ($newTabEl && $newTabEl.parents(".page").length > 0 && options.route) {
    const tabParentPageData = $newTabEl.parents(".page")[0].f7Page;
    if (tabParentPageData && options.route) {
      tabParentPageData.route = options.route;
    }
  }
  function onTabLoaded(contentEl) {
    router.removeThemeElements($newTabEl);
    let tabEventTarget = $newTabEl;
    if (typeof contentEl !== "string") tabEventTarget = $(contentEl);
    tabEventTarget.trigger("tab:init tab:mounted", tabRoute);
    router.emit("tabInit tabMounted", $newTabEl[0], tabRoute);
    if ($oldTabEl && $oldTabEl.length) {
      if (animated) {
        onTabsChanged(() => {
          router.emit("routeChanged", router.currentRoute, router.previousRoute, router);
          if (router.params.unloadTabContent) {
            router.tabRemove($oldTabEl, $newTabEl, tabRoute);
          }
        });
      } else {
        router.emit("routeChanged", router.currentRoute, router.previousRoute, router);
        if (router.params.unloadTabContent) {
          router.tabRemove($oldTabEl, $newTabEl, tabRoute);
        }
      }
    }
  }
  if ($newTabEl[0].f7RouterTabLoaded) {
    if (!$oldTabEl || !$oldTabEl.length) return router;
    if (animated) {
      onTabsChanged(() => {
        router.emit("routeChanged", router.currentRoute, router.previousRoute, router);
      });
    } else {
      router.emit("routeChanged", router.currentRoute, router.previousRoute, router);
    }
    return router;
  }
  function loadTab(loadTabParams, loadTabOptions) {
    const {
      url,
      content,
      el,
      component,
      componentUrl
    } = loadTabParams;
    function resolve(contentEl) {
      router.allowPageChange = true;
      if (!contentEl) return;
      if (typeof contentEl === "string") {
        $newTabEl.html(contentEl);
      } else {
        $newTabEl.html("");
        if (contentEl.f7Component) {
          contentEl.f7Component.mount((componentEl) => {
            $newTabEl.append(componentEl);
          });
        } else {
          $newTabEl.append(contentEl);
        }
      }
      $newTabEl[0].f7RouterTabLoaded = true;
      onTabLoaded(contentEl);
    }
    function reject() {
      router.allowPageChange = true;
      return router;
    }
    if (content) {
      resolve(content);
    } else if (el) {
      resolve(el);
    } else if (component || componentUrl) {
      try {
        router.tabComponentLoader({
          tabEl: $newTabEl[0],
          component,
          componentUrl,
          options: loadTabOptions,
          resolve,
          reject
        });
      } catch (err) {
        router.allowPageChange = true;
        throw err;
      }
    } else if (url) {
      if (router.xhrAbortController) {
        router.xhrAbortController.abort();
        router.xhrAbortController = false;
      }
      router.xhrRequest(url, loadTabOptions).then((tabContent) => {
        resolve(tabContent);
      }).catch(() => {
        router.allowPageChange = true;
      });
    }
  }
  let hasContentLoadProp;
  "url content component el componentUrl".split(" ").forEach((tabLoadProp) => {
    if (tabRoute[tabLoadProp]) {
      hasContentLoadProp = true;
      loadTab({
        [tabLoadProp]: tabRoute[tabLoadProp]
      }, options);
    }
  });
  function asyncResolve(resolveParams, resolveOptions) {
    loadTab(resolveParams, extend$1(options, resolveOptions));
  }
  function asyncReject() {
    router.allowPageChange = true;
  }
  if (tabRoute.async) {
    tabRoute.async.call(router, {
      router,
      to: currentRoute,
      from: previousRoute,
      resolve: asyncResolve,
      reject: asyncReject,
      app: router.app
    });
  } else if (tabRoute.asyncComponent) {
    asyncComponent(router, tabRoute.asyncComponent, asyncResolve, asyncReject);
  } else if (!hasContentLoadProp) {
    router.allowPageChange = true;
  }
  return router;
}
function tabRemove($oldTabEl, $newTabEl, tabRoute) {
  const router = this;
  let hasTabComponentChild;
  if ($oldTabEl[0]) {
    $oldTabEl[0].f7RouterTabLoaded = false;
    delete $oldTabEl[0].f7RouterTabLoaded;
  }
  $oldTabEl.children().each((tabChild) => {
    if (tabChild.f7Component) {
      hasTabComponentChild = true;
      $(tabChild).trigger("tab:beforeremove", tabRoute);
      tabChild.f7Component.destroy();
    }
  });
  if (!hasTabComponentChild) {
    $oldTabEl.trigger("tab:beforeremove", tabRoute);
  }
  router.emit("tabBeforeRemove", $oldTabEl[0], $newTabEl[0], tabRoute);
  router.removeTabContent($oldTabEl[0], tabRoute);
}
function modalLoad(modalType, route, loadOptions, direction) {
  if (loadOptions === void 0) {
    loadOptions = {};
  }
  const router = this;
  const app2 = router.app;
  const isPanel = modalType === "panel";
  const modalOrPanel = isPanel ? "panel" : "modal";
  const options = extend$1({
    animate: router.params.animate,
    browserHistory: true,
    history: true,
    on: {},
    once: {}
  }, loadOptions);
  const modalParams = extend$1({}, route.route[modalType]);
  const modalRoute = route.route;
  const routeCallback = (modal, name) => {
    const {
      on: on2,
      once: once2
    } = options;
    let callback;
    if (name === "open") {
      callback = on2.modalOpen || once2.modalOpen || on2.panelOpen || once2.panelOpen;
    }
    if (name === "close") {
      callback = on2.modalClose || once2.modalClose || on2.panelClose || once2.panelClose;
    }
    if (name === "closed") {
      callback = on2.modalClosed || once2.modalClosed || on2.panelClosed || once2.panelClosed;
    }
    if (callback) callback(modal);
  };
  function onModalLoaded() {
    const modal = app2[modalType].create(modalParams);
    modalRoute.modalInstance = modal;
    const hasEl = modal.el;
    function closeOnSwipeBack() {
      modal.close();
    }
    modal.on(`${modalOrPanel}Open`, () => {
      if (!hasEl) {
        router.removeThemeElements(modal.el);
        modal.$el.trigger(`${modalType.toLowerCase()}:init ${modalType.toLowerCase()}:mounted`, route, modal);
        router.emit(`${!isPanel ? "modalInit" : ""} ${modalType}Init ${modalType}Mounted`, modal.el, route, modal);
      }
      router.once("swipeBackMove", closeOnSwipeBack);
      routeCallback(modal, "open");
    });
    modal.on(`${modalOrPanel}Close`, () => {
      router.off("swipeBackMove", closeOnSwipeBack);
      if (!modal.closeByRouter) {
        router.back();
      }
      routeCallback(modal, "close");
    });
    modal.on(`${modalOrPanel}Closed`, () => {
      modal.$el.trigger(`${modalType.toLowerCase()}:beforeremove`, route, modal);
      modal.emit(`${!isPanel ? "modalBeforeRemove " : ""}${modalType}BeforeRemove`, modal.el, route, modal);
      const modalComponent = modal.el.f7Component;
      routeCallback(modal, "closed");
      if (modalComponent) {
        modalComponent.destroy();
      }
      nextTick(() => {
        if (modalComponent || modalParams.component || modalParams.asyncComponent || modalParams.async) {
          router.removeModal(modal.el);
        }
        modal.destroy();
        delete modal.route;
        delete modalRoute.modalInstance;
      });
    });
    if (options.route) {
      if (router.params.browserHistory && options.browserHistory) {
        History.push(router.view.id, {
          url: options.route.url,
          modal: modalType
        }, (router.params.browserHistoryRoot || "") + router.params.browserHistorySeparator + options.route.url);
      }
      if (options.route !== router.currentRoute) {
        modal.route = extend$1(options.route, {
          modal
        });
        router.currentRoute = modal.route;
      }
      if (options.history && !options.reloadCurrent) {
        router.history.push(options.route.url);
        router.saveHistory();
      }
    }
    if (hasEl) {
      router.removeThemeElements(modal.el);
      modal.$el.trigger(`${modalType.toLowerCase()}:init ${modalType.toLowerCase()}:mounted`, route, modal);
      router.emit(`${modalOrPanel}Init ${modalType}Init ${modalType}Mounted`, modal.el, route, modal);
    }
    modal.open(options.animate === false || options.animate === true ? options.animate : void 0);
  }
  function loadModal(loadModalParams, loadModalOptions) {
    const {
      url,
      content,
      component,
      componentUrl
    } = loadModalParams;
    function resolve(contentEl) {
      if (contentEl) {
        if (typeof contentEl === "string") {
          modalParams.content = contentEl;
        } else if (contentEl.f7Component) {
          contentEl.f7Component.mount((componentEl) => {
            modalParams.el = componentEl;
            app2.$el.append(componentEl);
          });
        } else {
          modalParams.el = contentEl;
        }
        onModalLoaded();
      }
    }
    function reject() {
      router.allowPageChange = true;
      return router;
    }
    if (content) {
      resolve(content);
    } else if (component || componentUrl) {
      try {
        router.modalComponentLoader({
          rootEl: app2.el,
          component,
          componentUrl,
          options: loadModalOptions,
          resolve,
          reject
        });
      } catch (err) {
        router.allowPageChange = true;
        throw err;
      }
    } else if (url) {
      if (router.xhrAbortController) {
        router.xhrAbortController.abort();
        router.xhrAbortController = false;
      }
      router.xhrRequest(url, loadModalOptions).then((modalContent) => {
        modalParams.content = modalContent;
        onModalLoaded();
      }).catch(() => {
        router.allowPageChange = true;
      });
    } else {
      onModalLoaded();
    }
  }
  let foundLoadProp;
  "url content component el componentUrl template".split(" ").forEach((modalLoadProp) => {
    if (modalParams[modalLoadProp] && !foundLoadProp) {
      foundLoadProp = true;
      loadModal({
        [modalLoadProp]: modalParams[modalLoadProp]
      }, options);
    }
  });
  if (!foundLoadProp && modalType === "actions") {
    onModalLoaded();
  }
  function asyncResolve(resolveParams, resolveOptions) {
    loadModal(resolveParams, extend$1(options, resolveOptions));
  }
  function asyncReject() {
    router.allowPageChange = true;
  }
  if (modalParams.async) {
    modalParams.async.call(router, {
      router,
      to: options.route,
      from: router.currentRoute,
      resolve: asyncResolve,
      reject: asyncReject,
      direction,
      app: app2
    });
  }
  if (modalParams.asyncComponent) {
    asyncComponent(router, modalParams.asyncComponent, asyncResolve, asyncReject);
  }
  return router;
}
function modalRemove(modal) {
  extend$1(modal, {
    closeByRouter: true
  });
  modal.close();
}
function backward(router, el, backwardOptions) {
  const device = getDevice();
  const document2 = getDocument();
  const $el = $(el);
  const app2 = router.app;
  const view = router.view;
  const options = extend$1(false, {
    animate: router.params.animate,
    browserHistory: true,
    replaceState: false
  }, backwardOptions);
  const masterDetailEnabled = router.params.masterDetailBreakpoint > 0;
  const isMaster = masterDetailEnabled && options.route && options.route.route && (options.route.route.master === true || typeof options.route.route.master === "function" && options.route.route.master(app2, router));
  let masterPageEl;
  let masterPageRemoved;
  const dynamicNavbar = router.dynamicNavbar;
  const $newPage = $el;
  const $oldPage = router.$el.children(".page-current");
  const initialPreload = $oldPage.length === 0 && options.preload;
  const currentIsMaster = masterDetailEnabled && $oldPage.hasClass("page-master");
  if ($newPage.length) {
    router.removeThemeElements($newPage);
  }
  let $navbarsEl;
  let $newNavbarEl;
  let $oldNavbarEl;
  if (dynamicNavbar) {
    $newNavbarEl = $newPage.children(".navbar");
    $navbarsEl = router.$navbarsEl;
    if ($newNavbarEl.length === 0 && $newPage[0] && $newPage[0].f7Page) {
      $newNavbarEl = $newPage[0].f7Page.$navbarEl;
    }
    $oldNavbarEl = $navbarsEl.find(".navbar-current");
  }
  router.allowPageChange = false;
  if ($newPage.length === 0 || $oldPage.length === 0 && !options.preload) {
    router.allowPageChange = true;
    return router;
  }
  router.removeThemeElements($newPage);
  if (options.route && options.route.route && options.route.route.keepAlive && !options.route.route.keepAliveData) {
    options.route.route.keepAliveData = {
      pageEl: $el[0]
    };
  }
  let isDetail;
  let isDetailRoot;
  if (masterDetailEnabled) {
    const $pagesInView = router.$el.children(".page").filter((pageInView) => pageInView !== $newPage[0]);
    for (let i = 0; i < $pagesInView.length; i += 1) {
      if (!masterPageEl && $pagesInView[i].classList.contains("page-master")) {
        masterPageEl = $pagesInView[i];
        continue;
      }
    }
    isDetail = !isMaster && masterPageEl && router.history.indexOf(options.route.url) > router.history.indexOf(masterPageEl.f7Page.route.url);
    if (!isDetail && !isMaster && masterPageEl && masterPageEl.f7Page && options.route.route.masterRoute) {
      isDetail = options.route.route.masterRoute.path === masterPageEl.f7Page.route.route.path;
    }
  }
  if (isDetail && masterPageEl && masterPageEl.f7Page) {
    isDetailRoot = router.history.indexOf(options.route.url) - router.history.indexOf(masterPageEl.f7Page.route.url) === 1;
  }
  $newPage.addClass(`page-${initialPreload ? "current" : "previous"}${isMaster ? " page-master" : ""}${isDetail ? " page-master-detail" : ""}${isDetailRoot ? " page-master-detail-root" : ""}`).removeAttr("aria-hidden").trigger("page:unstack").trigger("page:position", {
    position: initialPreload ? "current" : "previous"
  });
  router.emit("pageUnstack", $newPage[0]);
  router.emit("pagePosition", $newPage[0], initialPreload ? "current" : "previous");
  if (isMaster || isDetail) {
    $newPage.trigger("page:role", {
      role: isMaster ? "master" : "detail",
      root: !!isDetailRoot
    });
    router.emit("pageRole", $newPage[0], {
      role: isMaster ? "master" : "detail",
      detailRoot: !!isDetailRoot
    });
  }
  if (dynamicNavbar && $newNavbarEl.length > 0) {
    $newNavbarEl.addClass(`navbar-${initialPreload ? "current" : "previous"}${isMaster ? " navbar-master" : ""}${isDetail ? " navbar-master-detail" : ""}${isDetailRoot ? " navbar-master-detail-root" : ""}`).removeAttr("aria-hidden");
    $newNavbarEl.trigger("navbar:position", {
      position: initialPreload ? "current" : "previous"
    });
    router.emit("navbarPosition", $newNavbarEl[0], initialPreload ? "current" : "previous");
    if (isMaster || isDetailRoot) {
      router.emit("navbarRole", $newNavbarEl[0], {
        role: isMaster ? "master" : "detail",
        detailRoot: !!isDetailRoot
      });
    }
  }
  let backIndex;
  if (options.force) {
    if ($oldPage.prev(".page-previous").length >= 0) {
      if (router.history.indexOf(options.route.url) >= 0) {
        backIndex = router.history.length - router.history.indexOf(options.route.url) - 1;
        router.history = router.history.slice(0, router.history.indexOf(options.route.url) + 2);
        router.propsHistory = router.propsHistory.slice(0, router.history.indexOf(options.route.url) + 2);
        view.history = router.history;
      } else if (router.history[[router.history.length - 2]]) {
        router.propsHistory[router.propsHistory.length - 2] = options.props || {};
      } else {
        router.history.unshift(router.url);
        router.propsHistory.unshift(options.props || {});
      }
      const $pageToRemove = $oldPage.prev(".page-previous");
      let $navbarToRemove;
      if (dynamicNavbar) {
        $navbarToRemove = $(app2.navbar.getElByPage($pageToRemove));
      }
      if ($pageToRemove.length > 0) {
        router.pageCallback("beforeRemove", $pageToRemove, $navbarToRemove, "previous", void 0, options);
        if ($pageToRemove[0] === masterPageEl) {
          masterPageRemoved = true;
        }
        router.removePage($pageToRemove);
        if (dynamicNavbar && $navbarToRemove.length) {
          router.removeNavbar($navbarToRemove);
        }
      }
    }
  }
  const newPageInDom = $newPage.parents(document2).length > 0;
  const f7Component = $newPage[0].f7Component;
  function insertPage() {
    if (initialPreload) {
      if (!newPageInDom && f7Component) {
        f7Component.mount((componentEl) => {
          router.$el.append(componentEl);
        });
      } else {
        router.$el.append($newPage);
      }
    }
    if ($newPage.next($oldPage).length === 0) {
      if (!newPageInDom && f7Component) {
        f7Component.mount((componentEl) => {
          $(componentEl).insertBefore($oldPage);
        });
      } else {
        $newPage.insertBefore($oldPage);
      }
    }
    if (dynamicNavbar && $newNavbarEl.length) {
      if ($newNavbarEl.find(".title-large").length) {
        $newNavbarEl.addClass("navbar-large");
      }
      $newNavbarEl.insertBefore($oldNavbarEl);
      if ($oldNavbarEl.length > 0) {
        $newNavbarEl.insertBefore($oldNavbarEl);
      } else {
        if (!router.$navbarsEl.parents(document2).length) {
          router.$el.prepend(router.$navbarsEl);
        }
        $navbarsEl.append($newNavbarEl);
      }
    }
    if (!newPageInDom) {
      router.pageCallback("mounted", $newPage, $newNavbarEl, "previous", "current", options, $oldPage);
    } else if (options.route && options.route.route && options.route.route.keepAlive && !$newPage[0].f7PageMounted) {
      $newPage[0].f7PageMounted = true;
      router.pageCallback("mounted", $newPage, $newNavbarEl, "previous", "current", options, $oldPage);
    }
  }
  if (options.preload) {
    insertPage();
    if (options.route.route.tab) {
      router.tabLoad(options.route.route.tab, extend$1({}, options, {
        history: false,
        browserHistory: false,
        preload: true
      }));
    }
    if (isMaster) {
      $newPage.removeClass("page-master-stacked").trigger("page:masterunstack");
      router.emit("pageMasterUnstack", $newPage[0]);
      if (dynamicNavbar) {
        $(app2.navbar.getElByPage($newPage)).removeClass("navbar-master-stacked");
        router.emit("navbarMasterUnstack", app2.navbar.getElByPage($newPage));
      }
    }
    router.pageCallback("init", $newPage, $newNavbarEl, "previous", "current", options, $oldPage);
    if (initialPreload) {
      router.pageCallback("beforeIn", $newPage, $newNavbarEl, "current", void 0, options);
      router.pageCallback("afterIn", $newPage, $newNavbarEl, "current", void 0, options);
    }
    const $previousPages = $newPage.prevAll(".page-previous:not(.page-master)");
    if ($previousPages.length > 0) {
      $previousPages.each((pageToRemove) => {
        const $pageToRemove = $(pageToRemove);
        let $navbarToRemove;
        if (dynamicNavbar) {
          $navbarToRemove = $(app2.navbar.getElByPage($pageToRemove));
        }
        router.pageCallback("beforeRemove", $pageToRemove, $navbarToRemove, "previous", void 0);
        router.removePage($pageToRemove);
        if (dynamicNavbar && $navbarToRemove.length) {
          router.removeNavbar($navbarToRemove);
        }
      });
    }
    router.allowPageChange = true;
    return router;
  }
  if (!(device.ie || device.edge || device.firefox && !device.ios)) {
    if (router.params.browserHistory && options.browserHistory) {
      if (options.replaceState) {
        const browserHistoryRoot = router.params.browserHistoryRoot || "";
        History.replace(view.id, {
          url: options.route.url
        }, browserHistoryRoot + router.params.browserHistorySeparator + options.route.url);
      } else if (backIndex) {
        History.go(-backIndex);
      } else {
        History.back();
      }
    }
  }
  if (options.replaceState) {
    router.history[router.history.length - 1] = options.route.url;
    router.propsHistory[router.propsHistory.length - 1] = options.props || {};
  } else {
    if (router.history.length === 1) {
      router.history.unshift(router.url);
      router.propsHistory.unshift(options.props || {});
    }
    router.history.pop();
    router.propsHistory.pop();
  }
  router.saveHistory();
  router.currentPageEl = $newPage[0];
  if (dynamicNavbar && $newNavbarEl.length) {
    router.currentNavbarEl = $newNavbarEl[0];
  } else {
    delete router.currentNavbarEl;
  }
  router.currentRoute = options.route;
  if (device.ie || device.edge || device.firefox && !device.ios) {
    if (router.params.browserHistory && options.browserHistory) {
      if (options.replaceState) {
        const browserHistoryRoot = router.params.browserHistoryRoot || "";
        History.replace(view.id, {
          url: options.route.url
        }, browserHistoryRoot + router.params.browserHistorySeparator + options.route.url);
      } else if (backIndex) {
        History.go(-backIndex);
      } else {
        History.back();
      }
    }
  }
  insertPage();
  if (options.route.route.tab) {
    router.tabLoad(options.route.route.tab, extend$1({}, options, {
      history: false,
      browserHistory: false
    }));
  }
  if (masterDetailEnabled && (currentIsMaster || masterPageRemoved)) {
    view.checkMasterDetailBreakpoint(false);
  }
  router.pageCallback("init", $newPage, $newNavbarEl, "previous", "current", options, $oldPage);
  router.pageCallback("beforeOut", $oldPage, $oldNavbarEl, "current", "next", options);
  router.pageCallback("beforeIn", $newPage, $newNavbarEl, "previous", "current", options);
  function afterAnimation() {
    router.setPagePosition($newPage, "current", false);
    router.setPagePosition($oldPage, "next", true);
    if (dynamicNavbar) {
      router.setNavbarPosition($newNavbarEl, "current", false);
      router.setNavbarPosition($oldNavbarEl, "next", true);
    }
    router.pageCallback("afterOut", $oldPage, $oldNavbarEl, "current", "next", options);
    router.pageCallback("afterIn", $newPage, $newNavbarEl, "previous", "current", options);
    router.pageCallback("beforeRemove", $oldPage, $oldNavbarEl, "next", void 0, options);
    router.removePage($oldPage);
    if (dynamicNavbar && $oldNavbarEl.length) {
      router.removeNavbar($oldNavbarEl);
    }
    router.allowPageChange = true;
    router.emit("routeChanged", router.currentRoute, router.previousRoute, router);
    const preloadPreviousPage = router.params.preloadPreviousPage || router.params[`${app2.theme}SwipeBack`];
    if (preloadPreviousPage && router.history[router.history.length - 2] && !isMaster) {
      router.back(router.history[router.history.length - 2], {
        preload: true,
        props: router.propsHistory[router.propsHistory.length - 2] || {}
      });
    }
    if (router.params.browserHistory) {
      History.clearRouterQueue();
    }
  }
  function setPositionClasses() {
    router.setPagePosition($oldPage, "current");
    router.setPagePosition($newPage, "previous", false);
    if (dynamicNavbar) {
      router.setNavbarPosition($oldNavbarEl, "current");
      router.setNavbarPosition($newNavbarEl, "previous", false);
    }
  }
  if (options.animate && !(currentIsMaster && app2.width >= router.params.masterDetailBreakpoint)) {
    let transition2 = router.params.transition;
    if ($oldPage[0] && $oldPage[0].f7PageTransition) {
      transition2 = $oldPage[0].f7PageTransition;
      delete $oldPage[0].f7PageTransition;
    }
    if (options.transition) transition2 = options.transition;
    if (!transition2 && router.previousRoute && router.previousRoute.route) {
      transition2 = router.previousRoute.route.transition;
    }
    if (!transition2 && router.previousRoute && router.previousRoute.route && router.previousRoute.route.options) {
      transition2 = router.previousRoute.route.options.transition;
    }
    setPositionClasses();
    router.animate($oldPage, $newPage, $oldNavbarEl, $newNavbarEl, "backward", transition2, () => {
      afterAnimation();
    });
  } else {
    afterAnimation();
  }
  return router;
}
function loadBack(router, backParams, backOptions, ignorePageChange) {
  if (!router.allowPageChange && !ignorePageChange) return router;
  const params = backParams;
  const options = backOptions;
  const {
    url,
    content,
    el,
    pageName,
    component,
    componentUrl
  } = params;
  if (options.route.url && router.url === options.route.url && !(options.reloadCurrent || options.reloadPrevious) && !router.params.allowDuplicateUrls) {
    router.allowPageChange = true;
    return false;
  }
  if (!options.route && url) {
    options.route = router.parseRouteUrl(url);
  }
  function resolve(pageEl, newOptions) {
    return backward(router, pageEl, extend$1(options, newOptions));
  }
  function reject() {
    router.allowPageChange = true;
    return router;
  }
  if (url || componentUrl || component) {
    router.allowPageChange = false;
  }
  if (content) {
    backward(router, router.getPageEl(content), options);
  } else if (el) {
    backward(router, router.getPageEl(el), options);
  } else if (pageName) {
    backward(router, router.$el.children(`.page[data-name="${pageName}"]`).eq(0), options);
  } else if (component || componentUrl) {
    try {
      router.pageComponentLoader({
        routerEl: router.el,
        component,
        componentUrl,
        options,
        resolve,
        reject
      });
    } catch (err) {
      router.allowPageChange = true;
      throw err;
    }
  } else if (url) {
    if (router.xhrAbortController) {
      router.xhrAbortController.abort();
      router.xhrAbortController = false;
    }
    router.xhrRequest(url, options).then((pageContent) => {
      backward(router, router.getPageEl(pageContent), options);
    }).catch(() => {
      router.allowPageChange = true;
    });
  }
  return router;
}
function back() {
  const router = this;
  const device = getDevice();
  if (router.swipeBackActive) return router;
  let navigateUrl;
  let navigateOptions;
  let navigateProps;
  let route;
  if (typeof (arguments.length <= 0 ? void 0 : arguments[0]) === "object") {
    navigateOptions = (arguments.length <= 0 ? void 0 : arguments[0]) || {};
  } else {
    navigateUrl = arguments.length <= 0 ? void 0 : arguments[0];
    navigateOptions = (arguments.length <= 1 ? void 0 : arguments[1]) || {};
  }
  const {
    name,
    params,
    query
  } = navigateOptions;
  if (name) {
    navigateUrl = router.generateUrl({
      name,
      params,
      query
    });
    if (navigateUrl) {
      return router.back(navigateUrl, extend$1({}, navigateOptions, {
        name: null,
        params: null,
        query: null
      }));
    }
    return router;
  }
  const app2 = router.app;
  appRouterCheck(router, "back");
  let currentRouteIsModal = router.currentRoute.modal;
  let modalType;
  if (!currentRouteIsModal) {
    "popup popover sheet loginScreen actions customModal panel".split(" ").forEach((modalLoadProp) => {
      if (router.currentRoute.route[modalLoadProp]) {
        currentRouteIsModal = true;
        modalType = modalLoadProp;
      }
    });
  }
  if (currentRouteIsModal && !navigateOptions.preload) {
    const modalToClose = router.currentRoute.modal || router.currentRoute.route.modalInstance || app2[modalType].get();
    const previousUrl = router.history[router.history.length - 2];
    let previousRoute;
    if (modalToClose && modalToClose.$el) {
      const prevOpenedModals = modalToClose.$el.prevAll(".modal-in");
      if (prevOpenedModals.length && prevOpenedModals[0].f7Modal) {
        const modalEl = prevOpenedModals[0];
        if (!router.$el.parents(modalEl).length) {
          previousRoute = modalEl.f7Modal.route;
        }
      }
    }
    if (!previousRoute) {
      previousRoute = router.findMatchingRoute(previousUrl);
    }
    if (!previousRoute && previousUrl) {
      previousRoute = {
        url: previousUrl,
        path: previousUrl.split("?")[0],
        query: parseUrlQuery(previousUrl),
        route: {
          path: previousUrl.split("?")[0],
          url: previousUrl
        }
      };
    }
    if (!navigateUrl || navigateUrl.replace(/[# ]/g, "").trim().length === 0) {
      if (!previousRoute || !modalToClose) {
        return router;
      }
    }
    const forceOtherUrl = navigateOptions.force && previousRoute && navigateUrl;
    if (previousRoute && modalToClose) {
      const isBrokenBrowserHistory = device.ie || device.edge || device.firefox && !device.ios;
      const needHistoryBack = router.params.browserHistory && navigateOptions.browserHistory !== false;
      const currentRouteWithoutBrowserHistory = router.currentRoute && router.currentRoute.route && router.currentRoute.route.options && router.currentRoute.route.options.browserHistory === false;
      if (needHistoryBack && !isBrokenBrowserHistory && !currentRouteWithoutBrowserHistory) {
        History.back();
      }
      router.currentRoute = previousRoute;
      router.history.pop();
      router.propsHistory.pop();
      router.saveHistory();
      if (needHistoryBack && isBrokenBrowserHistory && !currentRouteWithoutBrowserHistory) {
        History.back();
      }
      router.modalRemove(modalToClose);
      if (forceOtherUrl) {
        router.navigate(navigateUrl, {
          reloadCurrent: true
        });
      }
    } else if (modalToClose) {
      router.modalRemove(modalToClose);
      if (navigateUrl) {
        router.navigate(navigateUrl, {
          reloadCurrent: true
        });
      }
    }
    return router;
  }
  let $previousPage = router.$el.children(".page-current").prevAll(".page-previous:not(.page-master)").eq(0);
  let skipMaster;
  if (router.params.masterDetailBreakpoint > 0) {
    const classes = [];
    router.$el.children(".page").each((pageEl) => {
      classes.push(pageEl.className);
    });
    const $previousMaster = router.$el.children(".page-current").prevAll(".page-master").eq(0);
    if ($previousMaster.length) {
      const expectedPreviousPageUrl = router.history[router.history.length - 2];
      const expectedPreviousPageRoute = router.findMatchingRoute(expectedPreviousPageUrl);
      if (expectedPreviousPageRoute && $previousMaster[0].f7Page && expectedPreviousPageRoute.route === $previousMaster[0].f7Page.route.route) {
        $previousPage = $previousMaster;
        if (!navigateOptions.preload) {
          skipMaster = app2.width >= router.params.masterDetailBreakpoint;
        }
      }
    }
  }
  if (!navigateOptions.force && $previousPage.length && !skipMaster) {
    const previousPageObj = $previousPage[0].f7Page;
    if (router.params.browserHistory && previousPageObj && router.history[router.history.length - 2] !== previousPageObj.route.url) {
      router.back(router.history[router.history.length - 2], extend$1(navigateOptions, {
        force: true,
        props: router.propsHistory[router.propsHistory.length - 2] || {}
      }));
      return router;
    }
    if (previousPageObj) {
      const previousPageRoute = previousPageObj.route;
      processRouteQueue.call(router, previousPageRoute, router.currentRoute, () => {
        loadBack(router, {
          el: $previousPage
        }, extend$1(navigateOptions, {
          route: previousPageRoute
        }));
      }, () => {
      }, "backward");
      return router;
    }
  }
  if (navigateUrl === "#") {
    navigateUrl = void 0;
  }
  if (navigateUrl && navigateUrl[0] !== "/" && navigateUrl.indexOf("#") !== 0) {
    navigateUrl = ((router.path || "/") + navigateUrl).replace("//", "/");
  }
  if (!navigateUrl && router.history.length > 1) {
    navigateUrl = router.history[router.history.length - 2];
    navigateProps = router.propsHistory[router.propsHistory.length - 2] || {};
  }
  if (skipMaster && !navigateOptions.force && router.history[router.history.length - 3]) {
    return router.back(router.history[router.history.length - 3], extend$1({}, navigateOptions || {}, {
      force: true,
      animate: false,
      props: router.propsHistory[router.propsHistory.length - 3] || {}
    }));
  }
  if (skipMaster && !navigateOptions.force) {
    return router;
  }
  route = router.findMatchingRoute(navigateUrl);
  if (!route) {
    if (navigateUrl) {
      route = {
        url: navigateUrl,
        path: navigateUrl.split("?")[0],
        query: parseUrlQuery(navigateUrl),
        route: {
          path: navigateUrl.split("?")[0],
          url: navigateUrl
        }
      };
    }
  }
  if (!route) {
    return router;
  }
  if (route.route.redirect) {
    return redirect.call(router, "backward", route, navigateOptions);
  }
  const options = {};
  if (route.route.options) {
    extend$1(options, route.route.options, navigateOptions, {
      props: navigateProps || {}
    });
  } else {
    extend$1(options, navigateOptions, {
      props: navigateProps || {}
    });
  }
  options.route = route;
  function resolve() {
    let routerLoaded = false;
    if (route.route.keepAlive && route.route.keepAliveData) {
      loadBack(router, {
        el: route.route.keepAliveData.pageEl
      }, options);
      routerLoaded = true;
    }
    "url content component pageName el componentUrl".split(" ").forEach((pageLoadProp) => {
      if (route.route[pageLoadProp] && !routerLoaded) {
        routerLoaded = true;
        loadBack(router, {
          [pageLoadProp]: route.route[pageLoadProp]
        }, options);
      }
    });
    if (routerLoaded) return;
    function asyncResolve(resolveParams, resolveOptions) {
      router.allowPageChange = false;
      loadBack(router, resolveParams, extend$1(options, resolveOptions), true);
    }
    function asyncReject() {
      router.allowPageChange = true;
    }
    if (route.route.async) {
      router.allowPageChange = false;
      route.route.async.call(router, {
        router,
        to: route,
        from: router.currentRoute,
        resolve: asyncResolve,
        reject: asyncReject,
        direction: "backward",
        app: app2
      });
    }
    if (route.route.asyncComponent) {
      asyncComponent(router, route.route.asyncComponent, asyncResolve, asyncReject);
    }
  }
  function reject() {
    router.allowPageChange = true;
  }
  if (options.preload) {
    resolve();
  } else {
    processRouteQueue.call(router, route, router.currentRoute, () => {
      if (route.route.modules) {
        app2.loadModules(Array.isArray(route.route.modules) ? route.route.modules : [route.route.modules]).then(() => {
          resolve();
        }).catch(() => {
          reject();
        });
      } else {
        resolve();
      }
    }, () => {
      reject();
    }, "backward");
  }
  return router;
}
function clearPreviousPages(router) {
  appRouterCheck(router, "clearPreviousPages");
  const app2 = router.app;
  const dynamicNavbar = router.dynamicNavbar;
  const $pagesToRemove = router.$el.children(".page").filter((pageInView) => {
    if (router.currentRoute && (router.currentRoute.modal || router.currentRoute.panel)) return true;
    return pageInView !== router.currentPageEl;
  });
  $pagesToRemove.each((pageEl) => {
    const $oldPageEl = $(pageEl);
    const $oldNavbarEl = $(app2.navbar.getElByPage($oldPageEl));
    router.pageCallback("beforeRemove", $oldPageEl, $oldNavbarEl, "previous", void 0, {});
    router.removePage($oldPageEl);
    if (dynamicNavbar && $oldNavbarEl.length) {
      router.removeNavbar($oldNavbarEl);
    }
  });
}
function clearPreviousHistory() {
  const router = this;
  appRouterCheck(router, "clearPreviousHistory");
  const url = router.history[router.history.length - 1];
  clearPreviousPages(router);
  router.history = [url];
  router.view.history = [url];
  router.saveHistory();
}
class Router extends Framework7Class {
  constructor(app2, view) {
    super({}, [typeof view === "undefined" ? app2 : view]);
    const router = this;
    router.isAppRouter = typeof view === "undefined";
    if (router.isAppRouter) {
      extend$1(false, router, {
        app: app2,
        params: app2.params.view,
        routes: app2.routes || [],
        cache: app2.cache
      });
    } else {
      extend$1(false, router, {
        app: app2,
        view,
        viewId: view.id,
        id: view.params.routerId,
        params: view.params,
        routes: view.routes,
        history: view.history,
        propsHistory: [],
        scrollHistory: view.scrollHistory,
        cache: app2.cache,
        dynamicNavbar: app2.theme === "ios" && view.params.iosDynamicNavbar,
        initialPages: [],
        initialNavbars: []
      });
    }
    router.useModules();
    router.allowPageChange = true;
    let currentRoute = {};
    let previousRoute = {};
    Object.defineProperty(router, "currentRoute", {
      enumerable: true,
      configurable: true,
      set(newRoute) {
        if (newRoute === void 0) {
          newRoute = {};
        }
        previousRoute = extend$1({}, currentRoute);
        currentRoute = newRoute;
        if (!currentRoute) return;
        router.url = currentRoute.url;
        router.emit("routeChange", newRoute, previousRoute, router);
      },
      get() {
        return currentRoute;
      }
    });
    Object.defineProperty(router, "previousRoute", {
      enumerable: true,
      configurable: true,
      get() {
        return previousRoute;
      },
      set(newRoute) {
        previousRoute = newRoute;
      }
    });
    return router;
  }
  mount() {
    const router = this;
    const view = router.view;
    const document2 = getDocument();
    extend$1(false, router, {
      tempDom: document2.createElement("div"),
      $el: view.$el,
      el: view.el,
      $navbarsEl: view.$navbarsEl,
      navbarsEl: view.navbarsEl
    });
    router.emit("local::mount routerMount", router);
  }
  animatableNavElements($newNavbarEl, $oldNavbarEl, toLarge, fromLarge, direction) {
    const router = this;
    const dynamicNavbar = router.dynamicNavbar;
    const animateIcon = router.params.iosAnimateNavbarBackIcon;
    let newNavEls;
    let oldNavEls;
    function animatableNavEl($el, $navbarInner) {
      const isSliding = $el.hasClass("sliding") || $navbarInner.hasClass("sliding");
      const isSubnavbar = $el.hasClass("subnavbar");
      const needsOpacityTransition = isSliding ? !isSubnavbar : true;
      const $iconEl = $el.find(".back .icon");
      let isIconLabel;
      if (isSliding && animateIcon && $el.hasClass("left") && $iconEl.length > 0 && $iconEl.next("span").length) {
        $el = $iconEl.next("span");
        isIconLabel = true;
      }
      return {
        $el,
        isIconLabel,
        leftOffset: $el[0].f7NavbarLeftOffset,
        rightOffset: $el[0].f7NavbarRightOffset,
        isSliding,
        isSubnavbar,
        needsOpacityTransition
      };
    }
    if (dynamicNavbar) {
      newNavEls = [];
      oldNavEls = [];
      $newNavbarEl.children(".navbar-inner").children(".left, .right, .title, .subnavbar").each((navEl) => {
        const $navEl = $(navEl);
        if ($navEl.hasClass("left") && fromLarge && direction === "forward") return;
        if ($navEl.hasClass("title") && toLarge) return;
        newNavEls.push(animatableNavEl($navEl, $newNavbarEl.children(".navbar-inner")));
      });
      if (!($oldNavbarEl.hasClass("navbar-master") && router.params.masterDetailBreakpoint > 0 && router.app.width >= router.params.masterDetailBreakpoint)) {
        $oldNavbarEl.children(".navbar-inner").children(".left, .right, .title, .subnavbar").each((navEl) => {
          const $navEl = $(navEl);
          if ($navEl.hasClass("left") && toLarge && !fromLarge && direction === "forward") return;
          if ($navEl.hasClass("left") && toLarge && direction === "backward") return;
          if ($navEl.hasClass("title") && fromLarge) {
            return;
          }
          oldNavEls.push(animatableNavEl($navEl, $oldNavbarEl.children(".navbar-inner")));
        });
      }
      [oldNavEls, newNavEls].forEach((navEls) => {
        navEls.forEach((navEl) => {
          const n2 = navEl;
          const {
            isSliding,
            $el
          } = navEl;
          const otherEls = navEls === oldNavEls ? newNavEls : oldNavEls;
          if (!(isSliding && $el.hasClass("title") && otherEls)) return;
          otherEls.forEach((otherNavEl) => {
            if (otherNavEl.isIconLabel) {
              const iconTextEl = otherNavEl.$el[0];
              n2.leftOffset += iconTextEl ? iconTextEl.offsetLeft || 0 : 0;
            }
          });
        });
      });
    }
    return {
      newNavEls,
      oldNavEls
    };
  }
  animate($oldPageEl, $newPageEl, $oldNavbarEl, $newNavbarEl, direction, transition2, callback) {
    const router = this;
    if (router.params.animateCustom) {
      router.params.animateCustom.apply(router, [$oldPageEl, $newPageEl, $oldNavbarEl, $newNavbarEl, direction, callback]);
      return;
    }
    const dynamicNavbar = router.dynamicNavbar;
    const ios = router.app.theme === "ios";
    if (transition2) {
      const routerCustomTransitionClass = `router-transition-custom router-transition-${transition2}-${direction}`;
      const onCustomTransitionDone = () => {
        router.$el.removeClass(routerCustomTransitionClass);
        if (dynamicNavbar && router.$navbarsEl.length) {
          if ($newNavbarEl) {
            router.$navbarsEl.prepend($newNavbarEl);
          }
          if ($oldNavbarEl) {
            router.$navbarsEl.prepend($oldNavbarEl);
          }
        }
        if (callback) callback();
      };
      (direction === "forward" ? $newPageEl : $oldPageEl).animationEnd(onCustomTransitionDone);
      if (dynamicNavbar) {
        if ($newNavbarEl && $newPageEl) {
          router.setNavbarPosition($newNavbarEl, "");
          $newNavbarEl.removeClass("navbar-next navbar-previous navbar-current");
          $newPageEl.prepend($newNavbarEl);
        }
        if ($oldNavbarEl && $oldPageEl) {
          router.setNavbarPosition($oldNavbarEl, "");
          $oldNavbarEl.removeClass("navbar-next navbar-previous navbar-current");
          $oldPageEl.prepend($oldNavbarEl);
        }
      }
      router.$el.addClass(routerCustomTransitionClass);
      return;
    }
    const routerTransitionClass = `router-transition-${direction} router-transition`;
    let newNavEls;
    let oldNavEls;
    let fromLarge;
    let toLarge;
    let toDifferent;
    let oldIsLarge;
    let newIsLarge;
    if (ios && dynamicNavbar) {
      const betweenMasterAndDetail = router.params.masterDetailBreakpoint > 0 && router.app.width >= router.params.masterDetailBreakpoint && ($oldNavbarEl.hasClass("navbar-master") && $newNavbarEl.hasClass("navbar-master-detail") || $oldNavbarEl.hasClass("navbar-master-detail") && $newNavbarEl.hasClass("navbar-master"));
      if (!betweenMasterAndDetail) {
        oldIsLarge = $oldNavbarEl && $oldNavbarEl.hasClass("navbar-large");
        newIsLarge = $newNavbarEl && $newNavbarEl.hasClass("navbar-large");
        fromLarge = oldIsLarge && !$oldNavbarEl.hasClass("navbar-large-collapsed");
        toLarge = newIsLarge && !$newNavbarEl.hasClass("navbar-large-collapsed");
        toDifferent = fromLarge && !toLarge || toLarge && !fromLarge;
      }
      const navEls = router.animatableNavElements($newNavbarEl, $oldNavbarEl, toLarge, fromLarge, direction);
      newNavEls = navEls.newNavEls;
      oldNavEls = navEls.oldNavEls;
    }
    function animateNavbars(progress) {
      if (!(ios && dynamicNavbar)) return;
      if (progress === 1) {
        if (toLarge) {
          $newNavbarEl.addClass("router-navbar-transition-to-large");
          $oldNavbarEl.addClass("router-navbar-transition-to-large");
        }
        if (fromLarge) {
          $newNavbarEl.addClass("router-navbar-transition-from-large");
          $oldNavbarEl.addClass("router-navbar-transition-from-large");
        }
      }
      newNavEls.forEach((navEl) => {
        const $el = navEl.$el;
        const offset2 = direction === "forward" ? navEl.rightOffset : navEl.leftOffset;
        if (navEl.isSliding) {
          if (navEl.isSubnavbar && newIsLarge) {
            $el[0].style.setProperty("transform", `translate3d(${offset2 * (1 - progress)}px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0)`, "important");
          } else {
            $el.transform(`translate3d(${offset2 * (1 - progress)}px,0,0)`);
          }
        }
      });
      oldNavEls.forEach((navEl) => {
        const $el = navEl.$el;
        const offset2 = direction === "forward" ? navEl.leftOffset : navEl.rightOffset;
        if (navEl.isSliding) {
          if (navEl.isSubnavbar && oldIsLarge) {
            $el.transform(`translate3d(${offset2 * progress}px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0)`);
          } else {
            $el.transform(`translate3d(${offset2 * progress}px,0,0)`);
          }
        }
      });
    }
    function onDone() {
      if (router.dynamicNavbar) {
        if ($newNavbarEl) {
          $newNavbarEl.removeClass("router-navbar-transition-to-large router-navbar-transition-from-large");
          $newNavbarEl.addClass("navbar-no-title-large-transition");
          nextFrame$1(() => {
            $newNavbarEl.removeClass("navbar-no-title-large-transition");
          });
        }
        if ($oldNavbarEl) {
          $oldNavbarEl.removeClass("router-navbar-transition-to-large router-navbar-transition-from-large");
        }
        if ($newNavbarEl.hasClass("sliding") || $newNavbarEl.children(".navbar-inner.sliding").length) {
          $newNavbarEl.find(".title, .left, .right, .left .icon, .subnavbar").transform("");
        } else {
          $newNavbarEl.find(".sliding").transform("");
        }
        if ($oldNavbarEl.hasClass("sliding") || $oldNavbarEl.children(".navbar-inner.sliding").length) {
          $oldNavbarEl.find(".title, .left, .right, .left .icon, .subnavbar").transform("");
        } else {
          $oldNavbarEl.find(".sliding").transform("");
        }
      }
      router.$el.removeClass(routerTransitionClass);
      if (callback) callback();
    }
    (direction === "forward" ? $newPageEl : ios ? $oldPageEl : $newPageEl).animationEnd(() => {
      onDone();
    });
    if (dynamicNavbar) {
      animateNavbars(0);
      nextFrame$1(() => {
        router.$el.addClass(routerTransitionClass);
        if (toDifferent) {
          router.el._clientLeft = router.el.clientLeft;
        }
        animateNavbars(1);
      });
    } else {
      router.$el.addClass(routerTransitionClass);
    }
  }
  removeModal(modalEl) {
    const router = this;
    router.removeEl(modalEl);
  }
  // eslint-disable-next-line
  removeTabContent(tabEl) {
    const $tabEl = $(tabEl);
    $tabEl.html("");
  }
  removeNavbar(el) {
    const router = this;
    router.removeEl(el);
  }
  removePage(el) {
    const $el = $(el);
    const f7Page = $el && $el[0] && $el[0].f7Page;
    const router = this;
    if (f7Page && f7Page.route && f7Page.route.route && f7Page.route.route.keepAlive) {
      $el.remove();
      return;
    }
    router.removeEl(el);
  }
  removeEl(el) {
    if (!el) return;
    const router = this;
    const $el = $(el);
    if ($el.length === 0) return;
    $el.find(".tab").each((tabEl) => {
      $(tabEl).children().each((tabChild) => {
        if (tabChild.f7Component) {
          $(tabChild).trigger("tab:beforeremove");
          tabChild.f7Component.destroy();
        }
      });
    });
    if ($el[0].f7Component && $el[0].f7Component.destroy) {
      $el[0].f7Component.destroy();
    }
    if (!router.params.removeElements) {
      return;
    }
    if (router.params.removeElementsWithTimeout) {
      setTimeout(() => {
        $el.remove();
      }, router.params.removeElementsTimeout);
    } else {
      $el.remove();
    }
  }
  getPageEl(content) {
    const router = this;
    if (typeof content === "string") {
      router.tempDom.innerHTML = content;
    } else {
      if ($(content).hasClass("page")) {
        return content;
      }
      router.tempDom.innerHTML = "";
      $(router.tempDom).append(content);
    }
    return router.findElement(".page", router.tempDom);
  }
  findElement(stringSelector, container) {
    const router = this;
    const view = router.view;
    const app2 = router.app;
    const modalsSelector = ".popup, .dialog, .popover, .actions-modal, .sheet-modal, .login-screen, .page";
    const $container = $(container);
    const selector = stringSelector;
    let found = $container.find(selector).filter((el) => $(el).parents(modalsSelector).length === 0);
    if (found.length > 1) {
      if (typeof view.selector === "string") {
        found = $container.find(`${view.selector} ${selector}`);
      }
      if (found.length > 1) {
        found = $container.find(`.${app2.params.viewMainClass} ${selector}`);
      }
    }
    if (found.length === 1) return found;
    found = router.findElement(selector, $container);
    if (found && found.length === 1) return found;
    if (found && found.length > 1) return $(found[0]);
    return void 0;
  }
  flattenRoutes(routes2) {
    if (routes2 === void 0) {
      routes2 = this.routes;
    }
    const router = this;
    let flattenedRoutes = [];
    routes2.forEach((route) => {
      let hasTabRoutes = false;
      if ("tabs" in route && route.tabs) {
        const mergedPathsRoutes = route.tabs.map((tabRoute) => {
          const tRoute = extend$1({}, route, {
            path: `${route.path}/${tabRoute.path}`.replace("///", "/").replace("//", "/"),
            parentPath: route.path,
            tab: tabRoute
          });
          delete tRoute.tabs;
          delete tRoute.routes;
          return tRoute;
        });
        hasTabRoutes = true;
        flattenedRoutes = flattenedRoutes.concat(router.flattenRoutes(mergedPathsRoutes));
      }
      if ("detailRoutes" in route) {
        const mergedPathsRoutes = route.detailRoutes.map((detailRoute) => {
          const dRoute = extend$1({}, detailRoute);
          dRoute.masterRoute = route;
          dRoute.masterRoutePath = route.path;
          return dRoute;
        });
        flattenedRoutes = flattenedRoutes.concat(route, router.flattenRoutes(mergedPathsRoutes));
      }
      if ("routes" in route) {
        const mergedPathsRoutes = route.routes.map((childRoute) => {
          const cRoute = extend$1({}, childRoute);
          cRoute.path = `${route.path}/${cRoute.path}`.replace("///", "/").replace("//", "/");
          return cRoute;
        });
        if (hasTabRoutes) {
          flattenedRoutes = flattenedRoutes.concat(router.flattenRoutes(mergedPathsRoutes));
        } else {
          flattenedRoutes = flattenedRoutes.concat(route, router.flattenRoutes(mergedPathsRoutes));
        }
      }
      if (!("routes" in route) && !("tabs" in route && route.tabs) && !("detailRoutes" in route)) {
        flattenedRoutes.push(route);
      }
    });
    return flattenedRoutes;
  }
  // eslint-disable-next-line
  parseRouteUrl(url) {
    if (!url) return {};
    const query = parseUrlQuery(url);
    const hash = url.split("#")[1];
    const params = {};
    const path2 = url.split("#")[0].split("?")[0];
    return {
      query,
      hash,
      params,
      url,
      path: path2
    };
  }
  generateUrl(parameters) {
    if (parameters === void 0) {
      parameters = {};
    }
    if (typeof parameters === "string") {
      return parameters;
    }
    const {
      name,
      path: path2,
      params,
      query
    } = parameters;
    if (!name && !path2) {
      throw new Error('Framework7: "name" or "path" parameter is required');
    }
    const router = this;
    const route = name ? router.findRouteByKey("name", name) : router.findRouteByKey("path", path2);
    if (!route) {
      if (name) {
        throw new Error(`Framework7: route with name "${name}" not found`);
      } else {
        throw new Error(`Framework7: route with path "${path2}" not found`);
      }
    }
    const url = router.constructRouteUrl(route, {
      params,
      query
    });
    if (url === "") {
      return "/";
    }
    if (!url) {
      throw new Error(`Framework7: can't construct URL for route with name "${name}"`);
    }
    return url;
  }
  // eslint-disable-next-line
  constructRouteUrl(route, _temp) {
    let {
      params,
      query
    } = _temp === void 0 ? {} : _temp;
    const {
      path: path2
    } = route;
    const toUrl = compile(path2);
    let url;
    try {
      url = toUrl(params || {});
    } catch (error) {
      throw new Error(`Framework7: error constructing route URL from passed params:
Route: ${path2}
${error.toString()}`);
    }
    if (query) {
      if (typeof query === "string") url += `?${query}`;
      else if (Object.keys(query).length) url += `?${serializeObject(query)}`;
    }
    return url;
  }
  findTabRouteUrl(tabEl) {
    const router = this;
    const $tabEl = $(tabEl);
    const parentPath = router.currentRoute.route.parentPath;
    const tabId = $tabEl.attr("id");
    const flattenedRoutes = router.flattenRoutes(router.routes);
    let foundTabRouteUrl;
    flattenedRoutes.forEach((route) => {
      if (route.parentPath === parentPath && route.tab && route.tab.id === tabId) {
        if (router.currentRoute.params && Object.keys(router.currentRoute.params).length > 0) {
          foundTabRouteUrl = router.constructRouteUrl(route, {
            params: router.currentRoute.params,
            query: router.currentRoute.query
          });
        } else {
          foundTabRouteUrl = route.path;
        }
      }
    });
    return foundTabRouteUrl;
  }
  findRouteByKey(key, value2) {
    const router = this;
    const routes2 = router.routes;
    const flattenedRoutes = router.flattenRoutes(routes2);
    let matchingRoute;
    flattenedRoutes.forEach((route) => {
      if (matchingRoute) return;
      if (route[key] === value2) {
        matchingRoute = route;
      }
    });
    return matchingRoute;
  }
  findMatchingRoute(url) {
    if (!url) return void 0;
    const router = this;
    const routes2 = router.routes;
    const flattenedRoutes = router.flattenRoutes(routes2);
    const {
      path: path2,
      query,
      hash,
      params
    } = router.parseRouteUrl(url);
    let matchingRoute;
    flattenedRoutes.forEach((route) => {
      if (matchingRoute) return;
      const keys = [];
      const pathsToMatch = [route.path || "/"];
      if (route.alias) {
        if (typeof route.alias === "string") pathsToMatch.push(route.alias);
        else if (Array.isArray(route.alias)) {
          route.alias.forEach((aliasPath) => {
            pathsToMatch.push(aliasPath);
          });
        }
      }
      let matched;
      pathsToMatch.forEach((pathToMatch) => {
        if (matched) return;
        matched = pathToRegexp(pathToMatch, keys).exec(path2 || "/");
      });
      if (matched) {
        keys.forEach((keyObj, index2) => {
          if (typeof keyObj.name === "number") return;
          const paramValue = matched[index2 + 1];
          if (typeof paramValue === "undefined" || paramValue === null) {
            params[keyObj.name] = paramValue;
          } else {
            params[keyObj.name] = decodeURIComponent(paramValue);
          }
        });
        let parentPath;
        if (route.parentPath) {
          parentPath = (path2 || "/").split("/").slice(0, route.parentPath.split("/").length - 1).join("/");
        }
        matchingRoute = {
          query,
          hash,
          params,
          url,
          path: path2 || "/",
          parentPath,
          route,
          name: route.name
        };
      }
    });
    return matchingRoute;
  }
  // eslint-disable-next-line
  replaceRequestUrlParams(url, options) {
    if (url === void 0) {
      url = "";
    }
    if (options === void 0) {
      options = {};
    }
    let compiledUrl = url;
    if (typeof compiledUrl === "string" && compiledUrl.indexOf("{{") >= 0 && options && options.route && options.route.params && Object.keys(options.route.params).length) {
      Object.keys(options.route.params).forEach((paramName) => {
        const regExp = new RegExp(`{{${paramName}}}`, "g");
        compiledUrl = compiledUrl.replace(regExp, options.route.params[paramName] || "");
      });
    }
    return compiledUrl;
  }
  removeFromXhrCache(url) {
    const router = this;
    const xhrCache = router.cache.xhr;
    let index2 = false;
    for (let i = 0; i < xhrCache.length; i += 1) {
      if (xhrCache[i].url === url) index2 = i;
    }
    if (index2 !== false) xhrCache.splice(index2, 1);
  }
  xhrRequest(requestUrl, options) {
    const router = this;
    const params = router.params;
    const {
      ignoreCache
    } = options;
    let url = requestUrl;
    let hasQuery = url.indexOf("?") >= 0;
    if (params.passRouteQueryToRequest && options && options.route && options.route.query && Object.keys(options.route.query).length) {
      url += `${hasQuery ? "&" : "?"}${serializeObject(options.route.query)}`;
      hasQuery = true;
    }
    if (params.passRouteParamsToRequest && options && options.route && options.route.params && Object.keys(options.route.params).length) {
      url += `${hasQuery ? "&" : "?"}${serializeObject(options.route.params)}`;
      hasQuery = true;
    }
    if (url.indexOf("{{") >= 0) {
      url = router.replaceRequestUrlParams(url, options);
    }
    if (params.xhrCacheIgnoreGetParameters && url.indexOf("?") >= 0) {
      url = url.split("?")[0];
    }
    return new Promise((resolve, reject) => {
      if (params.xhrCache && !ignoreCache && url.indexOf("nocache") < 0 && params.xhrCacheIgnore.indexOf(url) < 0) {
        for (let i = 0; i < router.cache.xhr.length; i += 1) {
          const cachedUrl = router.cache.xhr[i];
          if (cachedUrl.url === url) {
            if (now$1() - cachedUrl.time < params.xhrCacheDuration) {
              resolve(cachedUrl.content);
              return;
            }
          }
        }
      }
      router.xhrAbortController = new AbortController();
      let fetchRes;
      fetch(url, {
        signal: router.xhrAbortController.signal,
        method: "GET"
      }).then((res) => {
        fetchRes = res;
        return res.text();
      }).then((responseText) => {
        const {
          status
        } = fetchRes;
        router.emit("routerAjaxComplete", fetchRes);
        if (status !== "error" && status !== "timeout" && status >= 200 && status < 300 || status === 0) {
          if (params.xhrCache && responseText !== "") {
            router.removeFromXhrCache(url);
            router.cache.xhr.push({
              url,
              time: now$1(),
              content: responseText
            });
          }
          router.emit("routerAjaxSuccess", fetchRes, options);
          resolve(responseText);
        } else {
          router.emit("routerAjaxError", fetchRes, options);
          reject(fetchRes);
        }
      }).catch((err) => {
        reject(err);
      });
    });
  }
  setNavbarPosition($el, position, ariaHidden) {
    const router = this;
    $el.removeClass("navbar-previous navbar-current navbar-next");
    if (position) {
      $el.addClass(`navbar-${position}`);
    }
    if (ariaHidden === false) {
      $el.removeAttr("aria-hidden");
    } else if (ariaHidden === true) {
      $el.attr("aria-hidden", "true");
    }
    $el.trigger("navbar:position", {
      position
    });
    router.emit("navbarPosition", $el[0], position);
  }
  setPagePosition($el, position, ariaHidden) {
    const router = this;
    $el.removeClass("page-previous page-current page-next");
    $el.addClass(`page-${position}`);
    if (ariaHidden === false) {
      $el.removeAttr("aria-hidden");
    } else if (ariaHidden === true) {
      $el.attr("aria-hidden", "true");
    }
    $el.trigger("page:position", {
      position
    });
    router.emit("pagePosition", $el[0], position);
  }
  // Remove theme elements
  removeThemeElements(el) {
    const router = this;
    const theme = router.app.theme;
    let toRemove;
    if (theme === "ios") {
      toRemove = ".md-only, .if-md, .if-not-ios, .not-ios";
    } else if (theme === "md") {
      toRemove = ".ios-only, .if-ios, .if-not-md, .not-md";
    }
    $(el).find(toRemove).remove();
  }
  getPageData(pageEl, navbarEl, from, to, route, pageFromEl) {
    if (route === void 0) {
      route = {};
    }
    const router = this;
    const $pageEl = $(pageEl).eq(0);
    const $navbarEl = $(navbarEl).eq(0);
    const currentPage = $pageEl[0].f7Page || {};
    let direction;
    let pageFrom;
    if (from === "next" && to === "current" || from === "current" && to === "previous") direction = "forward";
    if (from === "current" && to === "next" || from === "previous" && to === "current") direction = "backward";
    if (currentPage && !currentPage.fromPage) {
      const $pageFromEl = $(pageFromEl);
      if ($pageFromEl.length) {
        pageFrom = $pageFromEl[0].f7Page;
      }
    }
    pageFrom = currentPage.pageFrom || pageFrom;
    if (pageFrom && pageFrom.pageFrom) {
      pageFrom.pageFrom = null;
    }
    const page = {
      app: router.app,
      view: router.view,
      router,
      $el: $pageEl,
      el: $pageEl[0],
      $pageEl,
      pageEl: $pageEl[0],
      $navbarEl,
      navbarEl: $navbarEl[0],
      name: $pageEl.attr("data-name"),
      position: from,
      from,
      to,
      direction,
      route: currentPage.route ? currentPage.route : route,
      pageFrom
    };
    $pageEl[0].f7Page = page;
    return page;
  }
  // Callbacks
  pageCallback(callback, pageEl, navbarEl, from, to, options, pageFromEl) {
    if (options === void 0) {
      options = {};
    }
    if (!pageEl) return;
    const router = this;
    const $pageEl = $(pageEl);
    if (!$pageEl.length) return;
    const $navbarEl = $(navbarEl);
    const {
      route
    } = options;
    const restoreScrollTopOnBack = router.params.restoreScrollTopOnBack && !(router.params.masterDetailBreakpoint > 0 && $pageEl.hasClass("page-master") && router.app.width >= router.params.masterDetailBreakpoint);
    const keepAlive = $pageEl[0].f7Page && $pageEl[0].f7Page.route && $pageEl[0].f7Page.route.route && $pageEl[0].f7Page.route.route.keepAlive;
    if (callback === "beforeRemove" && keepAlive) {
      callback = "beforeUnmount";
    }
    const camelName = `page${callback[0].toUpperCase() + callback.slice(1, callback.length)}`;
    const colonName = `page:${callback.toLowerCase()}`;
    let page = {};
    if (callback === "beforeRemove" && $pageEl[0].f7Page) {
      page = extend$1($pageEl[0].f7Page, {
        from,
        to,
        position: from
      });
    } else {
      page = router.getPageData($pageEl[0], $navbarEl[0], from, to, route, pageFromEl);
    }
    page.swipeBack = !!options.swipeBack;
    const {
      on: on2 = {},
      once: once2 = {}
    } = options.route ? options.route.route : {};
    if (options.on) {
      extend$1(on2, options.on);
    }
    if (options.once) {
      extend$1(once2, options.once);
    }
    function attachEvents() {
      if ($pageEl[0].f7RouteEventsAttached) return;
      $pageEl[0].f7RouteEventsAttached = true;
      if (on2 && Object.keys(on2).length > 0) {
        $pageEl[0].f7RouteEventsOn = on2;
        Object.keys(on2).forEach((eventName) => {
          on2[eventName] = on2[eventName].bind(router);
          $pageEl.on(eventNameToColonCase(eventName), on2[eventName]);
        });
      }
      if (once2 && Object.keys(once2).length > 0) {
        $pageEl[0].f7RouteEventsOnce = once2;
        Object.keys(once2).forEach((eventName) => {
          once2[eventName] = once2[eventName].bind(router);
          $pageEl.once(eventNameToColonCase(eventName), once2[eventName]);
        });
      }
    }
    function detachEvents() {
      if (!$pageEl[0].f7RouteEventsAttached) return;
      if ($pageEl[0].f7RouteEventsOn) {
        Object.keys($pageEl[0].f7RouteEventsOn).forEach((eventName) => {
          $pageEl.off(eventNameToColonCase(eventName), $pageEl[0].f7RouteEventsOn[eventName]);
        });
      }
      if ($pageEl[0].f7RouteEventsOnce) {
        Object.keys($pageEl[0].f7RouteEventsOnce).forEach((eventName) => {
          $pageEl.off(eventNameToColonCase(eventName), $pageEl[0].f7RouteEventsOnce[eventName]);
        });
      }
      $pageEl[0].f7RouteEventsAttached = null;
      $pageEl[0].f7RouteEventsOn = null;
      $pageEl[0].f7RouteEventsOnce = null;
      delete $pageEl[0].f7RouteEventsAttached;
      delete $pageEl[0].f7RouteEventsOn;
      delete $pageEl[0].f7RouteEventsOnce;
    }
    if (callback === "mounted") {
      attachEvents();
    }
    if (callback === "init") {
      if (restoreScrollTopOnBack && (from === "previous" || !from) && to === "current" && router.scrollHistory[page.route.url] && !$pageEl.hasClass("no-restore-scroll")) {
        let $pageContent = $pageEl.find(".page-content");
        if ($pageContent.length > 0) {
          $pageContent = $pageContent.filter((pageContentEl) => {
            return $(pageContentEl).parents(".tab:not(.tab-active)").length === 0 && !$(pageContentEl).is(".tab:not(.tab-active)");
          });
        }
        $pageContent.scrollTop(router.scrollHistory[page.route.url]);
      }
      attachEvents();
      if ($pageEl[0].f7PageInitialized) {
        $pageEl.trigger("page:reinit", page);
        router.emit("pageReinit", page);
        return;
      }
      $pageEl[0].f7PageInitialized = true;
    }
    if (restoreScrollTopOnBack && callback === "beforeOut" && from === "current" && to === "previous") {
      let $pageContent = $pageEl.find(".page-content");
      if ($pageContent.length > 0) {
        $pageContent = $pageContent.filter((pageContentEl) => {
          return $(pageContentEl).parents(".tab:not(.tab-active)").length === 0 && !$(pageContentEl).is(".tab:not(.tab-active)");
        });
      }
      router.scrollHistory[page.route.url] = $pageContent.scrollTop();
    }
    if (restoreScrollTopOnBack && callback === "beforeOut" && from === "current" && to === "next") {
      delete router.scrollHistory[page.route.url];
    }
    $pageEl.trigger(colonName, page);
    router.emit(camelName, page);
    if (callback === "beforeRemove" || callback === "beforeUnmount") {
      detachEvents();
      if (!keepAlive) {
        if ($pageEl[0].f7Page && $pageEl[0].f7Page.navbarEl) {
          delete $pageEl[0].f7Page.navbarEl.f7Page;
        }
        $pageEl[0].f7Page = null;
      }
    }
  }
  saveHistory() {
    const router = this;
    const window2 = getWindow();
    router.view.history = router.history;
    if (router.params.browserHistory && router.params.browserHistoryStoreHistory && window2.localStorage) {
      window2.localStorage[`f7router-${router.view.id}-history`] = JSON.stringify(router.history);
    }
  }
  restoreHistory() {
    const router = this;
    const window2 = getWindow();
    if (router.params.browserHistory && router.params.browserHistoryStoreHistory && window2.localStorage && window2.localStorage[`f7router-${router.view.id}-history`]) {
      router.history = JSON.parse(window2.localStorage[`f7router-${router.view.id}-history`]);
      router.view.history = router.history;
    }
  }
  clearHistory() {
    const router = this;
    router.history = [];
    if (router.view) router.view.history = [];
    router.saveHistory();
  }
  updateCurrentUrl(newUrl) {
    const router = this;
    appRouterCheck(router, "updateCurrentUrl");
    if (router.history.length) {
      router.history[router.history.length - 1] = newUrl;
    } else {
      router.history.push(newUrl);
    }
    const {
      query,
      hash,
      params,
      url,
      path: path2
    } = router.parseRouteUrl(newUrl);
    if (router.currentRoute) {
      extend$1(router.currentRoute, {
        query,
        hash,
        params,
        url,
        path: path2
      });
    }
    if (router.params.browserHistory) {
      const browserHistoryRoot = router.params.browserHistoryRoot || "";
      History.replace(router.view.id, {
        url: newUrl
      }, browserHistoryRoot + router.params.browserHistorySeparator + newUrl);
    }
    router.saveHistory();
    router.emit("routeUrlUpdate", router.currentRoute, router);
  }
  getInitialUrl() {
    const router = this;
    if (router.initialUrl) {
      return {
        initialUrl: router.initialUrl,
        historyRestored: router.historyRestored
      };
    }
    const {
      app: app2,
      view
    } = router;
    const document2 = getDocument();
    const window2 = getWindow();
    const location = app2.params.url && typeof app2.params.url === "string" && typeof URL !== "undefined" ? new URL(app2.params.url) : document2.location;
    let initialUrl = router.params.url;
    let documentUrl = location.href.split(location.origin)[1];
    let historyRestored;
    const {
      browserHistory,
      browserHistoryOnLoad,
      browserHistorySeparator
    } = router.params;
    let {
      browserHistoryRoot
    } = router.params;
    if ((window2.cordova || window2.Capacitor && window2.Capacitor.isNative) && browserHistory && !browserHistorySeparator && !browserHistoryRoot && location.pathname.indexOf("index.html")) {
      console.warn("Framework7: wrong or not complete browserHistory configuration, trying to guess browserHistoryRoot");
      browserHistoryRoot = location.pathname.split("index.html")[0];
    }
    if (!browserHistory || !browserHistoryOnLoad) {
      if (!initialUrl) {
        initialUrl = documentUrl;
      }
      if (location.search && initialUrl.indexOf("?") < 0) {
        initialUrl += location.search;
      }
      if (location.hash && initialUrl.indexOf("#") < 0) {
        initialUrl += location.hash;
      }
    } else {
      if (browserHistoryRoot && documentUrl.indexOf(browserHistoryRoot) >= 0) {
        documentUrl = documentUrl.substring(documentUrl.indexOf(browserHistoryRoot) + browserHistoryRoot.length);
        if (documentUrl === "") documentUrl = "/";
      }
      if (browserHistorySeparator.length > 0 && documentUrl.indexOf(browserHistorySeparator) >= 0) {
        initialUrl = documentUrl.substring(documentUrl.indexOf(browserHistorySeparator) + browserHistorySeparator.length);
      } else {
        initialUrl = documentUrl;
      }
      router.restoreHistory();
      if (router.history.indexOf(initialUrl) >= 0) {
        router.history = router.history.slice(0, router.history.indexOf(initialUrl) + 1);
      } else if (router.params.url === initialUrl) {
        router.history = [initialUrl];
      } else if (History.state && History.state[view.id] && History.state[view.id].url === router.history[router.history.length - 1]) {
        initialUrl = router.history[router.history.length - 1];
      } else {
        router.history = [documentUrl.split(browserHistorySeparator)[0] || "/", initialUrl];
      }
      if (router.history.length > 1) {
        historyRestored = true;
      } else {
        router.history = [];
      }
      router.saveHistory();
    }
    router.initialUrl = initialUrl;
    router.historyRestored = historyRestored;
    return {
      initialUrl,
      historyRestored
    };
  }
  init() {
    const router = this;
    const {
      app: app2,
      view
    } = router;
    const document2 = getDocument();
    router.mount();
    const {
      initialUrl,
      historyRestored
    } = router.getInitialUrl();
    if (view && router.params.iosSwipeBack && app2.theme === "ios" || view && router.params.mdSwipeBack && app2.theme === "md") {
      SwipeBack(router);
    }
    const {
      browserHistory,
      browserHistoryOnLoad,
      browserHistoryAnimateOnLoad,
      browserHistoryInitialMatch
    } = router.params;
    let currentRoute;
    if (router.history.length > 1) {
      const initUrl = browserHistoryInitialMatch ? initialUrl : router.history[0];
      currentRoute = router.findMatchingRoute(initUrl);
      if (!currentRoute) {
        currentRoute = extend$1(router.parseRouteUrl(initUrl), {
          route: {
            url: initUrl,
            path: initUrl.split("?")[0]
          }
        });
      }
    } else {
      currentRoute = router.findMatchingRoute(initialUrl);
      if (!currentRoute) {
        currentRoute = extend$1(router.parseRouteUrl(initialUrl), {
          route: {
            url: initialUrl,
            path: initialUrl.split("?")[0]
          }
        });
      }
    }
    if (router.$el.children(".page").length === 0 && initialUrl && router.params.loadInitialPage) {
      router.navigate(initialUrl, {
        initial: true,
        reloadCurrent: true,
        browserHistory: false,
        animate: false,
        once: {
          modalOpen() {
            if (!historyRestored) return;
            const preloadPreviousPage = router.params.preloadPreviousPage || router.params[`${app2.theme}SwipeBack`];
            if (preloadPreviousPage && router.history.length > 1) {
              router.back({
                preload: true
              });
            }
          },
          pageAfterIn() {
            if (!historyRestored) return;
            const preloadPreviousPage = router.params.preloadPreviousPage || router.params[`${app2.theme}SwipeBack`];
            if (preloadPreviousPage && router.history.length > 1) {
              router.back({
                preload: true
              });
            }
          }
        }
      });
    } else if (router.$el.children(".page").length) {
      let hasTabRoute;
      router.currentRoute = currentRoute;
      router.$el.children(".page").each((pageEl) => {
        const $pageEl = $(pageEl);
        let $navbarEl;
        router.setPagePosition($pageEl, "current");
        if (router.dynamicNavbar) {
          $navbarEl = $pageEl.children(".navbar");
          if ($navbarEl.length > 0) {
            if (!router.$navbarsEl.parents(document2).length) {
              router.$el.prepend(router.$navbarsEl);
            }
            router.setNavbarPosition($navbarEl, "current");
            router.$navbarsEl.append($navbarEl);
            if ($navbarEl.children(".title-large").length) {
              $navbarEl.addClass("navbar-large");
            }
            $pageEl.children(".navbar").remove();
          } else {
            router.$navbarsEl.addClass("navbar-hidden");
            if ($navbarEl.children(".title-large").length) {
              router.$navbarsEl.addClass("navbar-hidden navbar-large-hidden");
            }
          }
        }
        if (router.currentRoute && router.currentRoute.route && (router.currentRoute.route.master === true || typeof router.currentRoute.route.master === "function" && router.currentRoute.route.master(app2, router)) && router.params.masterDetailBreakpoint > 0) {
          $pageEl.addClass("page-master");
          $pageEl.trigger("page:role", {
            role: "master"
          });
          if ($navbarEl && $navbarEl.length) {
            $navbarEl.addClass("navbar-master");
          }
          view.checkMasterDetailBreakpoint();
        }
        const initOptions = {
          route: router.currentRoute
        };
        if (router.currentRoute && router.currentRoute.route && router.currentRoute.route.options) {
          extend$1(initOptions, router.currentRoute.route.options);
        }
        router.currentPageEl = $pageEl[0];
        if (router.dynamicNavbar && $navbarEl.length) {
          router.currentNavbarEl = $navbarEl[0];
        }
        router.removeThemeElements($pageEl);
        if (router.dynamicNavbar && $navbarEl.length) {
          router.removeThemeElements($navbarEl);
        }
        if (initOptions.route.route.tab) {
          hasTabRoute = true;
          router.tabLoad(initOptions.route.route.tab, extend$1({}, initOptions));
        }
        router.pageCallback("init", $pageEl, $navbarEl, "current", void 0, initOptions);
        router.pageCallback("beforeIn", $pageEl, $navbarEl, "current", void 0, initOptions);
        router.pageCallback("afterIn", $pageEl, $navbarEl, "current", void 0, initOptions);
      });
      if (historyRestored) {
        if (browserHistoryInitialMatch) {
          const preloadPreviousPage = router.params.preloadPreviousPage || router.params[`${app2.theme}SwipeBack`];
          if (preloadPreviousPage && router.history.length > 1) {
            router.back({
              preload: true
            });
          }
        } else {
          router.navigate(initialUrl, {
            initial: true,
            browserHistory: false,
            history: false,
            animate: browserHistoryAnimateOnLoad,
            once: {
              pageAfterIn() {
                const preloadPreviousPage = router.params.preloadPreviousPage || router.params[`${app2.theme}SwipeBack`];
                if (preloadPreviousPage && router.history.length > 2) {
                  router.back({
                    preload: true
                  });
                }
              }
            }
          });
        }
      }
      if (!historyRestored && !hasTabRoute) {
        router.history.push(initialUrl);
        router.saveHistory();
      }
    }
    if (initialUrl && browserHistory && browserHistoryOnLoad && (!History.state || !History.state[view.id])) {
      History.initViewState(view.id, {
        url: initialUrl
      });
    }
    router.emit("local::init routerInit", router);
  }
  destroy() {
    let router = this;
    router.emit("local::destroy routerDestroy", router);
    Object.keys(router).forEach((routerProp) => {
      router[routerProp] = null;
      delete router[routerProp];
    });
    router = null;
  }
}
Router.prototype.navigate = navigate;
Router.prototype.refreshPage = refreshPage;
Router.prototype.tabLoad = tabLoad;
Router.prototype.tabRemove = tabRemove;
Router.prototype.modalLoad = modalLoad;
Router.prototype.modalRemove = modalRemove;
Router.prototype.back = back;
Router.prototype.clearPreviousHistory = clearPreviousHistory;
const RouterModule = {
  name: "router",
  static: {
    Router
  },
  instance: {
    cache: {
      xhr: [],
      templates: [],
      components: []
    }
  },
  create() {
    const instance2 = this;
    if (instance2.app) {
      if (instance2.params.router) {
        instance2.router = new Router(instance2.app, instance2);
      }
    } else {
      instance2.router = new Router(instance2);
    }
  }
};
function resizableView(view) {
  const app2 = view.app;
  const support2 = getSupport();
  if (view.resizableInitialized) return;
  extend$1(view, {
    resizable: true,
    resizableWidth: null,
    resizableInitialized: true
  });
  const $htmlEl = $("html");
  const {
    $el
  } = view;
  if (!$el) return;
  let $resizeHandlerEl;
  let isTouched;
  let isMoved;
  const touchesStart = {};
  let touchesDiff;
  let width2;
  let minWidth;
  let maxWidth;
  function transformCSSWidth(v) {
    if (!v) return null;
    if (v.indexOf("%") >= 0 || v.indexOf("vw") >= 0) {
      return parseInt(v, 10) / 100 * app2.width;
    }
    const newV = parseInt(v, 10);
    if (Number.isNaN(newV)) return null;
    return newV;
  }
  function isResizable() {
    return view.resizable && $el.hasClass("view-resizable") && $el.hasClass("view-master-detail");
  }
  function handleTouchStart(e) {
    if (!isResizable()) return;
    touchesStart.x = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
    touchesStart.y = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
    isMoved = false;
    isTouched = true;
    const $pageMasterEl = $el.children(".page-master");
    minWidth = transformCSSWidth($pageMasterEl.css("min-width"));
    maxWidth = transformCSSWidth($pageMasterEl.css("max-width"));
  }
  function handleTouchMove(e) {
    if (!isTouched) return;
    e.f7PreventSwipePanel = true;
    const pageX = e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
    if (!isMoved) {
      width2 = $resizeHandlerEl[0].offsetLeft + $resizeHandlerEl[0].offsetWidth;
      $el.addClass("view-resizing");
      $htmlEl.css("cursor", "col-resize");
    }
    isMoved = true;
    e.preventDefault();
    touchesDiff = pageX - touchesStart.x;
    let newWidth = width2 + touchesDiff;
    if (minWidth && !Number.isNaN(minWidth)) {
      newWidth = Math.max(newWidth, minWidth);
    }
    if (maxWidth && !Number.isNaN(maxWidth)) {
      newWidth = Math.min(newWidth, maxWidth);
    }
    newWidth = Math.min(Math.max(newWidth, 0), app2.width);
    view.resizableWidth = newWidth;
    $htmlEl[0].style.setProperty("--f7-page-master-width", `${newWidth}px`);
    $el.trigger("view:resize", newWidth);
    view.emit("local::resize viewResize", view, newWidth);
  }
  function handleTouchEnd() {
    $("html").css("cursor", "");
    if (!isTouched || !isMoved) {
      isTouched = false;
      isMoved = false;
      return;
    }
    isTouched = false;
    isMoved = false;
    $htmlEl[0].style.setProperty("--f7-page-master-width", `${view.resizableWidth}px`);
    $el.removeClass("view-resizing");
  }
  function handleResize() {
    if (!view.resizableWidth) return;
    minWidth = transformCSSWidth($resizeHandlerEl.css("min-width"));
    maxWidth = transformCSSWidth($resizeHandlerEl.css("max-width"));
    if (minWidth && !Number.isNaN(minWidth) && view.resizableWidth < minWidth) {
      view.resizableWidth = Math.max(view.resizableWidth, minWidth);
    }
    if (maxWidth && !Number.isNaN(maxWidth) && view.resizableWidth > maxWidth) {
      view.resizableWidth = Math.min(view.resizableWidth, maxWidth);
    }
    view.resizableWidth = Math.min(Math.max(view.resizableWidth, 0), app2.width);
    $htmlEl[0].style.setProperty("--f7-page-master-width", `${view.resizableWidth}px`);
  }
  $resizeHandlerEl = view.$el.children(".view-resize-handler");
  if (!$resizeHandlerEl.length) {
    view.$el.append('<div class="view-resize-handler"></div>');
    $resizeHandlerEl = view.$el.children(".view-resize-handler");
  }
  view.$resizeHandlerEl = $resizeHandlerEl;
  $el.addClass("view-resizable");
  const passive = support2.passiveListener ? {
    passive: true
  } : false;
  view.$el.on(app2.touchEvents.start, ".view-resize-handler", handleTouchStart, passive);
  app2.on("touchmove:active", handleTouchMove);
  app2.on("touchend:passive", handleTouchEnd);
  app2.on("resize", handleResize);
  view.on("beforeOpen", handleResize);
  view.once("viewDestroy", () => {
    $el.removeClass("view-resizable");
    view.$resizeHandlerEl.remove();
    view.$el.off(app2.touchEvents.start, ".view-resize-handler", handleTouchStart, passive);
    app2.off("touchmove:active", handleTouchMove);
    app2.off("touchend:passive", handleTouchEnd);
    app2.off("resize", handleResize);
    view.off("beforeOpen", handleResize);
  });
}
let View$2 = class View extends Framework7Class {
  constructor(app2, el, viewParams) {
    if (viewParams === void 0) {
      viewParams = {};
    }
    super(viewParams, [app2]);
    const view = this;
    const ssr = view.params.routerId;
    const defaults2 = {
      routes: [],
      routesAdd: []
    };
    if (!ssr) {
      const $el = $(el);
      if (!$el.length) {
        let message = "Framework7: can't create a View instance because ";
        message += typeof el === "string" ? `the selector "${el}" didn't match any element` : "el must be an HTMLElement or Dom7 object";
        throw new Error(message);
      }
    }
    view.params = extend$1({
      el
    }, defaults2, app2.params.view, viewParams);
    if (view.params.routes.length > 0) {
      view.routes = view.params.routes;
    } else {
      view.routes = [].concat(app2.routes, view.params.routesAdd);
    }
    extend$1(false, view, {
      app: app2,
      name: view.params.name,
      main: view.params.main,
      history: [],
      scrollHistory: {}
    });
    view.useModules();
    app2.views.push(view);
    if (view.main) {
      app2.views.main = view;
    }
    if (view.name) {
      app2.views[view.name] = view;
    }
    view.index = app2.views.indexOf(view);
    let viewId;
    if (view.name) {
      viewId = `view_${view.name}`;
    } else if (view.main) {
      viewId = "view_main";
    } else {
      viewId = `view_${view.index}`;
    }
    view.id = viewId;
    if (!view.params.init) {
      return view;
    }
    if (app2.initialized) {
      view.init();
    } else {
      app2.on("init", () => {
        view.init();
      });
    }
    return view;
  }
  destroy() {
    let view = this;
    const app2 = view.app;
    view.$el.trigger("view:beforedestroy");
    view.emit("local::beforeDestroy viewBeforeDestroy", view);
    app2.off("resize", view.checkMasterDetailBreakpoint);
    if (view.main) {
      app2.views.main = null;
      delete app2.views.main;
    } else if (view.name) {
      app2.views[view.name] = null;
      delete app2.views[view.name];
    }
    view.$el[0].f7View = null;
    delete view.$el[0].f7View;
    app2.views.splice(app2.views.indexOf(view), 1);
    if (view.params.router && view.router) {
      view.router.destroy();
    }
    view.emit("local::destroy viewDestroy", view);
    Object.keys(view).forEach((viewProp) => {
      view[viewProp] = null;
      delete view[viewProp];
    });
    view = null;
  }
  checkMasterDetailBreakpoint(force) {
    const view = this;
    const app2 = view.app;
    const wasMasterDetail = view.$el.hasClass("view-master-detail");
    const isMasterDetail = app2.width >= view.params.masterDetailBreakpoint && view.$el.children(".page-master").length;
    if (typeof force === "undefined" && isMasterDetail || force === true) {
      view.$el.addClass("view-master-detail");
      if (!wasMasterDetail) {
        view.emit("local::masterDetailBreakpoint viewMasterDetailBreakpoint", view);
        view.$el.trigger("view:masterDetailBreakpoint");
      }
    } else {
      view.$el.removeClass("view-master-detail");
      if (wasMasterDetail) {
        view.emit("local::masterDetailBreakpoint viewMasterDetailBreakpoint", view);
        view.$el.trigger("view:masterDetailBreakpoint");
      }
    }
  }
  initMasterDetail() {
    const view = this;
    const app2 = view.app;
    view.checkMasterDetailBreakpoint = view.checkMasterDetailBreakpoint.bind(view);
    view.checkMasterDetailBreakpoint();
    if (view.params.masterDetailResizable) {
      resizableView(view);
    }
    app2.on("resize", view.checkMasterDetailBreakpoint);
  }
  mount(viewEl) {
    const view = this;
    const app2 = view.app;
    const el = view.params.el || viewEl;
    const $el = $(el);
    let selector;
    if (typeof el === "string") selector = el;
    else {
      selector = ($el.attr("id") ? `#${$el.attr("id")}` : "") + ($el.attr("class") ? `.${$el.attr("class").replace(/ /g, ".").replace(".active", "")}` : "");
    }
    let $navbarsEl;
    if (app2.theme === "ios" && view.params.iosDynamicNavbar) {
      $navbarsEl = $el.children(".navbars").eq(0);
      if ($navbarsEl.length === 0) {
        $navbarsEl = $('<div class="navbars"></div>');
      }
    }
    extend$1(view, {
      $el,
      el: $el[0],
      main: view.main || $el.hasClass("view-main"),
      $navbarsEl,
      navbarsEl: $navbarsEl ? $navbarsEl[0] : void 0,
      selector
    });
    if (view.main) {
      app2.views.main = view;
    }
    if ($el && $el[0]) {
      $el[0].f7View = view;
    }
    view.emit("local::mount viewMount", view);
  }
  init(viewEl) {
    const view = this;
    view.mount(viewEl);
    if (view.params.router) {
      if (view.params.masterDetailBreakpoint > 0) {
        view.initMasterDetail();
      }
      if (view.params.initRouterOnTabShow && view.$el.hasClass("tab") && !view.$el.hasClass("tab-active")) {
        view.$el.once("tab:show", () => {
          view.router.init();
        });
      } else {
        view.router.init();
      }
      view.$el.trigger("view:init");
      view.emit("local::init viewInit", view);
    }
  }
};
View$2.use(RouterModule);
function initClicks(app2) {
  function handleClicks(e) {
    const window2 = getWindow();
    const $clickedEl = $(e.target);
    const $clickedLinkEl = $clickedEl.closest("a");
    const isLink = $clickedLinkEl.length > 0;
    const url = isLink && $clickedLinkEl.attr("href");
    if (isLink) {
      if ($clickedLinkEl.is(app2.params.clicks.externalLinks) || // eslint-disable-next-line
      url && url.indexOf("javascript:") >= 0) {
        const target = $clickedLinkEl.attr("target");
        if (url && window2.cordova && window2.cordova.InAppBrowser && (target === "_system" || target === "_blank")) {
          e.preventDefault();
          window2.cordova.InAppBrowser.open(url, target);
        } else if (url && window2.Capacitor && window2.Capacitor.Plugins && window2.Capacitor.Plugins.Browser && (target === "_system" || target === "_blank")) {
          e.preventDefault();
          window2.Capacitor.Plugins.Browser.open({
            url
          });
        }
        return;
      }
    }
    Object.keys(app2.modules).forEach((moduleName) => {
      const moduleClicks = app2.modules[moduleName].clicks;
      if (!moduleClicks) return;
      if (e.preventF7Router) return;
      Object.keys(moduleClicks).forEach((clickSelector) => {
        const matchingClickedElement = $clickedEl.closest(clickSelector).eq(0);
        if (matchingClickedElement.length > 0) {
          moduleClicks[clickSelector].call(app2, matchingClickedElement, matchingClickedElement.dataset(), e);
        }
      });
    });
    let clickedLinkData = {};
    if (isLink) {
      e.preventDefault();
      clickedLinkData = $clickedLinkEl.dataset();
    }
    clickedLinkData.clickedEl = $clickedLinkEl[0];
    if (e.preventF7Router) return;
    if ($clickedLinkEl.hasClass("prevent-router") || $clickedLinkEl.hasClass("router-prevent")) return;
    const validUrl = url && url.length > 0 && url[0] !== "#";
    if (validUrl || $clickedLinkEl.hasClass("back")) {
      let view;
      if (clickedLinkData.view && clickedLinkData.view === "current") {
        view = app2.views.current;
      } else if (clickedLinkData.view) {
        view = $(clickedLinkData.view)[0].f7View;
      } else {
        view = $clickedEl.parents(".view")[0] && $clickedEl.parents(".view")[0].f7View;
        if (view && view.params.linksView && (!$clickedLinkEl.hasClass("back") || $clickedLinkEl.hasClass("back") && view.router.history.length === 1)) {
          if (typeof view.params.linksView === "string") view = $(view.params.linksView)[0].f7View;
          else if (view.params.linksView instanceof View$2) view = view.params.linksView;
        }
      }
      if (!view) {
        if (app2.views.main) view = app2.views.main;
      }
      if (!view || !view.router) return;
      if ($clickedLinkEl[0].f7RouteProps) {
        clickedLinkData.props = $clickedLinkEl[0].f7RouteProps;
      }
      if ($clickedLinkEl.hasClass("back")) view.router.back(url, clickedLinkData);
      else view.router.navigate(url, clickedLinkData);
    }
  }
  app2.on("click", handleClicks);
}
const ClicksModule = {
  name: "clicks",
  params: {
    clicks: {
      // External Links
      externalLinks: ".external"
    }
  },
  on: {
    init() {
      const app2 = this;
      initClicks(app2);
    }
  }
};
const RouterComponentLoaderModule = {
  name: "routerComponentLoader",
  proto: {
    openIn(router, url, options) {
      const navigateOptions = {
        url,
        route: {
          path: url,
          options: {
            ...options,
            openIn: void 0
          }
        }
      };
      const params = {
        ...options
      };
      const component = (props, ctx) => {
        const {
          $h: $h2,
          $onMounted,
          $el,
          $f7
        } = ctx;
        $onMounted(() => {
          const viewEl = $el.value.find(".view");
          const view = $f7.view.create(viewEl, {
            linksView: router.view.selector,
            ignoreOpenIn: true,
            loadInitialPage: false
          });
          view.router.navigate(url, {
            props: options.props,
            reloadAll: true
          });
        });
        return () => {
          if (options.openIn === "popup") {
            return $h2`<div class="popup popup-router-open-in" data-url="${url}"><div class="view"></div></div>`;
          }
          if (options.openIn === "loginScreen") {
            return $h2`<div class="login-screen login-screen-router-open-in" data-url="${url}"><div class="view"></div></div>`;
          }
          if (options.openIn === "sheet") {
            return $h2`<div class="sheet-modal sheet-modal-router-open-in" data-url="${url}"><div class="sheet-modal-inner"><div class="view"></div></div></div>`;
          }
          if (options.openIn === "popover") {
            return $h2`<div class="popover popover-router-open-in" data-url="${url}"><div class="popover-inner"><div class="view"></div></div></div>`;
          }
          if (options.openIn.indexOf("panel") >= 0) {
            const parts = options.openIn.split(":");
            const side = parts[1] || "left";
            const effect = parts[2] || "cover";
            return $h2`<div class="panel panel-router-open-in panel-${side} panel-${effect}" data-url="${url}"><div class="view"></div></div>`;
          }
        };
      };
      if (options.openIn === "popup") {
        navigateOptions.route.popup = params;
      }
      if (options.openIn === "loginScreen") {
        navigateOptions.route.loginScreen = params;
      }
      if (options.openIn === "sheet") {
        navigateOptions.route.sheet = params;
      }
      if (options.openIn === "popover") {
        params.targetEl = options.clickedEl || options.targetEl;
        navigateOptions.route.popover = params;
      }
      if (options.openIn.indexOf("panel") >= 0) {
        params.targetEl = options.clickedEl || options.targetEl;
        navigateOptions.route.panel = params;
      }
      params.component = component;
      return router.navigate(navigateOptions);
    },
    componentLoader(component, componentUrl, options, resolve, reject) {
      if (options === void 0) {
        options = {};
      }
      const router = this;
      const {
        app: app2
      } = router;
      const url = typeof component === "string" ? component : componentUrl;
      const compiledUrl = router.replaceRequestUrlParams(url, options);
      function compile2(componentFunction) {
        let context = options.context || {};
        if (typeof context === "function") context = context.call(router);
        else if (typeof context === "string") {
          try {
            context = JSON.parse(context);
          } catch (err) {
            reject(err);
            throw err;
          }
        }
        const componentContext = merge({}, context, {
          f7route: options.route,
          f7router: router
        });
        const componentProps = merge(options.route ? options.route.params || {} : {}, options.props || {}, options.routeProps || {});
        let componentEl;
        let componentRoot;
        if (options.componentOptions && options.componentOptions.el) {
          componentEl = options.componentOptions.el;
        }
        if (options.componentOptions && options.componentOptions.root) {
          componentRoot = options.componentOptions.root;
        }
        app2.component.create(componentFunction, componentProps, {
          context: componentContext,
          el: componentEl,
          root: componentRoot
        }).then((createdComponent) => {
          resolve(createdComponent.el);
        }).catch((err) => {
          reject(err);
          throw new Error(err, {
            cause: err
          });
        });
      }
      let cachedComponent;
      if (compiledUrl && router.params.componentCache) {
        router.cache.components.forEach((cached) => {
          if (cached.url === compiledUrl) cachedComponent = cached.component;
        });
      }
      if (compiledUrl && cachedComponent) {
        compile2(cachedComponent);
      } else if (compiledUrl && !cachedComponent) {
        if (router.xhrAbortController) {
          router.xhrAbortController.abort();
          router.xhrAbortController = false;
        }
        router.xhrRequest(url, options).then((loadedComponent) => {
          const parsedComponent = app2.component.parse(loadedComponent);
          if (router.params.componentCache) {
            router.cache.components.push({
              url: compiledUrl,
              component: parsedComponent
            });
          }
          compile2(parsedComponent);
        }).catch((err) => {
          reject();
          throw err;
        });
      } else {
        compile2(component);
      }
    },
    modalComponentLoader(_temp) {
      let {
        component,
        componentUrl,
        options,
        resolve,
        reject
      } = _temp === void 0 ? {} : _temp;
      const router = this;
      router.componentLoader(component, componentUrl, options, (el) => {
        resolve(el);
      }, reject);
    },
    tabComponentLoader(_temp2) {
      let {
        component,
        componentUrl,
        options,
        resolve,
        reject
      } = _temp2 === void 0 ? {} : _temp2;
      const router = this;
      router.componentLoader(component, componentUrl, options, (el) => {
        resolve(el);
      }, reject);
    },
    pageComponentLoader(_temp3) {
      let {
        component,
        componentUrl,
        options,
        resolve,
        reject
      } = _temp3 === void 0 ? {} : _temp3;
      const router = this;
      router.componentLoader(component, componentUrl, options, function(el, newOptions) {
        if (newOptions === void 0) {
          newOptions = {};
        }
        resolve(el, newOptions);
      }, reject);
    }
  }
};
var n = function(t2, s, r, e) {
  var u;
  s[0] = 0;
  for (var h2 = 1; h2 < s.length; h2++) {
    var p = s[h2++], a = s[h2] ? (s[0] |= p ? 1 : 2, r[s[h2++]]) : s[++h2];
    3 === p ? e[0] = a : 4 === p ? e[1] = Object.assign(e[1] || {}, a) : 5 === p ? (e[1] = e[1] || {})[s[++h2]] = a : 6 === p ? e[1][s[++h2]] += a + "" : p ? (u = t2.apply(a, n(t2, a, r, ["", null])), e.push(u), a[0] ? s[0] |= 2 : (s[h2 - 2] = 0, s[h2] = u)) : e.push(a);
  }
  return e;
}, t = /* @__PURE__ */ new Map();
function htm(s) {
  var r = t.get(this);
  return r || (r = /* @__PURE__ */ new Map(), t.set(this, r)), (r = n(this, r.get(s) || (r.set(s, r = function(n2) {
    for (var t2, s2, r2 = 1, e = "", u = "", h2 = [0], p = function(n3) {
      1 === r2 && (n3 || (e = e.replace(/^\s*\n\s*|\s*\n\s*$/g, ""))) ? h2.push(0, n3, e) : 3 === r2 && (n3 || e) ? (h2.push(3, n3, e), r2 = 2) : 2 === r2 && "..." === e && n3 ? h2.push(4, n3, 0) : 2 === r2 && e && !n3 ? h2.push(5, 0, true, e) : r2 >= 5 && ((e || !n3 && 5 === r2) && (h2.push(r2, 0, e, s2), r2 = 6), n3 && (h2.push(r2, n3, 0, s2), r2 = 6)), e = "";
    }, a = 0; a < n2.length; a++) {
      a && (1 === r2 && p(), p(a));
      for (var l = 0; l < n2[a].length; l++) t2 = n2[a][l], 1 === r2 ? "<" === t2 ? (p(), h2 = [h2], r2 = 3) : e += t2 : 4 === r2 ? "--" === e && ">" === t2 ? (r2 = 1, e = "") : e = t2 + e[0] : u ? t2 === u ? u = "" : e += t2 : '"' === t2 || "'" === t2 ? u = t2 : ">" === t2 ? (p(), r2 = 1) : r2 && ("=" === t2 ? (r2 = 5, s2 = e, e = "") : "/" === t2 && (r2 < 5 || ">" === n2[a][l + 1]) ? (p(), 3 === r2 && (h2 = h2[0]), r2 = h2, (h2 = h2[0]).push(2, 0, r2), r2 = 0) : " " === t2 || "	" === t2 || "\n" === t2 || "\r" === t2 ? (p(), r2 = 2) : e += t2), 3 === r2 && "!--" === e && (r2 = 4, h2 = h2[0]);
    }
    return p(), h2;
  }(s)), r), arguments, [])).length > 1 ? r : r[0];
}
const ignoreChildren$1 = [false, null, "", void 0];
const h$1 = function(type, props) {
  for (var _len = arguments.length, children2 = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    children2[_key - 2] = arguments[_key];
  }
  return {
    type,
    props: props || {},
    children: flattenArray(children2.filter((child) => ignoreChildren$1.indexOf(child) < 0))
  };
};
const $h = htm.bind(h$1);
function vnode(sel, data2, children2, text2, elm) {
  var key = data2 === void 0 ? void 0 : data2.key;
  return {
    sel,
    data: data2,
    children: children2,
    text: text2,
    elm,
    key
  };
}
var array = Array.isArray;
function primitive(s) {
  return typeof s === "string" || typeof s === "number";
}
function addNS(data2, children2, sel) {
  data2.ns = "http://www.w3.org/2000/svg";
  if (sel !== "foreignObject" && children2 !== void 0) {
    for (var i = 0; i < children2.length; ++i) {
      var childData = children2[i].data;
      if (childData !== void 0) {
        addNS(childData, children2[i].children, children2[i].sel);
      }
    }
  }
}
function h(sel, b, c) {
  var data2 = {}, children2, text2, i;
  if (c !== void 0) {
    data2 = b;
    if (array(c)) {
      children2 = c;
    } else if (primitive(c)) {
      text2 = c;
    } else if (c && c.sel) {
      children2 = [c];
    }
  } else if (b !== void 0) {
    if (array(b)) {
      children2 = b;
    } else if (primitive(b)) {
      text2 = b;
    } else if (b && b.sel) {
      children2 = [b];
    } else {
      data2 = b;
    }
  }
  if (array(children2)) {
    for (i = 0; i < children2.length; ++i) {
      if (primitive(children2[i])) children2[i] = vnode(void 0, void 0, void 0, children2[i], void 0);
    }
  }
  if (sel[0] === "s" && sel[1] === "v" && sel[2] === "g" && (sel.length === 3 || sel[3] === "." || sel[3] === "#")) {
    addNS(data2, children2, sel);
  }
  return vnode(sel, data2, children2, text2, void 0);
}
const customComponents = {};
const SELF_CLOSING = "area base br col command embed hr img input keygen link menuitem meta param source track wbr".split(" ");
const PROPS_ATTRS = "hidden checked disabled readonly selected autofocus autoplay required multiple value indeterminate routeProps innerHTML".split(" ");
const BOOLEAN_PROPS = "hidden checked disabled readonly selected autofocus autoplay required multiple readOnly indeterminate".split(" ");
const getTagName = (treeNode) => {
  return typeof treeNode.type === "function" ? treeNode.type.name || "CustomComponent" : treeNode.type;
};
const toCamelCase = (name) => {
  return name.split("-").map((word, index2) => {
    if (index2 === 0) return word.toLowerCase();
    return word[0].toUpperCase() + word.substr(1);
  }).join("");
};
const propsFromAttrs = function() {
  const context = {};
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  args.forEach(function(obj) {
    if (obj === void 0) {
      obj = {};
    }
    Object.keys(obj).forEach((key) => {
      context[toCamelCase(key)] = obj[key];
    });
  });
  return context;
};
const createCustomComponent = (_ref) => {
  let {
    f7: f72,
    treeNode,
    vnode: vnode2,
    data: data2
  } = _ref;
  const component = typeof treeNode.type === "function" ? treeNode.type : customComponents[treeNode.type];
  f72.component.create(component, propsFromAttrs(data2.attrs || {}, data2.props || {}), {
    el: vnode2.elm,
    children: treeNode.children
  }).then((c) => {
    if (vnode2.data && vnode2.data.on && c && c.$el) {
      Object.keys(vnode2.data.on).forEach((eventName) => {
        c.$el.on(eventName, vnode2.data.on[eventName]);
      });
    }
    vnode2.elm.__component__ = c;
  });
};
const updateCustomComponent = (vnode2) => {
  const component = vnode2 && vnode2.elm && vnode2.elm.__component__;
  if (!component) return;
  const newProps = propsFromAttrs(vnode2.data.attrs || {}, vnode2.data.props || {});
  component.children = vnode2.data.treeNode.children;
  Object.assign(component.props, newProps);
  component.update();
};
const destroyCustomComponent = (vnode2) => {
  const component = vnode2 && vnode2.elm && vnode2.elm.__component__;
  if (component) {
    const {
      el,
      $el
    } = component;
    if (vnode2.data && vnode2.data.on && $el) {
      Object.keys(vnode2.data.on).forEach((eventName) => {
        $el.off(eventName, vnode2.data.on[eventName]);
      });
    }
    if (component.destroy) component.destroy();
    if (el && el.parentNode) el.parentNode.removeChild(el);
    delete vnode2.elm.__component__;
  }
};
const isCustomComponent = (treeNodeType) => {
  return typeof treeNodeType === "function" || treeNodeType && treeNodeType.indexOf("-") > 0 && customComponents[treeNodeType];
};
function getHooks(treeNode, data2, f72, initial, isRoot) {
  const hooks2 = {};
  const insert2 = [];
  const destroy = [];
  const update2 = [];
  const postpatch = [];
  let isFakeElement = false;
  let tagName2 = getTagName(treeNode);
  if (data2 && data2.attrs && data2.attrs.component) {
    tagName2 = data2.attrs.component;
    delete data2.attrs.component;
    isFakeElement = true;
  }
  const isCustom = isCustomComponent(treeNode.type);
  if (isCustom) {
    insert2.push((vnode2) => {
      if (vnode2.sel !== tagName2 && !isFakeElement) return;
      createCustomComponent({
        f7: f72,
        treeNode,
        vnode: vnode2,
        data: data2
      });
    });
    destroy.push((vnode2) => {
      destroyCustomComponent(vnode2);
    });
    update2.push((oldVnode, vnode2) => {
      updateCustomComponent(vnode2);
    });
  }
  if (!isCustom) {
    if (!data2 || !data2.attrs || !data2.attrs.class) return hooks2;
    const classNames2 = data2.attrs.class;
    classNames2.split(" ").forEach((className) => {
      if (!initial) {
        insert2.push(...f72.getVnodeHooks("insert", className));
      }
      destroy.push(...f72.getVnodeHooks("destroy", className));
      update2.push(...f72.getVnodeHooks("update", className));
      postpatch.push(...f72.getVnodeHooks("postpatch", className));
    });
  }
  if (isRoot && !initial) {
    postpatch.push((oldVnode, vnode2) => {
      const vn = vnode2 || oldVnode;
      if (!vn) return;
      if (vn.data && vn.data.component) {
        vn.data.component.hook("onUpdated");
      }
    });
  }
  if (insert2.length === 0 && destroy.length === 0 && update2.length === 0 && postpatch.length === 0) {
    return hooks2;
  }
  if (insert2.length) {
    hooks2.insert = (vnode2) => {
      insert2.forEach((f) => f(vnode2));
    };
  }
  if (destroy.length) {
    hooks2.destroy = (vnode2) => {
      destroy.forEach((f) => f(vnode2));
    };
  }
  if (update2.length) {
    hooks2.update = (oldVnode, vnode2) => {
      update2.forEach((f) => f(oldVnode, vnode2));
    };
  }
  if (postpatch.length) {
    hooks2.postpatch = (oldVnode, vnode2) => {
      postpatch.forEach((f) => f(oldVnode, vnode2));
    };
  }
  return hooks2;
}
const getEventHandler = function(eventHandler, _temp) {
  let {
    stop: stop2,
    prevent,
    once: once2
  } = _temp === void 0 ? {} : _temp;
  let fired = false;
  function handler() {
    const e = arguments.length <= 0 ? void 0 : arguments[0];
    if (once2 && fired) return;
    if (stop2) e.stopPropagation();
    if (prevent) e.preventDefault();
    fired = true;
    eventHandler(...arguments);
  }
  return handler;
};
const getData = (treeNode, component, f72, initial, isRoot) => {
  const data2 = {
    component,
    treeNode
  };
  const tagName2 = getTagName(treeNode);
  Object.keys(treeNode.props).forEach((attrName) => {
    const attrValue = treeNode.props[attrName];
    if (typeof attrValue === "undefined") return;
    if (PROPS_ATTRS.indexOf(attrName) >= 0) {
      if (!data2.props) data2.props = {};
      if (attrName === "readonly") {
        attrName = "readOnly";
      }
      if (attrName === "routeProps") {
        attrName = "f7RouteProps";
      }
      if (tagName2 === "option" && attrName === "value") {
        if (!data2.attrs) data2.attrs = {};
        data2.attrs.value = attrValue;
      }
      if (BOOLEAN_PROPS.indexOf(attrName) >= 0) {
        data2.props[attrName] = attrValue === false ? false : true;
      } else {
        data2.props[attrName] = attrValue;
      }
    } else if (attrName === "key") {
      data2.key = attrValue;
    } else if (attrName.indexOf("@") === 0 || attrName.indexOf("on") === 0 && attrName.length > 2) {
      if (!data2.on) data2.on = {};
      let eventName = attrName.indexOf("@") === 0 ? attrName.substr(1) : eventNameToColonCase(attrName.substr(2));
      let stop2 = false;
      let prevent = false;
      let once2 = false;
      if (eventName.indexOf(".") >= 0) {
        eventName.split(".").forEach((eventNamePart, eventNameIndex) => {
          if (eventNameIndex === 0) eventName = eventNamePart;
          else {
            if (eventNamePart === "stop") stop2 = true;
            if (eventNamePart === "prevent") prevent = true;
            if (eventNamePart === "once") once2 = true;
          }
        });
      }
      data2.on[eventName] = getEventHandler(attrValue, {
        stop: stop2,
        prevent,
        once: once2
      });
    } else if (attrName === "style") {
      if (typeof attrValue !== "string") {
        data2.style = attrValue;
      } else {
        if (!data2.attrs) data2.attrs = {};
        data2.attrs.style = attrValue;
      }
    } else {
      if (!data2.attrs) data2.attrs = {};
      data2.attrs[attrName] = attrValue;
      if (attrName === "id" && !data2.key && !isRoot) {
        data2.key = attrValue;
      }
    }
  });
  const hooks2 = getHooks(treeNode, data2, f72, initial, isRoot);
  hooks2.prepatch = (oldVnode, vnode2) => {
    if (!oldVnode || !vnode2) return;
    if (oldVnode && oldVnode.data && oldVnode.data.props) {
      Object.keys(oldVnode.data.props).forEach((key) => {
        if (BOOLEAN_PROPS.indexOf(key) < 0) return;
        if (!vnode2.data) vnode2.data = {};
        if (!vnode2.data.props) vnode2.data.props = {};
        if (oldVnode.data.props[key] === true && !(key in vnode2.data.props)) {
          vnode2.data.props[key] = false;
        }
      });
    }
  };
  data2.hook = hooks2;
  return data2;
};
const getChildren = (treeNode, component, f72, initial) => {
  if (treeNode && treeNode.type && SELF_CLOSING.indexOf(treeNode.type) >= 0) {
    return [];
  }
  const children2 = [];
  const nodes = treeNode.children;
  for (let i = 0; i < nodes.length; i += 1) {
    const childNode = nodes[i];
    const child = treeNodeToVNode(childNode, component, f72, initial, false);
    if (Array.isArray(child)) {
      children2.push(...child);
    } else if (child) {
      children2.push(child);
    }
  }
  return children2;
};
const getSlots = (treeNode, component, f72, initial) => {
  const slotName = treeNode.props.name || "default";
  const slotNodes = (component.children || []).filter((childTreeNode) => {
    let childSlotName = "default";
    if (childTreeNode.props) {
      childSlotName = childTreeNode.props.slot || "default";
    }
    return childSlotName === slotName;
  });
  if (slotNodes.length === 0) {
    return getChildren(treeNode, component, f72, initial);
  }
  return slotNodes.map((subTreeNode) => treeNodeToVNode(subTreeNode, component, f72, initial));
};
const isTreeNode = (treeNode) => {
  return isObject$1(treeNode) && "props" in treeNode && "type" in treeNode && "children" in treeNode;
};
const treeNodeToVNode = (treeNode, component, f72, initial, isRoot) => {
  if (!isTreeNode(treeNode)) {
    return String(treeNode);
  }
  if (treeNode.type === "slot") {
    return getSlots(treeNode, component, f72, initial);
  }
  const data2 = getData(treeNode, component, f72, initial, isRoot);
  const children2 = isCustomComponent(treeNode.type) ? [] : getChildren(treeNode, component, f72, initial);
  return h(getTagName(treeNode), data2, children2);
};
function vdom(tree, component, initial) {
  if (tree === void 0) {
    tree = {};
  }
  return treeNodeToVNode(tree, component, component.f7, initial, true);
}
function createElement(tagName2) {
  return document.createElement(tagName2);
}
function createElementNS(namespaceURI, qualifiedName) {
  return document.createElementNS(namespaceURI, qualifiedName);
}
function createTextNode(text2) {
  return document.createTextNode(text2);
}
function createComment(text2) {
  return document.createComment(text2);
}
function insertBefore(parentNode2, newNode, referenceNode) {
  if (referenceNode && referenceNode.parentNode !== parentNode2) {
    if (referenceNode.__component__) referenceNode = referenceNode.__component__.el;
  }
  parentNode2.insertBefore(newNode, referenceNode);
}
function removeChild(node, child) {
  if (!node) return;
  node.removeChild(child);
}
function appendChild(node, child) {
  node.appendChild(child);
}
function parentNode(node) {
  return node.parentNode;
}
function nextSibling(node) {
  return node.nextSibling;
}
function tagName(elm) {
  return elm.tagName;
}
function setTextContent(node, text2) {
  node.textContent = text2;
}
function getTextContent(node) {
  return node.textContent;
}
function isElement(node) {
  return node.nodeType === 1;
}
function isText(node) {
  return node.nodeType === 3;
}
function isComment(node) {
  return node.nodeType === 8;
}
var htmlDomApi = {
  createElement,
  createElementNS,
  createTextNode,
  createComment,
  insertBefore,
  removeChild,
  appendChild,
  parentNode,
  nextSibling,
  tagName,
  setTextContent,
  getTextContent,
  isElement,
  isText,
  isComment
};
function isUndef(s) {
  return s === void 0;
}
function isDef(s) {
  return s !== void 0;
}
var emptyNode = vnode("", {}, [], void 0, void 0);
function sameVnode(vnode1, vnode2) {
  return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;
}
function isVnode(vnode2) {
  return vnode2.sel !== void 0;
}
function createKeyToOldIdx(children2, beginIdx, endIdx) {
  var i, map = {}, key, ch;
  for (i = beginIdx; i <= endIdx; ++i) {
    ch = children2[i];
    if (ch != null) {
      key = ch.key;
      if (key !== void 0) map[key] = i;
    }
  }
  return map;
}
var hooks = ["create", "update", "remove", "destroy", "pre", "post"];
function init$1(modules, domApi) {
  var i, j, cbs = {};
  var api = htmlDomApi;
  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      var hook = modules[j][hooks[i]];
      if (hook !== void 0) {
        cbs[hooks[i]].push(hook);
      }
    }
  }
  function emptyNodeAt(elm) {
    var id2 = elm.id ? "#" + elm.id : "";
    var c = elm.className ? "." + elm.className.split(" ").join(".") : "";
    return vnode(api.tagName(elm).toLowerCase() + id2 + c, {}, [], void 0, elm);
  }
  function createRmCb(childElm, listeners) {
    return function rmCb() {
      if (--listeners === 0) {
        var parent_1 = api.parentNode(childElm);
        api.removeChild(parent_1, childElm);
      }
    };
  }
  function createElm(vnode2, insertedVnodeQueue) {
    var i2, data2 = vnode2.data;
    if (data2 !== void 0) {
      if (isDef(i2 = data2.hook) && isDef(i2 = i2.init)) {
        i2(vnode2);
        data2 = vnode2.data;
      }
    }
    var children2 = vnode2.children, sel = vnode2.sel;
    if (sel === "!") {
      if (isUndef(vnode2.text)) {
        vnode2.text = "";
      }
      vnode2.elm = api.createComment(vnode2.text);
    } else if (sel !== void 0) {
      var hashIdx = sel.indexOf("#");
      var dotIdx = sel.indexOf(".", hashIdx);
      var hash = hashIdx > 0 ? hashIdx : sel.length;
      var dot = dotIdx > 0 ? dotIdx : sel.length;
      var tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel;
      var elm = vnode2.elm = isDef(data2) && isDef(i2 = data2.ns) ? api.createElementNS(i2, tag) : api.createElement(tag);
      if (hash < dot) elm.setAttribute("id", sel.slice(hash + 1, dot));
      if (dotIdx > 0) elm.setAttribute("class", sel.slice(dot + 1).replace(/\./g, " "));
      for (i2 = 0; i2 < cbs.create.length; ++i2) cbs.create[i2](emptyNode, vnode2);
      if (array(children2)) {
        for (i2 = 0; i2 < children2.length; ++i2) {
          var ch = children2[i2];
          if (ch != null) {
            api.appendChild(elm, createElm(ch, insertedVnodeQueue));
          }
        }
      } else if (primitive(vnode2.text)) {
        api.appendChild(elm, api.createTextNode(vnode2.text));
      }
      i2 = vnode2.data.hook;
      if (isDef(i2)) {
        if (i2.create) i2.create(emptyNode, vnode2);
        if (i2.insert) insertedVnodeQueue.push(vnode2);
      }
    } else {
      vnode2.elm = api.createTextNode(vnode2.text);
    }
    return vnode2.elm;
  }
  function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (ch != null) {
        api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);
      }
    }
  }
  function invokeDestroyHook(vnode2) {
    var i2, j2, data2 = vnode2.data;
    if (data2 !== void 0) {
      if (isDef(i2 = data2.hook) && isDef(i2 = i2.destroy)) i2(vnode2);
      for (i2 = 0; i2 < cbs.destroy.length; ++i2) cbs.destroy[i2](vnode2);
      if (vnode2.children !== void 0) {
        for (j2 = 0; j2 < vnode2.children.length; ++j2) {
          i2 = vnode2.children[j2];
          if (i2 != null && typeof i2 !== "string") {
            invokeDestroyHook(i2);
          }
        }
      }
    }
  }
  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var i_1 = void 0, listeners = void 0, rm = void 0, ch = vnodes[startIdx];
      if (ch != null) {
        if (isDef(ch.sel)) {
          invokeDestroyHook(ch);
          listeners = cbs.remove.length + 1;
          rm = createRmCb(ch.elm, listeners);
          for (i_1 = 0; i_1 < cbs.remove.length; ++i_1) cbs.remove[i_1](ch, rm);
          if (isDef(i_1 = ch.data) && isDef(i_1 = i_1.hook) && isDef(i_1 = i_1.remove)) {
            i_1(ch, rm);
          } else {
            rm();
          }
        } else {
          api.removeChild(parentElm, ch.elm);
        }
      }
    }
  }
  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {
    var oldStartIdx = 0, newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx;
    var idxInOld;
    var elmToMove;
    var before;
    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (oldStartVnode == null) {
        oldStartVnode = oldCh[++oldStartIdx];
      } else if (oldEndVnode == null) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (newStartVnode == null) {
        newStartVnode = newCh[++newStartIdx];
      } else if (newEndVnode == null) {
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (oldKeyToIdx === void 0) {
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }
        idxInOld = oldKeyToIdx[newStartVnode.key];
        if (isUndef(idxInOld)) {
          api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
          newStartVnode = newCh[++newStartIdx];
        } else {
          elmToMove = oldCh[idxInOld];
          if (elmToMove.sel !== newStartVnode.sel) {
            api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
          } else {
            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
            oldCh[idxInOld] = void 0;
            api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
          }
          newStartVnode = newCh[++newStartIdx];
        }
      }
    }
    if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {
      if (oldStartIdx > oldEndIdx) {
        before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;
        addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
      } else {
        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
      }
    }
  }
  function patchVnode(oldVnode, vnode2, insertedVnodeQueue) {
    var i2, hook2;
    if (isDef(i2 = vnode2.data) && isDef(hook2 = i2.hook) && isDef(i2 = hook2.prepatch)) {
      i2(oldVnode, vnode2);
    }
    var elm = vnode2.elm = oldVnode.elm;
    var oldCh = oldVnode.children;
    var ch = vnode2.children;
    if (oldVnode === vnode2) return;
    if (vnode2.data !== void 0) {
      for (i2 = 0; i2 < cbs.update.length; ++i2) cbs.update[i2](oldVnode, vnode2);
      i2 = vnode2.data.hook;
      if (isDef(i2) && isDef(i2 = i2.update)) i2(oldVnode, vnode2);
    }
    if (isUndef(vnode2.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue);
      } else if (isDef(ch)) {
        if (isDef(oldVnode.text)) api.setTextContent(elm, "");
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        api.setTextContent(elm, "");
      }
    } else if (oldVnode.text !== vnode2.text) {
      api.setTextContent(elm, vnode2.text);
    }
    if (isDef(hook2) && isDef(i2 = hook2.postpatch)) {
      i2(oldVnode, vnode2);
    }
  }
  return function patch2(oldVnode, vnode2) {
    var i2, elm, parent2;
    var insertedVnodeQueue = [];
    for (i2 = 0; i2 < cbs.pre.length; ++i2) cbs.pre[i2]();
    if (!isVnode(oldVnode)) {
      oldVnode = emptyNodeAt(oldVnode);
    }
    if (sameVnode(oldVnode, vnode2)) {
      patchVnode(oldVnode, vnode2, insertedVnodeQueue);
    } else {
      elm = oldVnode.elm;
      parent2 = api.parentNode(elm);
      createElm(vnode2, insertedVnodeQueue);
      if (parent2 !== null) {
        api.insertBefore(parent2, vnode2.elm, api.nextSibling(elm));
        removeVnodes(parent2, [oldVnode], 0, 0);
      }
    }
    for (i2 = 0; i2 < insertedVnodeQueue.length; ++i2) {
      insertedVnodeQueue[i2].data.hook.insert(insertedVnodeQueue[i2]);
    }
    for (i2 = 0; i2 < cbs.post.length; ++i2) cbs.post[i2]();
    return vnode2;
  };
}
var xlinkNS = "http://www.w3.org/1999/xlink";
var xmlNS = "http://www.w3.org/XML/1998/namespace";
var colonChar = 58;
var xChar = 120;
function updateAttrs(oldVnode, vnode2) {
  var key, elm = vnode2.elm, oldAttrs = oldVnode.data.attrs, attrs = vnode2.data.attrs;
  if (!oldAttrs && !attrs) return;
  if (oldAttrs === attrs) return;
  oldAttrs = oldAttrs || {};
  attrs = attrs || {};
  for (key in attrs) {
    var cur = attrs[key];
    var old = oldAttrs[key];
    if (old !== cur) {
      if (cur === true) {
        elm.setAttribute(key, "");
      } else if (cur === false) {
        elm.removeAttribute(key);
      } else {
        if (key.charCodeAt(0) !== xChar) {
          elm.setAttribute(key, cur);
        } else if (key.charCodeAt(3) === colonChar) {
          elm.setAttributeNS(xmlNS, key, cur);
        } else if (key.charCodeAt(5) === colonChar) {
          elm.setAttributeNS(xlinkNS, key, cur);
        } else {
          elm.setAttribute(key, cur);
        }
      }
    }
  }
  for (key in oldAttrs) {
    if (!(key in attrs)) {
      elm.removeAttribute(key);
    }
  }
}
var attributesModule = {
  create: updateAttrs,
  update: updateAttrs
};
function updateProps(oldVnode, vnode2) {
  var key, cur, old, elm = vnode2.elm, oldProps = oldVnode.data.props, props = vnode2.data.props;
  if (!oldProps && !props) return;
  if (oldProps === props) return;
  oldProps = oldProps || {};
  props = props || {};
  for (key in oldProps) {
    if (!props[key]) {
      delete elm[key];
    }
  }
  for (key in props) {
    cur = props[key];
    old = oldProps[key];
    if (old !== cur && (key !== "value" || elm[key] !== cur)) {
      elm[key] = cur;
    }
  }
}
var propsModule = {
  create: updateProps,
  update: updateProps
};
var raf = typeof window !== "undefined" && window.requestAnimationFrame || setTimeout;
var nextFrame = function(fn) {
  raf(function() {
    raf(fn);
  });
};
function setNextFrame(obj, prop2, val2) {
  nextFrame(function() {
    obj[prop2] = val2;
  });
}
function updateStyle(oldVnode, vnode2) {
  var cur, name, elm = vnode2.elm, oldStyle = oldVnode.data.style, style = vnode2.data.style;
  if (!oldStyle && !style) return;
  if (oldStyle === style) return;
  oldStyle = oldStyle || {};
  style = style || {};
  var oldHasDel = "delayed" in oldStyle;
  for (name in oldStyle) {
    if (!style[name]) {
      if (name[0] === "-" && name[1] === "-") {
        elm.style.removeProperty(name);
      } else {
        elm.style[name] = "";
      }
    }
  }
  for (name in style) {
    cur = style[name];
    if (name === "delayed" && style.delayed) {
      for (var name2 in style.delayed) {
        cur = style.delayed[name2];
        if (!oldHasDel || cur !== oldStyle.delayed[name2]) {
          setNextFrame(elm.style, name2, cur);
        }
      }
    } else if (name !== "remove" && cur !== oldStyle[name]) {
      if (name[0] === "-" && name[1] === "-") {
        elm.style.setProperty(name, cur);
      } else {
        elm.style[name] = cur;
      }
    }
  }
}
function applyDestroyStyle(vnode2) {
  var style, name, elm = vnode2.elm, s = vnode2.data.style;
  if (!s || !(style = s.destroy)) return;
  for (name in style) {
    elm.style[name] = style[name];
  }
}
function applyRemoveStyle(vnode2, rm) {
  var s = vnode2.data.style;
  if (!s || !s.remove) {
    rm();
    return;
  }
  var name, elm = vnode2.elm, i = 0, compStyle, style = s.remove, amount = 0, applied = [];
  for (name in style) {
    applied.push(name);
    elm.style[name] = style[name];
  }
  compStyle = getComputedStyle(elm);
  var props = compStyle["transition-property"].split(", ");
  for (; i < props.length; ++i) {
    if (applied.indexOf(props[i]) !== -1) amount++;
  }
  elm.addEventListener("transitionend", function(ev) {
    if (ev.target === elm) --amount;
    if (amount === 0) rm();
  });
}
var styleModule = {
  create: updateStyle,
  update: updateStyle,
  destroy: applyDestroyStyle,
  remove: applyRemoveStyle
};
function invokeHandler(handler, event, args) {
  if (typeof handler === "function") {
    handler(event, ...args);
  }
}
function handleEvent(event, args, vnode2) {
  const name = event.type;
  const on2 = vnode2.data.on;
  if (on2 && on2[name]) {
    invokeHandler(on2[name], event, args);
  }
}
function createListener() {
  return function handler(event) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    handleEvent(event, args, handler.vnode);
  };
}
function updateEvents(oldVnode, vnode2) {
  const oldOn = oldVnode.data.on;
  const oldListener = oldVnode.listener;
  const oldElm = oldVnode.elm;
  const on2 = vnode2 && vnode2.data.on;
  const elm = vnode2 && vnode2.elm;
  if (oldOn === on2) {
    return;
  }
  if (oldOn && oldListener) {
    if (!on2) {
      Object.keys(oldOn).forEach((name) => {
        $(oldElm).off(name, oldListener);
      });
    } else {
      Object.keys(oldOn).forEach((name) => {
        if (!on2[name]) {
          $(oldElm).off(name, oldListener);
        }
      });
    }
  }
  if (on2) {
    const listener = oldVnode.listener || createListener();
    vnode2.listener = listener;
    listener.vnode = vnode2;
    if (!oldOn) {
      Object.keys(on2).forEach((name) => {
        $(elm).on(name, listener);
      });
    } else {
      Object.keys(on2).forEach((name) => {
        if (!oldOn[name]) {
          $(elm).on(name, listener);
        }
      });
    }
  }
}
const eventListenersModule = {
  create: updateEvents,
  update: updateEvents,
  destroy: updateEvents
};
const patch = init$1([attributesModule, propsModule, styleModule, eventListenersModule]);
const ignoreChildren = [false, null, "", void 0];
const $jsx = function(type, props) {
  for (var _len = arguments.length, children2 = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    children2[_key - 2] = arguments[_key];
  }
  const flatChildren = flattenArray((children2 || []).filter((child) => ignoreChildren.indexOf(child) < 0));
  if (type === "Fragment") {
    return flatChildren;
  }
  return {
    type,
    props: props || {},
    children: flatChildren
  };
};
const types = [{
  name: "array",
  init: (i) => i,
  type: (i) => [i].find(Array.isArray),
  update: (i, o) => [o].filter(Array.isArray).find(() => (i.length = 0, i.push(...o))),
  insert: function(i, x, o) {
    if (o === void 0) {
      o = [];
    }
    return i.splice(Math.max(x, 0), 0, ...[o].flat());
  },
  replace: function(i, x, o) {
    if (o === void 0) {
      o = [];
    }
    return i.splice(Math.max(x, 0), Math.min(++x, 1), ...[o].flat());
  },
  append: function(i, o) {
    if (o === void 0) {
      o = [];
    }
    return i.push(...[o].flat());
  },
  prepend: function(i, o) {
    if (o === void 0) {
      o = [];
    }
    return i.unshift(...[o].flat());
  },
  swap: (i, a, b) => {
    [i[a], i[b]] = [i[b], i[a]];
  },
  fromTo: function(i, a, b) {
    if (b === void 0) {
      b = a;
    }
    return i.splice(Math.max(b, 0), 0, ...i.splice(Math.max(a, 0), 1));
  },
  remove: function(i, o, a) {
    if (a === void 0) {
      a = i.map((_, x) => x);
    }
    return [o].flat().filter((i2) => a.includes(i2)).sort((a2, b) => b - a2).forEach((x) => i.splice(x, 1));
  },
  clear: (i) => i.length = 0
}, {
  name: "object",
  init: (i) => i,
  type: (i) => [i].filter((i2) => [i2 !== null, i2 !== void 0].every((i3) => i3)).find((i2) => Object.getPrototypeOf(i2) === Object.prototype),
  update: (i, o) => Object.assign(i, o),
  insert: () => {
  },
  replace: () => {
  },
  append: () => {
  },
  prepend: () => {
  },
  swap: () => ({}),
  // N/A
  fromTo: () => ({}),
  // N/A
  remove: (i, o) => [o].flat().forEach((k) => delete i[k]),
  clear: (i) => Object.keys(i).forEach((k) => delete i[k])
}, {
  name: "atoms",
  type: () => true,
  init: function(i, o) {
    if (o === void 0) {
      o = {};
    }
    return Object.defineProperty(o, "value", {
      get: () => i,
      set: (v) => {
        i = v;
      }
    }), o;
  },
  update: function(i, v) {
    if (v === void 0) {
      v = i.value;
    }
    i.value = v;
  },
  insert: () => ({}),
  // N/A
  replace: () => ({}),
  // N/A
  append: () => ({}),
  // N/A
  prepend: () => ({}),
  // N/A
  swap: () => ({}),
  // N/A
  fromTo: () => ({}),
  // N/A
  remove: () => ({}),
  // N/A
  clear: (i) => {
    i.value = void 0;
  }
}];
class Component {
  constructor(app2, component, props, _temp) {
    if (props === void 0) {
      props = {};
    }
    let {
      el,
      context,
      children: children2
    } = _temp === void 0 ? {} : _temp;
    const document2 = getDocument();
    merge(this, {
      f7: app2,
      props: props || {},
      context: context || {},
      id: component.id || id(),
      children: children2 || [],
      theme: {
        ios: app2.theme === "ios",
        md: app2.theme === "md"
      },
      style: component.style,
      __updateQueue: [],
      __eventHandlers: [],
      __onceEventHandlers: [],
      __onBeforeMount: [],
      __onMounted: [],
      __onBeforeUpdate: [],
      __onUpdated: [],
      __onBeforeUnmount: [],
      __onUnmounted: []
    });
    const createComponent = () => {
      return component(this.props, this.getComponentContext(true));
    };
    const getRenderFuncion = (componentResult) => new Promise((resolve, reject) => {
      if (typeof componentResult === "function") {
        resolve(componentResult);
      } else if (componentResult instanceof Promise) {
        componentResult.then((render) => {
          resolve(render);
        }).catch((err) => {
          reject(err);
        });
      } else {
        reject(new Error(`Framework7: Component render function is not a "function" type. Didn't you forget to "return $render"?`));
      }
    });
    return new Promise((resolve, reject) => {
      const componentResult = createComponent();
      getRenderFuncion(componentResult).then((render) => {
        this.renderFunction = render;
        const tree = this.render();
        if (el) {
          this.vnode = vdom(tree, this, true);
          if (this.style) {
            this.styleEl = document2.createElement("style");
            this.styleEl.innerHTML = this.style;
          }
          this.el = el;
          patch(this.el, this.vnode);
          this.el = this.vnode.elm;
          this.$el = $(this.el);
          this.attachEvents();
          this.el.f7Component = this;
          this.mount();
          resolve(this);
          return;
        }
        if (tree) {
          this.vnode = vdom(tree, this, true);
          this.el = document2.createElement(this.vnode.sel || "div");
          patch(this.el, this.vnode);
          this.$el = $(this.el);
        }
        if (this.style) {
          this.styleEl = document2.createElement("style");
          this.styleEl.innerHTML = this.style;
        }
        this.attachEvents();
        if (this.el) {
          this.el.f7Component = this;
        }
        resolve(this);
      }).catch((err) => {
        reject(err);
      });
    });
  }
  on(eventName, handler) {
    if (!this.__eventHandlers) return;
    this.__eventHandlers.push({
      eventName,
      handler
    });
  }
  once(eventName, handler) {
    if (!this.__eventHandlers) return;
    this.__onceEventHandlers.push({
      eventName,
      handler
    });
  }
  getComponentRef() {
    const self = this;
    return (initialValue) => {
      let value2 = initialValue;
      const obj = {};
      Object.defineProperty(obj, "value", {
        get() {
          return value2;
        },
        set(v) {
          value2 = v;
          self.update();
        }
      });
      return obj;
    };
  }
  getComponentStore() {
    const {
      state,
      _gettersPlain,
      dispatch
    } = this.f7.store;
    const $store = {
      state,
      dispatch
    };
    $store.getters = new Proxy(_gettersPlain, {
      get: (target, prop2) => {
        const obj = target[prop2];
        const callback = (v) => {
          obj.value = v;
          this.update();
        };
        obj.onUpdated(callback);
        return obj;
      }
    });
    return $store;
  }
  /* eslint-disable no-sequences */
  getUseState() {
    var _this = this;
    return (o) => {
      const obj = [o].reduce(function(t2, _i, _x, _a, i) {
        if (i === void 0) {
          i = t2.init(_i);
        }
        return {
          state: i,
          update: (v) => (t2.update(i, v), _this.update()),
          remove: (v) => (t2.remove(i, v), _this.update()),
          clear: () => (t2.clear(i), _this.update()),
          insert: (x, v) => (t2.insert(i, x, v), _this.update()),
          replace: (x, v) => (t2.replace(i, x, v), _this.update()),
          append: (v) => (t2.append(i, v), _this.update()),
          prepend: (v) => (t2.prepend(i, v), _this.update()),
          swap: (a, b) => (t2.swap(i, a, b), _this.update()),
          fromTo: (a, b) => (t2.fromTo(i, a, b), _this.update()),
          method: function(f) {
            if (f === void 0) {
              f = () => ({});
            }
            return f(i), _this.update();
          },
          async: function(f) {
            if (f === void 0) {
              f = () => Promise.reject(i);
            }
            return f(i).then(() => _this.update());
          }
        };
      }, types.find((i) => i.type(o)));
      obj.length = 12;
      obj[Symbol.iterator] = function Iterate() {
        const values = Object.values(this);
        values.splice(values.indexOf(12), 1);
        let index2 = 0;
        return {
          next() {
            if (index2 < values.length) {
              const val2 = values[index2];
              index2 += 1;
              return {
                value: val2,
                done: false
              };
            }
            return {
              done: true
            };
          }
        };
      };
      return obj;
    };
  }
  /* eslint-enable no-sequences */
  getComponentContext(includeHooks) {
    const ctx = {
      $f7route: this.context.f7route,
      $f7router: this.context.f7router,
      $h,
      $,
      $id: this.id,
      $f7: this.f7,
      $f7ready: this.f7ready.bind(this),
      $theme: this.theme,
      $tick: this.tick.bind(this),
      $update: this.update.bind(this),
      $emit: this.emit.bind(this),
      $store: this.getComponentStore(),
      $ref: this.getComponentRef(),
      $el: {},
      $useState: this.getUseState()
    };
    Object.defineProperty(ctx.$el, "value", {
      get: () => {
        return this.$el;
      }
    });
    if (includeHooks) Object.assign(ctx, {
      $on: this.on.bind(this),
      $once: this.once.bind(this),
      $onBeforeMount: (handler) => this.__onBeforeMount.push(handler),
      $onMounted: (handler) => this.__onMounted.push(handler),
      $onBeforeUpdate: (handler) => this.__onBeforeUpdate.push(handler),
      $onUpdated: (handler) => this.__onUpdated.push(handler),
      $onBeforeUnmount: (handler) => this.__onBeforeUnmount.push(handler),
      $onUnmounted: (handler) => this.__onUnmounted.push(handler)
    });
    return ctx;
  }
  render() {
    return this.renderFunction(this.getComponentContext());
  }
  emit(name, data2) {
    if (!this.el) return;
    this.$el.trigger(name, data2);
  }
  attachEvents() {
    const {
      $el
    } = this;
    if (!this.__eventHandlers) return;
    this.__eventHandlers.forEach((_ref) => {
      let {
        eventName,
        handler
      } = _ref;
      $el.on(eventNameToColonCase(eventName), handler);
    });
    this.__onceEventHandlers.forEach((_ref2) => {
      let {
        eventName,
        handler
      } = _ref2;
      $el.once(eventNameToColonCase(eventName), handler);
    });
  }
  detachEvents() {
    const {
      $el
    } = this;
    if (!this.__eventHandlers) return;
    this.__eventHandlers.forEach((_ref3) => {
      let {
        eventName,
        handler
      } = _ref3;
      $el.on(eventNameToColonCase(eventName), handler);
    });
    this.__onceEventHandlers.forEach((_ref4) => {
      let {
        eventName,
        handler
      } = _ref4;
      $el.once(eventNameToColonCase(eventName), handler);
    });
  }
  startUpdateQueue() {
    const window2 = getWindow();
    if (this.__requestAnimationFrameId) return;
    const update2 = () => {
      this.hook("onBeforeUpdate");
      const tree = this.render();
      if (tree) {
        const newVNode = vdom(tree, this, false);
        this.vnode = patch(this.vnode, newVNode);
      }
    };
    this.__requestAnimationFrameId = window2.requestAnimationFrame(() => {
      if (this.__updateIsPending) update2();
      let resolvers = [...this.__updateQueue];
      this.__updateQueue = [];
      this.__updateIsPending = false;
      window2.cancelAnimationFrame(this.__requestAnimationFrameId);
      delete this.__requestAnimationFrameId;
      delete this.__updateIsPending;
      resolvers.forEach((resolver) => resolver());
      resolvers = [];
    });
  }
  tick(callback) {
    return new Promise((resolve) => {
      function resolver() {
        resolve();
        if (callback) callback();
      }
      this.__updateQueue.push(resolver);
      this.startUpdateQueue();
    });
  }
  update(callback) {
    if (this.__destroyed) return new Promise(() => {
    });
    return new Promise((resolve) => {
      const resolver = () => {
        resolve();
        if (callback) callback();
      };
      this.__updateIsPending = true;
      this.__updateQueue.push(resolver);
      this.startUpdateQueue();
    });
  }
  setState(callback) {
    return this.update(callback);
  }
  f7ready(callback) {
    if (this.f7.initialized) {
      callback(this.f7);
      return;
    }
    this.f7.once("init", () => {
      callback(this.f7);
    });
  }
  mount(mountMethod) {
    this.hook("onBeforeMount", this.$el);
    if (this.styleEl) $("head").append(this.styleEl);
    if (mountMethod) mountMethod(this.el);
    this.hook("onMounted", this.$el);
  }
  destroy() {
    if (this.__destroyed) return;
    const window2 = getWindow();
    this.hook("onBeforeUnmount");
    if (this.styleEl) $(this.styleEl).remove();
    this.detachEvents();
    this.hook("onUnmounted");
    if (this.el && this.el.f7Component) {
      this.el.f7Component = null;
      delete this.el.f7Component;
    }
    if (this.vnode) {
      this.vnode = patch(this.vnode, {
        sel: this.vnode.sel,
        data: {}
      });
    }
    window2.cancelAnimationFrame(this.__requestAnimationFrameId);
    this.__updateQueue = [];
    this.__eventHandlers = [];
    this.__onceEventHandlers = [];
    this.__onBeforeMount = [];
    this.__onMounted = [];
    this.__onBeforeUpdate = [];
    this.__onUpdated = [];
    this.__onBeforeUnmount = [];
    this.__onUnmounted = [];
    deleteProps(this);
    this.__destroyed = true;
  }
  hook(name) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    if (this.__destroyed) return;
    this[`__${name}`].forEach((handler) => {
      handler(...args);
    });
  }
}
Component.$jsx = $jsx;
function parseComponent(componentString) {
  const window2 = getWindow();
  const document2 = getDocument();
  const componentId = id();
  const callbackCreateName = `f7_component_create_callback_${componentId}`;
  let template;
  const hasTemplate = componentString.match(/<template([ ]?)([a-z0-9-]*)>/);
  if (hasTemplate) {
    template = componentString.split(/<template[ ]?[a-z0-9-]*>/).filter((item, index2) => index2 > 0).join("<template>").split("</template>").filter((item, index2, arr) => index2 < arr.length - 1).join("</template>").replace(/{{#raw}}([ \n]*)<template/g, "{{#raw}}<template").replace(/\/template>([ \n]*){{\/raw}}/g, "/template>{{/raw}}").replace(/([ \n])<template/g, "$1{{#raw}}<template").replace(/\/template>([ \n])/g, "/template>{{/raw}}$1");
  }
  let style = null;
  if (componentString.indexOf("<style>") >= 0) {
    style = componentString.split("<style>")[1].split("</style>")[0];
  }
  if (componentString.indexOf("<style scoped>") >= 0) {
    style = componentString.split("<style scoped>")[1].split("</style>")[0];
  }
  let scriptContent;
  if (componentString.indexOf("<script>") >= 0) {
    const scripts = componentString.split("<script>");
    scriptContent = scripts[scripts.length - 1].split("<\/script>")[0].trim();
  } else {
    scriptContent = "return () => {return $render}";
  }
  if (!scriptContent || !scriptContent.trim()) scriptContent = "return () => {return $render}";
  if (template) {
    scriptContent = scriptContent.replace("$render", `function ($$ctx) {
          var $ = $$ctx.$$;
          var $h = $$ctx.$h;
          var $root = $$ctx.$root;
          var $f7 = $$ctx.$f7;
          var $f7route = $$ctx.$f7route;
          var $f7router = $$ctx.$f7router;
          var $theme = $$ctx.$theme;
          var $update = $$ctx.$update;
          var $store = $$ctx.$store;
          var $ref = $$ctx.$ref;
          var $useState = $$ctx.$useState;

          return $h\`${template}\`
        }
        `).replace(/export default/g, "return");
  }
  scriptContent = `window.${callbackCreateName} = function () {${scriptContent}}`;
  const scriptEl = document2.createElement("script");
  scriptEl.innerHTML = scriptContent;
  $("head").append(scriptEl);
  const component = window2[callbackCreateName]();
  $(scriptEl).remove();
  window2[callbackCreateName] = null;
  delete window2[callbackCreateName];
  if (style) {
    component.style = style;
  }
  component.id = componentId;
  return component;
}
function registerComponent(tagName2, component) {
  customComponents[tagName2] = component;
}
function unregisterComponent(tagName2) {
  delete customComponents[tagName2];
}
const ComponentModule = {
  name: "component",
  static: {
    Component,
    parseComponent,
    registerComponent,
    unregisterComponent
  },
  create() {
    const app2 = this;
    app2.component = {
      registerComponent,
      unregisterComponent,
      parse(componentString) {
        return parseComponent(componentString);
      },
      create(component, props, _ref) {
        let {
          root,
          el,
          context,
          children: children2
        } = _ref;
        return new Component(app2, component, props, {
          root,
          el,
          context,
          children: children2
        });
      }
    };
  }
};
const HistoryModule = {
  name: "history",
  static: {
    history: History
  },
  on: {
    init() {
      History.init(this);
    }
  }
};
const SW = {
  registrations: [],
  register(path2, scope) {
    const app2 = this;
    const window2 = getWindow();
    if (!("serviceWorker" in window2.navigator) || !app2.serviceWorker.container) {
      return new Promise((resolve, reject) => {
        reject(new Error("Service worker is not supported"));
      });
    }
    return new Promise((resolve, reject) => {
      app2.serviceWorker.container.register(path2, scope ? {
        scope
      } : {}).then((reg) => {
        SW.registrations.push(reg);
        app2.emit("serviceWorkerRegisterSuccess", reg);
        resolve(reg);
      }).catch((error) => {
        app2.emit("serviceWorkerRegisterError", error);
        reject(error);
      });
    });
  },
  unregister(registration) {
    const app2 = this;
    const window2 = getWindow();
    if (!("serviceWorker" in window2.navigator) || !app2.serviceWorker.container) {
      return new Promise((resolve, reject) => {
        reject(new Error("Service worker is not supported"));
      });
    }
    let registrations;
    if (!registration) registrations = SW.registrations;
    else if (Array.isArray(registration)) registrations = registration;
    else registrations = [registration];
    return Promise.all(registrations.map((reg) => new Promise((resolve, reject) => {
      reg.unregister().then(() => {
        if (SW.registrations.indexOf(reg) >= 0) {
          SW.registrations.splice(SW.registrations.indexOf(reg), 1);
        }
        app2.emit("serviceWorkerUnregisterSuccess", reg);
        resolve();
      }).catch((error) => {
        app2.emit("serviceWorkerUnregisterError", reg, error);
        reject(error);
      });
    })));
  }
};
const ServiceWorkerModule = {
  name: "sw",
  params: {
    serviceWorker: {
      path: void 0,
      scope: void 0
    }
  },
  create() {
    const app2 = this;
    const window2 = getWindow();
    extend$1(app2, {
      serviceWorker: {
        container: "serviceWorker" in window2.navigator ? window2.navigator.serviceWorker : void 0,
        registrations: SW.registrations,
        register: SW.register.bind(app2),
        unregister: SW.unregister.bind(app2)
      }
    });
  },
  on: {
    init() {
      const window2 = getWindow();
      if (!("serviceWorker" in window2.navigator)) return;
      const app2 = this;
      if (app2.device.cordova || window2.Capacitor && window2.Capacitor.isNative) return;
      if (!app2.serviceWorker.container) return;
      const paths = app2.params.serviceWorker.path;
      const scope = app2.params.serviceWorker.scope;
      if (!paths || Array.isArray(paths) && !paths.length) return;
      const toRegister = Array.isArray(paths) ? paths : [paths];
      toRegister.forEach((path2) => {
        app2.serviceWorker.register(path2, scope);
      });
    }
  }
};
function createStore(storeParams) {
  if (storeParams === void 0) {
    storeParams = {};
  }
  const store = {
    __store: true
  };
  const originalState = {
    ...storeParams.state || {}
  };
  const actions = {
    ...storeParams.actions || {}
  };
  const getters = {
    ...storeParams.getters || {}
  };
  const state = extend$1({}, originalState);
  let propsQueue = [];
  const gettersDependencies = {};
  const gettersCallbacks = {};
  Object.keys(getters).forEach((getterKey) => {
    gettersDependencies[getterKey] = [];
    gettersCallbacks[getterKey] = [];
  });
  const getGetterValue = (getterKey) => {
    return getters[getterKey]({
      state: store.state
    });
  };
  const addGetterDependencies = (getterKey, deps) => {
    if (!gettersDependencies[getterKey]) gettersDependencies[getterKey] = [];
    deps.forEach((dep) => {
      if (gettersDependencies[getterKey].indexOf(dep) < 0) {
        gettersDependencies[getterKey].push(dep);
      }
    });
  };
  const addGetterCallback = (getterKey, callback) => {
    if (!gettersCallbacks[getterKey]) gettersCallbacks[getterKey] = [];
    gettersCallbacks[getterKey].push(callback);
  };
  const runGetterCallbacks = (stateKey) => {
    const keys = Object.keys(gettersDependencies).filter((getterKey) => {
      return gettersDependencies[getterKey].indexOf(stateKey) >= 0;
    });
    keys.forEach((getterKey) => {
      if (!gettersCallbacks[getterKey] || !gettersCallbacks[getterKey].length) return;
      gettersCallbacks[getterKey].forEach((callback) => {
        callback(getGetterValue(getterKey));
      });
    });
  };
  const removeGetterCallback = (callback) => {
    Object.keys(gettersCallbacks).forEach((stateKey) => {
      const callbacks = gettersCallbacks[stateKey];
      if (callbacks.indexOf(callback) >= 0) {
        callbacks.splice(callbacks.indexOf(callback), 1);
      }
    });
  };
  store.__removeCallback = (callback) => {
    removeGetterCallback(callback);
  };
  const getterValue = function(getterKey, addCallback) {
    if (addCallback === void 0) {
      addCallback = true;
    }
    if (getterKey === "constructor") return void 0;
    propsQueue = [];
    const value2 = getGetterValue(getterKey);
    addGetterDependencies(getterKey, propsQueue);
    const onUpdated = (callback2) => {
      addGetterCallback(getterKey, callback2);
    };
    const obj = {
      value: value2,
      onUpdated
    };
    if (!addCallback) {
      return obj;
    }
    const callback = (v) => {
      obj.value = v;
    };
    obj.__callback = callback;
    addGetterCallback(getterKey, callback);
    return obj;
  };
  store.state = new Proxy(state, {
    set: (target, prop2, value2) => {
      target[prop2] = value2;
      runGetterCallbacks(prop2);
      return true;
    },
    get: (target, prop2) => {
      propsQueue.push(prop2);
      return target[prop2];
    }
  });
  store.getters = new Proxy(getters, {
    set: () => false,
    get: (target, prop2) => {
      if (!target[prop2]) {
        return void 0;
      }
      return getterValue(prop2, true);
    }
  });
  store._gettersPlain = new Proxy(getters, {
    set: () => false,
    get: (target, prop2) => {
      if (!target[prop2]) {
        return void 0;
      }
      return getterValue(prop2, false);
    }
  });
  store.dispatch = (actionName, data2) => {
    return new Promise((resolve, reject) => {
      if (!actions[actionName]) {
        reject();
        throw new Error(`Framework7: Store action "${actionName}" is not found`);
      }
      const result = actions[actionName]({
        state: store.state,
        dispatch: store.dispatch
      }, data2);
      resolve(result);
    });
  };
  return store;
}
const StoreModule = {
  name: "store",
  static: {
    createStore
  },
  proto: {
    createStore
  }
};
const isCapacitor = () => {
  const window2 = getWindow();
  return window2.Capacitor && window2.Capacitor.isNative && window2.Capacitor.Plugins && window2.Capacitor.Plugins.StatusBar;
};
const Statusbar = {
  hide() {
    const window2 = getWindow();
    const device = getDevice();
    if (device.cordova && window2.StatusBar) {
      window2.StatusBar.hide();
    }
    if (isCapacitor()) {
      window2.Capacitor.Plugins.StatusBar.hide();
    }
  },
  show() {
    const window2 = getWindow();
    const device = getDevice();
    if (device.cordova && window2.StatusBar) {
      window2.StatusBar.show();
    }
    if (isCapacitor()) {
      window2.Capacitor.Plugins.StatusBar.show();
    }
  },
  onClick() {
    const app2 = this;
    let pageContent;
    if ($(".popup.modal-in").length > 0) {
      pageContent = $(".popup.modal-in").find(".page:not(.page-previous):not(.page-next):not(.cached)").find(".page-content");
    } else if ($(".panel.panel-in").length > 0) {
      pageContent = $(".panel.panel-in").find(".page:not(.page-previous):not(.page-next):not(.cached)").find(".page-content");
    } else if ($(".views > .view.tab-active").length > 0) {
      pageContent = $(".views > .view.tab-active").find(".page:not(.page-previous):not(.page-next):not(.cached)").find(".page-content");
    } else if ($(".views").length > 0) {
      pageContent = $(".views").find(".page:not(.page-previous):not(.page-next):not(.cached)").find(".page-content");
    } else {
      pageContent = app2.$el.children(".view").find(".page:not(.page-previous):not(.page-next):not(.cached)").find(".page-content");
    }
    if (pageContent && pageContent.length > 0) {
      if (pageContent.hasClass("tab")) {
        pageContent = pageContent.parent(".tabs").children(".page-content.tab-active");
      }
      if (pageContent.length > 0) pageContent.scrollTop(0, 300);
    }
  },
  setTextColor(color) {
    const window2 = getWindow();
    const device = getDevice();
    if (device.cordova && window2.StatusBar) {
      if (color === "white") {
        window2.StatusBar.styleLightContent();
      } else {
        window2.StatusBar.styleDefault();
      }
    }
    if (isCapacitor()) {
      if (color === "white") {
        window2.Capacitor.Plugins.StatusBar.setStyle({
          style: "DARK"
        });
      } else {
        window2.Capacitor.Plugins.StatusBar.setStyle({
          style: "LIGHT"
        });
      }
    }
  },
  setBackgroundColor(color) {
    const window2 = getWindow();
    const device = getDevice();
    if (device.cordova && window2.StatusBar) {
      window2.StatusBar.backgroundColorByHexString(color);
    }
    if (isCapacitor()) {
      window2.Capacitor.Plugins.StatusBar.setBackgroundColor({
        color
      });
    }
  },
  isVisible() {
    const window2 = getWindow();
    const device = getDevice();
    return new Promise((resolve) => {
      if (device.cordova && window2.StatusBar) {
        resolve(window2.StatusBar.isVisible);
      }
      if (isCapacitor()) {
        window2.Capacitor.Plugins.StatusBar.getInfo().then((info) => {
          resolve(info.visible);
        });
      }
      resolve(false);
    });
  },
  overlaysWebView(overlays) {
    if (overlays === void 0) {
      overlays = true;
    }
    const window2 = getWindow();
    const device = getDevice();
    if (device.cordova && window2.StatusBar) {
      window2.StatusBar.overlaysWebView(overlays);
    }
    if (isCapacitor()) {
      window2.Capacitor.Plugins.StatusBar.setOverlaysWebView({
        overlay: overlays
      });
    }
  },
  init() {
    const app2 = this;
    const window2 = getWindow();
    const device = getDevice();
    const params = app2.params.statusbar;
    if (!params.enabled) return;
    const isCordova = device.cordova && window2.StatusBar;
    const isCap = isCapacitor();
    if (isCordova || isCap) {
      if (params.scrollTopOnClick) {
        $(window2).on("statusTap", Statusbar.onClick.bind(app2));
      }
      if (device.ios) {
        if (params.iosOverlaysWebView) {
          Statusbar.overlaysWebView(true);
        } else {
          Statusbar.overlaysWebView(false);
        }
        if (params.iosTextColor === "white") {
          Statusbar.setTextColor("white");
        } else {
          Statusbar.setTextColor("black");
        }
      }
      if (device.android) {
        if (params.androidOverlaysWebView) {
          Statusbar.overlaysWebView(true);
        } else {
          Statusbar.overlaysWebView(false);
        }
        if (params.androidTextColor === "white") {
          Statusbar.setTextColor("white");
        } else {
          Statusbar.setTextColor("black");
        }
      }
    }
    if (params.iosBackgroundColor && device.ios) {
      Statusbar.setBackgroundColor(params.iosBackgroundColor);
    }
    if (params.androidBackgroundColor && device.android) {
      Statusbar.setBackgroundColor(params.androidBackgroundColor);
    }
  }
};
const Statusbar$1 = {
  name: "statusbar",
  params: {
    statusbar: {
      enabled: true,
      scrollTopOnClick: true,
      iosOverlaysWebView: true,
      iosTextColor: "black",
      iosBackgroundColor: null,
      androidOverlaysWebView: false,
      androidTextColor: "black",
      androidBackgroundColor: null
    }
  },
  create() {
    const app2 = this;
    bindMethods(app2, {
      statusbar: Statusbar
    });
  },
  on: {
    init() {
      const app2 = this;
      Statusbar.init.call(app2);
    }
  }
};
function getCurrentView(app2) {
  const $popoverView = $(".popover.modal-in .view");
  const $popupView = $(".popup.modal-in .view");
  const $panelView = $(".panel.panel-in .view");
  let $viewsEl = $(".views");
  if ($viewsEl.length === 0) $viewsEl = app2.$el;
  let $viewEl = $viewsEl.children(".view");
  if ($viewEl.length === 0) {
    $viewEl = $viewsEl.children(".tabs").children(".view");
  }
  if ($viewEl.length > 1) {
    if ($viewEl.hasClass("tab")) {
      $viewEl = $viewsEl.children(".view.tab-active");
      if ($viewEl.length === 0) {
        $viewEl = $viewsEl.children(".tabs").children(".view.tab-active");
      }
    }
  }
  if ($popoverView.length > 0 && $popoverView[0].f7View) return $popoverView[0].f7View;
  if ($popupView.length > 0 && $popupView[0].f7View) return $popupView[0].f7View;
  if ($panelView.length > 0 && $panelView[0].f7View) return $panelView[0].f7View;
  if ($viewEl.length > 0) {
    if ($viewEl.length === 1 && $viewEl[0].f7View) return $viewEl[0].f7View;
    if ($viewEl.length > 1) {
      return app2.views.main;
    }
  }
  return void 0;
}
const View$1 = {
  name: "view",
  params: {
    view: {
      init: true,
      initRouterOnTabShow: false,
      name: void 0,
      main: false,
      router: true,
      linksView: null,
      xhrCache: true,
      xhrCacheIgnore: [],
      xhrCacheIgnoreGetParameters: false,
      xhrCacheDuration: 1e3 * 60 * 10,
      // Ten minutes
      componentCache: true,
      preloadPreviousPage: true,
      allowDuplicateUrls: false,
      reloadPages: false,
      reloadDetail: false,
      masterDetailBreakpoint: 0,
      masterDetailResizable: false,
      removeElements: true,
      removeElementsWithTimeout: false,
      removeElementsTimeout: 0,
      restoreScrollTopOnBack: true,
      unloadTabContent: true,
      passRouteQueryToRequest: true,
      passRouteParamsToRequest: false,
      loadInitialPage: true,
      // Swipe Back
      iosSwipeBack: true,
      iosSwipeBackAnimateShadow: true,
      iosSwipeBackAnimateOpacity: true,
      iosSwipeBackActiveArea: 30,
      iosSwipeBackThreshold: 0,
      mdSwipeBack: false,
      mdSwipeBackAnimateShadow: true,
      mdSwipeBackAnimateOpacity: false,
      mdSwipeBackActiveArea: 30,
      mdSwipeBackThreshold: 0,
      // Push State
      browserHistory: false,
      browserHistoryRoot: void 0,
      browserHistoryAnimate: true,
      browserHistoryAnimateOnLoad: false,
      browserHistorySeparator: "#!",
      browserHistoryOnLoad: true,
      browserHistoryInitialMatch: false,
      browserHistoryStoreHistory: true,
      browserHistoryTabs: "replace",
      // Animate Pages
      animate: true,
      // iOS Dynamic Navbar
      iosDynamicNavbar: true,
      // Animate iOS Navbar Back Icon
      iosAnimateNavbarBackIcon: true,
      // Delays
      iosPageLoadDelay: 0,
      mdPageLoadDelay: 0,
      // Routes hooks
      routesBeforeEnter: null,
      routesBeforeLeave: null
    }
  },
  static: {
    View: View$2
  },
  create() {
    const app2 = this;
    extend$1(app2, {
      views: extend$1([], {
        create(el, params) {
          return new View$2(app2, el, params);
        },
        get(viewEl) {
          const $viewEl = $(viewEl);
          if ($viewEl.length && $viewEl[0].f7View) return $viewEl[0].f7View;
          return void 0;
        }
      })
    });
    Object.defineProperty(app2.views, "current", {
      enumerable: true,
      configurable: true,
      get() {
        return getCurrentView(app2);
      }
    });
    app2.view = app2.views;
  },
  on: {
    init() {
      const app2 = this;
      $(".view-init").each((viewEl) => {
        if (viewEl.f7View) return;
        const viewParams = $(viewEl).dataset();
        app2.views.create(viewEl, viewParams);
      });
    },
    "modalOpen panelOpen": function onOpen(instance2) {
      const app2 = this;
      instance2.$el.find(".view-init").each((viewEl) => {
        if (viewEl.f7View) return;
        const viewParams = $(viewEl).dataset();
        app2.views.create(viewEl, viewParams);
      });
    },
    "modalBeforeDestroy panelBeforeDestroy": function onClose(instance2) {
      if (!instance2 || !instance2.$el) return;
      instance2.$el.find(".view-init").each((viewEl) => {
        const view = viewEl.f7View;
        if (!view) return;
        view.destroy();
      });
    }
  },
  vnode: {
    "view-init": {
      insert(vnode2) {
        const app2 = this;
        const viewEl = vnode2.elm;
        if (viewEl.f7View) return;
        const viewParams = $(viewEl).dataset();
        app2.views.create(viewEl, viewParams);
      },
      destroy(vnode2) {
        const viewEl = vnode2.elm;
        const view = viewEl.f7View;
        if (!view) return;
        view.destroy();
      }
    }
  }
};
const Navbar$1 = {
  size(el) {
    const app2 = this;
    let $el = $(el);
    if ($el.hasClass("navbars")) {
      $el = $el.children(".navbar").each((navbarEl) => {
        app2.navbar.size(navbarEl);
      });
      return;
    }
    const $innerEl = $el.children(".navbar-inner");
    if (!$innerEl.length) return;
    const needCenterTitle = $innerEl.hasClass("navbar-inner-centered-title") || app2.params.navbar[`${app2.theme}CenterTitle`];
    const needLeftTitle = app2.theme === "ios" && !app2.params.navbar[`${app2.theme}CenterTitle`];
    if (!needCenterTitle && !needLeftTitle) return;
    if ($el.parents(".tab:not(.tab-active)").length > 0 || $el.parents(".popup:not(.modal-in)").length > 0) {
      return;
    }
    if (app2.theme !== "ios" && app2.params.navbar[`${app2.theme}CenterTitle`]) {
      $innerEl.addClass("navbar-inner-centered-title");
    }
    if (app2.theme === "ios" && !app2.params.navbar.iosCenterTitle) {
      $innerEl.addClass("navbar-inner-left-title");
    }
    const $viewEl = $el.parents(".view").eq(0);
    const left = app2.rtl ? $innerEl.children(".right") : $innerEl.children(".left");
    const right = app2.rtl ? $innerEl.children(".left") : $innerEl.children(".right");
    const title = $innerEl.children(".title");
    const subnavbar = $innerEl.children(".subnavbar");
    const noLeft = left.length === 0;
    const noRight = right.length === 0;
    const leftWidth = noLeft ? 0 : left.outerWidth(true);
    const rightWidth = noRight ? 0 : right.outerWidth(true);
    const titleWidth = title.outerWidth(true);
    const navbarStyles = $innerEl.styles();
    const navbarWidth = $innerEl[0].offsetWidth;
    const navbarInnerWidth = navbarWidth - parseInt(navbarStyles.paddingLeft, 10) - parseInt(navbarStyles.paddingRight, 10);
    const isPrevious = $el.hasClass("navbar-previous");
    const sliding = $innerEl.hasClass("sliding");
    let router;
    let dynamicNavbar;
    if ($viewEl.length > 0 && $viewEl[0].f7View) {
      router = $viewEl[0].f7View.router;
      dynamicNavbar = router && router.dynamicNavbar;
    }
    let currLeft;
    let diff;
    if (noRight) {
      currLeft = navbarInnerWidth - titleWidth;
    }
    if (noLeft) {
      currLeft = 0;
    }
    if (!noLeft && !noRight) {
      currLeft = (navbarInnerWidth - rightWidth - titleWidth + leftWidth) / 2;
    }
    let requiredLeft = (navbarInnerWidth - titleWidth) / 2;
    if (navbarInnerWidth - leftWidth - rightWidth > titleWidth) {
      if (requiredLeft < leftWidth) {
        requiredLeft = leftWidth;
      }
      if (requiredLeft + titleWidth > navbarInnerWidth - rightWidth) {
        requiredLeft = navbarInnerWidth - rightWidth - titleWidth;
      }
      diff = requiredLeft - currLeft;
    } else {
      diff = 0;
    }
    const inverter = app2.rtl ? -1 : 1;
    if (dynamicNavbar && app2.theme === "ios") {
      if (title.hasClass("sliding") || title.length > 0 && sliding) {
        let titleLeftOffset = -(currLeft + diff) * inverter;
        const titleRightOffset = (navbarInnerWidth - currLeft - diff - titleWidth) * inverter;
        if (isPrevious) {
          if (router && router.params.iosAnimateNavbarBackIcon) {
            const activeNavbarBackLink = $el.parent().find(".navbar-current").children(".left.sliding").find(".back .icon ~ span");
            if (activeNavbarBackLink.length > 0) {
              titleLeftOffset += activeNavbarBackLink[0].offsetLeft;
            }
          }
        }
        title[0].f7NavbarLeftOffset = titleLeftOffset;
        title[0].f7NavbarRightOffset = titleRightOffset;
      }
      if (!noLeft && (left.hasClass("sliding") || sliding)) {
        if (app2.rtl) {
          left[0].f7NavbarLeftOffset = -(navbarInnerWidth - left[0].offsetWidth) / 2 * inverter;
          left[0].f7NavbarRightOffset = leftWidth * inverter;
        } else {
          left[0].f7NavbarLeftOffset = -leftWidth;
          left[0].f7NavbarRightOffset = (navbarInnerWidth - left[0].offsetWidth) / 2;
          if (router && router.params.iosAnimateNavbarBackIcon && left.find(".back .icon").length > 0) {
            if (left.find(".back .icon ~ span").length) {
              const leftOffset = left[0].f7NavbarLeftOffset;
              const rightOffset = left[0].f7NavbarRightOffset;
              left[0].f7NavbarLeftOffset = 0;
              left[0].f7NavbarRightOffset = 0;
              left.find(".back .icon ~ span")[0].f7NavbarLeftOffset = leftOffset;
              left.find(".back .icon ~ span")[0].f7NavbarRightOffset = rightOffset - left.find(".back .icon")[0].offsetWidth;
            }
          }
        }
      }
      if (!noRight && (right.hasClass("sliding") || sliding)) {
        if (app2.rtl) {
          right[0].f7NavbarLeftOffset = -rightWidth * inverter;
          right[0].f7NavbarRightOffset = (navbarInnerWidth - right[0].offsetWidth) / 2 * inverter;
        } else {
          right[0].f7NavbarLeftOffset = -(navbarInnerWidth - right[0].offsetWidth) / 2;
          right[0].f7NavbarRightOffset = rightWidth;
        }
      }
      if (subnavbar.length && (subnavbar.hasClass("sliding") || sliding)) {
        subnavbar[0].f7NavbarLeftOffset = app2.rtl ? subnavbar[0].offsetWidth : -subnavbar[0].offsetWidth;
        subnavbar[0].f7NavbarRightOffset = -subnavbar[0].f7NavbarLeftOffset;
      }
    }
    if (needCenterTitle) {
      let titleLeft = diff;
      if (app2.rtl && noLeft && noRight && title.length > 0) titleLeft = -titleLeft;
      title.css({
        left: `${titleLeft}px`
      });
    }
  },
  hide(el, animate2, hideStatusbar, hideOnlyCurrent) {
    if (animate2 === void 0) {
      animate2 = true;
    }
    if (hideStatusbar === void 0) {
      hideStatusbar = false;
    }
    if (hideOnlyCurrent === void 0) {
      hideOnlyCurrent = false;
    }
    const app2 = this;
    let $el = $(el);
    const isDynamic = $el.hasClass("navbar") && $el.parent(".navbars").length && !hideOnlyCurrent;
    if (isDynamic) $el = $el.parents(".navbars");
    if (!$el.length) return;
    if ($el.hasClass("navbar-hidden")) return;
    let className = `navbar-hidden${animate2 ? " navbar-transitioning" : ""}`;
    const currentIsLarge = isDynamic ? $el.find(".navbar-current .title-large").length : $el.find(".title-large").length;
    if (currentIsLarge) {
      className += " navbar-large-hidden";
    }
    if (hideStatusbar) {
      className += " navbar-hidden-statusbar";
    }
    $el.transitionEnd(() => {
      $el.removeClass("navbar-transitioning");
    });
    $el.addClass(className);
    if (isDynamic) {
      $el.children(".navbar").each((subEl) => {
        $(subEl).trigger("navbar:hide");
        app2.emit("navbarHide", subEl);
      });
    } else {
      $el.trigger("navbar:hide");
      app2.emit("navbarHide", $el[0]);
    }
  },
  show(el, animate2, hideOnlyCurrent) {
    if (el === void 0) {
      el = ".navbar-hidden";
    }
    if (animate2 === void 0) {
      animate2 = true;
    }
    if (hideOnlyCurrent === void 0) {
      hideOnlyCurrent = false;
    }
    const app2 = this;
    let $el = $(el);
    const isDynamic = $el.hasClass("navbar") && $el.parent(".navbars").length && !hideOnlyCurrent;
    if (isDynamic) $el = $el.parents(".navbars");
    if (!$el.length) return;
    if (!$el.hasClass("navbar-hidden")) return;
    if (animate2) {
      $el.addClass("navbar-transitioning");
      $el.transitionEnd(() => {
        $el.removeClass("navbar-transitioning");
      });
    }
    $el.removeClass("navbar-hidden navbar-large-hidden navbar-hidden-statusbar");
    if (isDynamic) {
      $el.children(".navbar").each((subEl) => {
        $(subEl).trigger("navbar:show");
        app2.emit("navbarShow", subEl);
      });
    } else {
      $el.trigger("navbar:show");
      app2.emit("navbarShow", $el[0]);
    }
  },
  getElByPage(page) {
    let $pageEl;
    let $navbarEl;
    let pageData;
    if (page.$navbarEl || page.$el) {
      pageData = page;
      $pageEl = page.$el;
    } else {
      $pageEl = $(page);
      if ($pageEl.length > 0) pageData = $pageEl[0].f7Page;
    }
    if (pageData && pageData.$navbarEl && pageData.$navbarEl.length > 0) {
      $navbarEl = pageData.$navbarEl;
    } else if ($pageEl) {
      $navbarEl = $pageEl.children(".navbar");
    }
    if (!$navbarEl || $navbarEl && $navbarEl.length === 0) return void 0;
    return $navbarEl[0];
  },
  getPageByEl(navbarEl) {
    const $navbarEl = $(navbarEl);
    if ($navbarEl.parents(".page").length) {
      return $navbarEl.parents(".page")[0];
    }
    let pageEl;
    $navbarEl.parents(".view").find(".page").each((el) => {
      if (el && el.f7Page && el.f7Page.navbarEl && $navbarEl[0] === el.f7Page.navbarEl) {
        pageEl = el;
      }
    });
    return pageEl;
  },
  collapseLargeTitle(navbarEl) {
    const app2 = this;
    let $navbarEl = $(navbarEl);
    if ($navbarEl.hasClass("navbars")) {
      $navbarEl = $navbarEl.find(".navbar");
      if ($navbarEl.length > 1) {
        $navbarEl = $(navbarEl).find(".navbar-large.navbar-current");
      }
      if ($navbarEl.length > 1 || !$navbarEl.length) {
        return;
      }
    }
    const $pageEl = $(app2.navbar.getPageByEl($navbarEl));
    $navbarEl.addClass("navbar-large-collapsed");
    $pageEl.eq(0).addClass("page-with-navbar-large-collapsed").trigger("page:navbarlargecollapsed");
    app2.emit("pageNavbarLargeCollapsed", $pageEl[0]);
    $navbarEl.trigger("navbar:collapse");
    app2.emit("navbarCollapse", $navbarEl[0]);
  },
  expandLargeTitle(navbarEl) {
    const app2 = this;
    let $navbarEl = $(navbarEl);
    if ($navbarEl.hasClass("navbars")) {
      $navbarEl = $navbarEl.find(".navbar-large");
      if ($navbarEl.length > 1) {
        $navbarEl = $(navbarEl).find(".navbar-large.navbar-current");
      }
      if ($navbarEl.length > 1 || !$navbarEl.length) {
        return;
      }
    }
    const $pageEl = $(app2.navbar.getPageByEl($navbarEl));
    $navbarEl.removeClass("navbar-large-collapsed");
    $pageEl.eq(0).removeClass("page-with-navbar-large-collapsed").trigger("page:navbarlargeexpanded");
    app2.emit("pageNavbarLargeExpanded", $pageEl[0]);
    $navbarEl.trigger("navbar:expand");
    app2.emit("navbarExpand", $navbarEl[0]);
  },
  toggleLargeTitle(navbarEl) {
    const app2 = this;
    let $navbarEl = $(navbarEl);
    if ($navbarEl.hasClass("navbars")) {
      $navbarEl = $navbarEl.find(".navbar-large");
      if ($navbarEl.length > 1) {
        $navbarEl = $(navbarEl).find(".navbar-large.navbar-current");
      }
      if ($navbarEl.length > 1 || !$navbarEl.length) {
        return;
      }
    }
    if ($navbarEl.hasClass("navbar-large-collapsed")) {
      app2.navbar.expandLargeTitle($navbarEl);
    } else {
      app2.navbar.collapseLargeTitle($navbarEl);
    }
  },
  initNavbarOnScroll(pageEl, navbarEl, needHide, needCollapse, needTransparent) {
    const app2 = this;
    const support2 = getSupport();
    const $pageEl = $(pageEl);
    const $navbarEl = $(navbarEl);
    const $titleLargeEl = $navbarEl.find(".title-large");
    const isLarge = $titleLargeEl.length || $navbarEl.hasClass(".navbar-large");
    let navbarHideHeight = 44;
    const snapPageScrollToLargeTitle = app2.params.navbar.snapPageScrollToLargeTitle;
    const snapPageScrollToTransparentNavbar = app2.params.navbar.snapPageScrollToTransparentNavbar;
    let previousScrollTop;
    let currentScrollTop;
    let scrollHeight;
    let offsetHeight;
    let reachEnd;
    let action;
    let navbarHidden;
    let navbarCollapsed;
    let navbarTitleLargeHeight;
    let navbarOffsetHeight;
    if (needCollapse || needHide && isLarge) {
      navbarTitleLargeHeight = $navbarEl.css("--f7-navbar-large-title-height");
      if (navbarTitleLargeHeight && navbarTitleLargeHeight.indexOf("px") >= 0) {
        navbarTitleLargeHeight = parseInt(navbarTitleLargeHeight, 10);
        if (Number.isNaN(navbarTitleLargeHeight) && $titleLargeEl.length) {
          navbarTitleLargeHeight = $titleLargeEl[0].offsetHeight;
        } else if (Number.isNaN(navbarTitleLargeHeight)) {
          if (app2.theme === "ios") navbarTitleLargeHeight = 52;
          else if (app2.theme === "md") navbarTitleLargeHeight = 88;
        }
      } else if ($titleLargeEl.length) {
        navbarTitleLargeHeight = $titleLargeEl[0].offsetHeight;
      } else {
        if (app2.theme === "ios") navbarTitleLargeHeight = 52;
        else if (app2.theme === "md") navbarTitleLargeHeight = 88;
      }
    }
    if (needHide && isLarge) {
      navbarHideHeight += navbarTitleLargeHeight;
    }
    let scrollChanged;
    let scrollContent;
    let scrollTimeoutId;
    let touchEndTimeoutId;
    const touchSnapTimeout = 70;
    const desktopSnapTimeout = 300;
    function calcScrollableDistance() {
      $pageEl.find(".page-content").each((pageContentEl) => {
        pageContentEl.f7ScrollableDistance = pageContentEl.scrollHeight - pageContentEl.offsetHeight;
      });
    }
    function snapLargeNavbar() {
      const inSearchbarExpanded = $navbarEl.hasClass("with-searchbar-expandable-enabled");
      if (inSearchbarExpanded) return;
      if (!scrollContent || currentScrollTop < 0) return;
      if (currentScrollTop >= navbarTitleLargeHeight / 2 && currentScrollTop < navbarTitleLargeHeight) {
        $(scrollContent).scrollTop(navbarTitleLargeHeight, 100);
      } else if (currentScrollTop < navbarTitleLargeHeight) {
        $(scrollContent).scrollTop(0, 200);
      }
    }
    function snapTransparentNavbar() {
      const inSearchbarExpanded = $navbarEl.hasClass("with-searchbar-expandable-enabled");
      if (inSearchbarExpanded) return;
      if (!scrollContent || currentScrollTop < 0) return;
      if (currentScrollTop >= navbarOffsetHeight / 2 && currentScrollTop < navbarOffsetHeight) {
        $(scrollContent).scrollTop(navbarOffsetHeight, 100);
      } else if (currentScrollTop < navbarOffsetHeight) {
        $(scrollContent).scrollTop(0, 200);
      }
    }
    function handleNavbarTransparent() {
      const isHidden = $navbarEl.hasClass("navbar-hidden") || $navbarEl.parent(".navbars").hasClass("navbar-hidden");
      const inSearchbarExpanded = $navbarEl.hasClass("with-searchbar-expandable-enabled");
      if (inSearchbarExpanded || isHidden) return;
      if (!navbarOffsetHeight) {
        navbarOffsetHeight = navbarEl.offsetHeight;
      }
      let opacity = currentScrollTop / navbarOffsetHeight;
      const notTransparent = $navbarEl.hasClass("navbar-transparent-visible");
      opacity = Math.max(Math.min(opacity, 1), 0);
      if (notTransparent && opacity === 1 || !notTransparent && opacity === 0) {
        $navbarEl.find(".navbar-bg, .title").css("opacity", "");
        return;
      }
      if (notTransparent && opacity === 0) {
        $navbarEl.trigger("navbar:transparenthide");
        app2.emit("navbarTransparentHide", $navbarEl[0]);
        $navbarEl.removeClass("navbar-transparent-visible");
        $navbarEl.find(".navbar-bg, .title").css("opacity", "");
        return;
      }
      if (!notTransparent && opacity === 1) {
        $navbarEl.trigger("navbar:transparentshow");
        app2.emit("navbarTransparentShow", $navbarEl[0]);
        $navbarEl.addClass("navbar-transparent-visible");
        $navbarEl.find(".navbar-bg, .title").css("opacity", "");
        return;
      }
      $navbarEl.find(".navbar-bg, .title").css("opacity", opacity);
      if (snapPageScrollToTransparentNavbar) {
        if (!support2.touch) {
          clearTimeout(scrollTimeoutId);
          scrollTimeoutId = setTimeout(() => {
            snapTransparentNavbar();
          }, desktopSnapTimeout);
        } else if (touchEndTimeoutId) {
          clearTimeout(touchEndTimeoutId);
          touchEndTimeoutId = null;
          touchEndTimeoutId = setTimeout(() => {
            snapTransparentNavbar();
            clearTimeout(touchEndTimeoutId);
            touchEndTimeoutId = null;
          }, touchSnapTimeout);
        }
      }
    }
    let previousCollapseProgress = null;
    let collapseProgress = null;
    function handleLargeNavbarCollapse(pageContentEl) {
      const isHidden = $navbarEl.hasClass("navbar-hidden") || $navbarEl.parent(".navbars").hasClass("navbar-hidden");
      if (isHidden) return;
      const isLargeTransparent = $navbarEl.hasClass("navbar-large-transparent") || $navbarEl.hasClass("navbar-large") && $navbarEl.hasClass("navbar-transparent");
      previousCollapseProgress = collapseProgress;
      const scrollableDistance = Math.min(navbarTitleLargeHeight, pageContentEl.f7ScrollableDistance || navbarTitleLargeHeight);
      collapseProgress = Math.min(Math.max(currentScrollTop / scrollableDistance, 0), 1);
      const previousCollapseWasInMiddle = previousCollapseProgress > 0 && previousCollapseProgress < 1;
      const inSearchbarExpanded = $navbarEl.hasClass("with-searchbar-expandable-enabled");
      if (inSearchbarExpanded) return;
      navbarCollapsed = $navbarEl.hasClass("navbar-large-collapsed");
      const $bgEl = $navbarEl.find(".navbar-bg");
      if (collapseProgress === 0 && navbarCollapsed) {
        app2.navbar.expandLargeTitle($navbarEl[0]);
      } else if (collapseProgress === 1 && !navbarCollapsed) {
        app2.navbar.collapseLargeTitle($navbarEl[0]);
      }
      if (collapseProgress === 0 && navbarCollapsed || collapseProgress === 0 && previousCollapseWasInMiddle || collapseProgress === 1 && !navbarCollapsed || collapseProgress === 1 && previousCollapseWasInMiddle) {
        if (app2.theme === "md") {
          $navbarEl.find(".navbar-inner").css("overflow", "");
        }
        $navbarEl.find(".title").css("opacity", "");
        $navbarEl.find(".title-large-text, .subnavbar").css("transform", "");
        $navbarEl.find(".title-large-text").css("opacity", "");
        if (isLargeTransparent) {
          $bgEl.css("opacity", "");
        }
        $bgEl.css("transform", "");
      } else if (collapseProgress > 0 && collapseProgress < 1) {
        if (app2.theme === "md") {
          $navbarEl.find(".navbar-inner").css("overflow", "visible");
        }
        $navbarEl.find(".title").css("opacity", -0.5 + collapseProgress * 1.5);
        $navbarEl.find(".title-large-text, .subnavbar").css("transform", `translate3d(0px, ${-1 * collapseProgress * navbarTitleLargeHeight}px, 0)`);
        $navbarEl.find(".title-large-text").css("opacity", 1 - collapseProgress * 2);
        if (isLargeTransparent) {
          $bgEl.css("opacity", collapseProgress);
        }
        $bgEl.css("transform", `translate3d(0px, ${-1 * collapseProgress * navbarTitleLargeHeight}px, 0)`);
      }
      if (snapPageScrollToLargeTitle) {
        if (!support2.touch) {
          clearTimeout(scrollTimeoutId);
          scrollTimeoutId = setTimeout(() => {
            snapLargeNavbar();
          }, desktopSnapTimeout);
        } else if (touchEndTimeoutId) {
          clearTimeout(touchEndTimeoutId);
          touchEndTimeoutId = null;
          touchEndTimeoutId = setTimeout(() => {
            snapLargeNavbar();
            clearTimeout(touchEndTimeoutId);
            touchEndTimeoutId = null;
          }, touchSnapTimeout);
        }
      }
    }
    function handleTitleHideShow() {
      if ($pageEl.hasClass("page-with-card-opened")) return;
      scrollHeight = scrollContent.scrollHeight;
      offsetHeight = scrollContent.offsetHeight;
      reachEnd = currentScrollTop + offsetHeight >= scrollHeight;
      navbarHidden = $navbarEl.hasClass("navbar-hidden") || $navbarEl.parent(".navbars").hasClass("navbar-hidden");
      if (reachEnd) {
        if (app2.params.navbar.showOnPageScrollEnd) {
          action = "show";
        }
      } else if (previousScrollTop > currentScrollTop) {
        if (app2.params.navbar.showOnPageScrollTop || currentScrollTop <= navbarHideHeight) {
          action = "show";
        } else {
          action = "hide";
        }
      } else if (currentScrollTop > navbarHideHeight) {
        action = "hide";
      } else {
        action = "show";
      }
      if (action === "show" && navbarHidden) {
        app2.navbar.show($navbarEl, true, true);
        navbarHidden = false;
      } else if (action === "hide" && !navbarHidden) {
        app2.navbar.hide($navbarEl, true, false, true);
        navbarHidden = true;
      }
      previousScrollTop = currentScrollTop;
    }
    function handleScroll(e) {
      scrollContent = this;
      if (e && e.target && e.target !== scrollContent) {
        return;
      }
      currentScrollTop = scrollContent.scrollTop;
      scrollChanged = currentScrollTop;
      if (needCollapse) {
        handleLargeNavbarCollapse(scrollContent);
      } else if (needTransparent) {
        handleNavbarTransparent();
      }
      if ($pageEl.hasClass("page-previous")) return;
      if (needHide) {
        handleTitleHideShow();
      }
    }
    function handeTouchStart() {
      scrollChanged = false;
    }
    function handleTouchEnd() {
      clearTimeout(touchEndTimeoutId);
      touchEndTimeoutId = null;
      touchEndTimeoutId = setTimeout(() => {
        if (scrollChanged !== false) {
          if (needTransparent && !needCollapse) {
            snapTransparentNavbar();
          } else {
            snapLargeNavbar();
          }
          clearTimeout(touchEndTimeoutId);
          touchEndTimeoutId = null;
        }
      }, touchSnapTimeout);
    }
    $pageEl.on("scroll", ".page-content", handleScroll, true);
    if (support2.touch && (needCollapse && snapPageScrollToLargeTitle || needTransparent && snapPageScrollToTransparentNavbar)) {
      app2.on("touchstart:passive", handeTouchStart);
      app2.on("touchend:passive", handleTouchEnd);
    }
    calcScrollableDistance();
    if (needCollapse || needTransparent) {
      $pageEl.find(".page-content").each((pageContentEl) => {
        if (pageContentEl.scrollTop > 0) handleScroll.call(pageContentEl);
      });
    }
    app2.on("resize", calcScrollableDistance);
    $pageEl[0].f7DetachNavbarScrollHandlers = function f7DetachNavbarScrollHandlers() {
      app2.off("resize", calcScrollableDistance);
      delete $pageEl[0].f7DetachNavbarScrollHandlers;
      $pageEl.off("scroll", ".page-content", handleScroll, true);
      if (support2.touch && (needCollapse && snapPageScrollToLargeTitle || needTransparent && snapPageScrollToTransparentNavbar)) {
        app2.off("touchstart:passive", handeTouchStart);
        app2.off("touchend:passive", handleTouchEnd);
      }
    };
  }
};
const Navbar$2 = {
  name: "navbar",
  create() {
    const app2 = this;
    bindMethods(app2, {
      navbar: Navbar$1
    });
  },
  params: {
    navbar: {
      scrollTopOnTitleClick: true,
      iosCenterTitle: true,
      mdCenterTitle: false,
      hideOnPageScroll: false,
      showOnPageScrollEnd: true,
      showOnPageScrollTop: true,
      collapseLargeTitleOnScroll: true,
      snapPageScrollToLargeTitle: true,
      snapPageScrollToTransparentNavbar: true
    }
  },
  on: {
    "panelBreakpoint panelCollapsedBreakpoint panelResize viewResize resize viewMasterDetailBreakpoint": function onPanelResize() {
      const app2 = this;
      $(".navbar").each((navbarEl) => {
        app2.navbar.size(navbarEl);
      });
    },
    pageBeforeRemove(page) {
      if (page.$el[0].f7DetachNavbarScrollHandlers) {
        page.$el[0].f7DetachNavbarScrollHandlers();
      }
    },
    pageBeforeIn(page) {
      const app2 = this;
      if (app2.theme !== "ios") return;
      let $navbarsEl;
      const view = page.$el.parents(".view")[0].f7View;
      const navbarEl = app2.navbar.getElByPage(page);
      if (!navbarEl) {
        $navbarsEl = page.$el.parents(".view").children(".navbars");
      } else {
        $navbarsEl = $(navbarEl).parents(".navbars");
      }
      if (page.$el.hasClass("no-navbar") || view.router.dynamicNavbar && !navbarEl) {
        const animate2 = !!(page.pageFrom && page.router.history.length > 0);
        app2.navbar.hide($navbarsEl, animate2);
      } else {
        app2.navbar.show($navbarsEl);
      }
    },
    pageReinit(page) {
      const app2 = this;
      const $navbarEl = $(app2.navbar.getElByPage(page));
      if (!$navbarEl || $navbarEl.length === 0) return;
      app2.navbar.size($navbarEl);
    },
    pageInit(page) {
      const app2 = this;
      const $navbarEl = $(app2.navbar.getElByPage(page));
      if (!$navbarEl || $navbarEl.length === 0) return;
      app2.navbar.size($navbarEl);
      let needCollapseOnScrollHandler;
      if ($navbarEl.find(".title-large").length > 0) {
        $navbarEl.addClass("navbar-large");
      }
      if ($navbarEl.hasClass("navbar-large")) {
        if (app2.params.navbar.collapseLargeTitleOnScroll) needCollapseOnScrollHandler = true;
        page.$el.addClass("page-with-navbar-large");
      }
      let needTransparentOnScroll;
      if (!needCollapseOnScrollHandler && $navbarEl.hasClass("navbar-transparent")) {
        needTransparentOnScroll = true;
      }
      let needHideOnScrollHandler;
      if (app2.params.navbar.hideOnPageScroll || page.$el.find(".hide-navbar-on-scroll").length || page.$el.hasClass("hide-navbar-on-scroll") || page.$el.find(".hide-bars-on-scroll").length || page.$el.hasClass("hide-bars-on-scroll")) {
        if (page.$el.find(".keep-navbar-on-scroll").length || page.$el.hasClass("keep-navbar-on-scroll") || page.$el.find(".keep-bars-on-scroll").length || page.$el.hasClass("keep-bars-on-scroll")) {
          needHideOnScrollHandler = false;
        } else {
          needHideOnScrollHandler = true;
        }
      }
      if (needCollapseOnScrollHandler || needHideOnScrollHandler || needTransparentOnScroll) {
        app2.navbar.initNavbarOnScroll(page.el, $navbarEl[0], needHideOnScrollHandler, needCollapseOnScrollHandler, needTransparentOnScroll);
      }
    },
    "panelOpen panelSwipeOpen modalOpen": function onPanelModalOpen(instance2) {
      const app2 = this;
      instance2.$el.find(".navbar:not(.navbar-previous)").each((navbarEl) => {
        app2.navbar.size(navbarEl);
      });
    },
    tabShow(tabEl) {
      const app2 = this;
      $(tabEl).find(".navbar:not(.navbar-previous)").each((navbarEl) => {
        app2.navbar.size(navbarEl);
      });
    }
  },
  clicks: {
    ".navbar .title": function onTitleClick($clickedEl, clickedData, e) {
      const app2 = this;
      if (!app2.params.navbar.scrollTopOnTitleClick) return;
      if ($(e.target).closest("a, button").length > 0) {
        return;
      }
      let $pageContentEl;
      const $navbarEl = $clickedEl.parents(".navbar");
      const $navbarsEl = $navbarEl.parents(".navbars");
      $pageContentEl = $navbarEl.parents(".page-content");
      if ($pageContentEl.length === 0) {
        if ($navbarEl.parents(".page").length > 0) {
          $pageContentEl = $navbarEl.parents(".page").find(".page-content");
        }
        if ($pageContentEl.length === 0 && $navbarsEl.length) {
          if ($navbarsEl.nextAll(".page-current").length > 0) {
            $pageContentEl = $navbarsEl.nextAll(".page-current").find(".page-content");
          }
        }
        if ($pageContentEl.length === 0) {
          if ($navbarEl.nextAll(".page-current").length > 0) {
            $pageContentEl = $navbarEl.nextAll(".page-current").find(".page-content");
          }
        }
      }
      if ($pageContentEl && $pageContentEl.length > 0) {
        if ($pageContentEl.hasClass("tab")) {
          $pageContentEl = $pageContentEl.parent(".tabs").children(".page-content.tab-active");
        }
        if ($pageContentEl.length > 0) $pageContentEl.scrollTop(0, 300);
      }
    }
  },
  vnode: {
    navbar: {
      postpatch(vnode2) {
        const app2 = this;
        app2.navbar.size(vnode2.elm);
      }
    }
  }
};
const Toolbar = {
  setHighlight(tabbarEl) {
    const app2 = this;
    const $tabbarEl = $(tabbarEl);
    if (app2.theme === "ios" && !$tabbarEl.hasClass("tabbar-highlight")) return;
    if ($tabbarEl.length === 0 || !($tabbarEl.hasClass("tabbar") || $tabbarEl.hasClass("tabbar-icons"))) return;
    let $highlightEl = $tabbarEl.find(".tab-link-highlight");
    const tabLinksCount = $tabbarEl.find(".tab-link").length;
    if (tabLinksCount === 0) {
      $highlightEl.remove();
      return;
    }
    if ($highlightEl.length === 0) {
      $tabbarEl.children(".toolbar-inner").append('<span class="tab-link-highlight"></span>');
      $highlightEl = $tabbarEl.find(".tab-link-highlight");
    } else if ($highlightEl.next().length) {
      $tabbarEl.children(".toolbar-inner").append($highlightEl);
    }
    const $activeLink = $tabbarEl.find(".tab-link-active");
    let highlightWidth;
    let highlightTranslate;
    if ($tabbarEl.hasClass("tabbar-scrollable") && $activeLink && $activeLink[0]) {
      highlightWidth = `${$activeLink[0].offsetWidth}px`;
      highlightTranslate = `${$activeLink[0].offsetLeft}px`;
    } else {
      const activeIndex = $activeLink.index();
      highlightWidth = `${100 / tabLinksCount}%`;
      highlightTranslate = `${(app2.rtl ? -activeIndex : activeIndex) * 100}%`;
    }
    nextFrame$1(() => {
      $highlightEl.css("width", highlightWidth).transform(`translate3d(${highlightTranslate},0,0)`);
    });
  },
  init(tabbarEl) {
    const app2 = this;
    app2.toolbar.setHighlight(tabbarEl);
  },
  hide(el, animate2) {
    if (animate2 === void 0) {
      animate2 = true;
    }
    const app2 = this;
    const $el = $(el);
    if ($el.hasClass("toolbar-hidden")) return;
    const className = `toolbar-hidden${animate2 ? " toolbar-transitioning" : ""}`;
    $el.transitionEnd(() => {
      $el.removeClass("toolbar-transitioning");
    });
    $el.addClass(className);
    $el.trigger("toolbar:hide");
    app2.emit("toolbarHide", $el[0]);
  },
  show(el, animate2) {
    if (animate2 === void 0) {
      animate2 = true;
    }
    const app2 = this;
    const $el = $(el);
    if (!$el.hasClass("toolbar-hidden")) return;
    if (animate2) {
      $el.addClass("toolbar-transitioning");
      $el.transitionEnd(() => {
        $el.removeClass("toolbar-transitioning");
      });
    }
    $el.removeClass("toolbar-hidden");
    $el.trigger("toolbar:show");
    app2.emit("toolbarShow", $el[0]);
  },
  initToolbarOnScroll(pageEl) {
    const app2 = this;
    const $pageEl = $(pageEl);
    let $toolbarEl = $pageEl.parents(".view").children(".toolbar");
    if ($toolbarEl.length === 0) {
      $toolbarEl = $pageEl.find(".toolbar");
    }
    if ($toolbarEl.length === 0) {
      $toolbarEl = $pageEl.parents(".views").children(".tabbar, .tabbar-icons");
    }
    if ($toolbarEl.length === 0) {
      return;
    }
    let previousScrollTop;
    let currentScrollTop;
    let scrollHeight;
    let offsetHeight;
    let reachEnd;
    let action;
    let toolbarHidden;
    function handleScroll(e) {
      if ($pageEl.hasClass("page-with-card-opened")) return;
      if ($pageEl.hasClass("page-previous")) return;
      const scrollContent = this;
      if (e && e.target && e.target !== scrollContent) {
        return;
      }
      currentScrollTop = scrollContent.scrollTop;
      scrollHeight = scrollContent.scrollHeight;
      offsetHeight = scrollContent.offsetHeight;
      reachEnd = currentScrollTop + offsetHeight >= scrollHeight;
      toolbarHidden = $toolbarEl.hasClass("toolbar-hidden");
      if (reachEnd) {
        if (app2.params.toolbar.showOnPageScrollEnd) {
          action = "show";
        }
      } else if (previousScrollTop > currentScrollTop) {
        if (app2.params.toolbar.showOnPageScrollTop || currentScrollTop <= 44) {
          action = "show";
        } else {
          action = "hide";
        }
      } else if (currentScrollTop > 44) {
        action = "hide";
      } else {
        action = "show";
      }
      if (action === "show" && toolbarHidden) {
        app2.toolbar.show($toolbarEl);
        toolbarHidden = false;
      } else if (action === "hide" && !toolbarHidden) {
        app2.toolbar.hide($toolbarEl);
        toolbarHidden = true;
      }
      previousScrollTop = currentScrollTop;
    }
    $pageEl.on("scroll", ".page-content", handleScroll, true);
    $pageEl[0].f7ScrollToolbarHandler = handleScroll;
  }
};
const Toolbar$1 = {
  name: "toolbar",
  create() {
    const app2 = this;
    bindMethods(app2, {
      toolbar: Toolbar
    });
  },
  params: {
    toolbar: {
      hideOnPageScroll: false,
      showOnPageScrollEnd: true,
      showOnPageScrollTop: true
    }
  },
  on: {
    pageBeforeRemove(page) {
      if (page.$el[0].f7ScrollToolbarHandler) {
        page.$el.off("scroll", ".page-content", page.$el[0].f7ScrollToolbarHandler, true);
      }
    },
    pageBeforeIn(page) {
      const app2 = this;
      let $toolbarEl = page.$el.parents(".view").children(".toolbar");
      if ($toolbarEl.length === 0) {
        $toolbarEl = page.$el.parents(".views").children(".tabbar, .tabbar-icons");
      }
      if ($toolbarEl.length === 0) {
        $toolbarEl = page.$el.find(".toolbar");
      }
      if ($toolbarEl.length === 0) {
        return;
      }
      if (page.$el.hasClass("no-toolbar")) {
        app2.toolbar.hide($toolbarEl);
      } else {
        app2.toolbar.show($toolbarEl);
      }
    },
    pageInit(page) {
      const app2 = this;
      page.$el.find(".tabbar, .tabbar-icons").each((tabbarEl) => {
        app2.toolbar.init(tabbarEl);
      });
      if (app2.params.toolbar.hideOnPageScroll || page.$el.find(".hide-toolbar-on-scroll").length || page.$el.hasClass("hide-toolbar-on-scroll") || page.$el.find(".hide-bars-on-scroll").length || page.$el.hasClass("hide-bars-on-scroll")) {
        if (page.$el.find(".keep-toolbar-on-scroll").length || page.$el.hasClass("keep-toolbar-on-scroll") || page.$el.find(".keep-bars-on-scroll").length || page.$el.hasClass("keep-bars-on-scroll")) {
          return;
        }
        app2.toolbar.initToolbarOnScroll(page.el);
      }
    },
    init() {
      const app2 = this;
      app2.$el.find(".tabbar, .tabbar-icons").each((tabbarEl) => {
        app2.toolbar.init(tabbarEl);
      });
    }
  },
  vnode: {
    tabbar: {
      insert(vnode2) {
        const app2 = this;
        app2.toolbar.init(vnode2.elm);
      }
    }
  }
};
const Subnavbar = {
  name: "subnavbar",
  on: {
    pageInit(page) {
      if (page.$navbarEl && page.$navbarEl.length && page.$navbarEl.find(".subnavbar").length) {
        page.$el.addClass("page-with-subnavbar");
      }
      const $innerSubnavbars = page.$el.find(".subnavbar").filter((subnavbarEl) => {
        return $(subnavbarEl).parents(".page")[0] === page.$el[0];
      });
      if ($innerSubnavbars.length) {
        page.$el.addClass("page-with-subnavbar");
      }
    }
  }
};
let TouchRipple$1 = class TouchRipple {
  constructor(app2, $el, x, y) {
    const ripple = this;
    if (!$el) return void 0;
    const {
      left,
      top,
      width: width2,
      height: height2
    } = $el[0].getBoundingClientRect();
    const center = {
      x: x - left,
      y: y - top
    };
    let diameter = Math.max((height2 ** 2 + width2 ** 2) ** 0.5, 48);
    let isInset = false;
    const insetElements = app2.params.touch.touchRippleInsetElements || "";
    if (insetElements && $el.is(insetElements)) {
      isInset = true;
    }
    if (isInset) {
      diameter = Math.max(Math.min(width2, height2), 48);
    }
    if (!isInset && $el.css("overflow") === "hidden") {
      const distanceFromCenter = ((center.x - width2 / 2) ** 2 + (center.y - height2 / 2) ** 2) ** 0.5;
      const scale = (diameter / 2 + distanceFromCenter) / (diameter / 2);
      ripple.rippleTransform = `translate3d(0px, 0px, 0) scale(${scale * 2})`;
    } else {
      ripple.rippleTransform = `translate3d(${-center.x + width2 / 2}px, ${-center.y + height2 / 2}px, 0) scale(1)`;
    }
    if (isInset) {
      $el.addClass("ripple-inset");
    }
    ripple.$rippleWaveEl = $(`<div class="ripple-wave${isInset ? " ripple-wave-inset" : ""}" style="width: ${diameter}px; height: ${diameter}px; margin-top:-${diameter / 2}px; margin-left:-${diameter / 2}px; left:${center.x}px; top:${center.y}px; --f7-ripple-transform: ${ripple.rippleTransform}"></div>`);
    $el.prepend(ripple.$rippleWaveEl);
    ripple.$rippleWaveEl.animationEnd(() => {
      if (!ripple.$rippleWaveEl) return;
      if (ripple.$rippleWaveEl.hasClass("ripple-wave-out")) return;
      ripple.$rippleWaveEl.addClass("ripple-wave-in");
      if (ripple.shouldBeRemoved) {
        ripple.out();
      }
    });
    return ripple;
  }
  destroy() {
    let ripple = this;
    if (ripple.$rippleWaveEl) {
      ripple.$rippleWaveEl.remove();
    }
    Object.keys(ripple).forEach((key) => {
      ripple[key] = null;
      delete ripple[key];
    });
    ripple = null;
  }
  out() {
    const ripple = this;
    const {
      $rippleWaveEl
    } = this;
    clearTimeout(ripple.removeTimeout);
    $rippleWaveEl.addClass("ripple-wave-out");
    ripple.removeTimeout = setTimeout(() => {
      ripple.destroy();
    }, 300);
    $rippleWaveEl.animationEnd(() => {
      clearTimeout(ripple.removeTimeout);
      ripple.destroy();
    });
  }
  remove() {
    const ripple = this;
    if (ripple.shouldBeRemoved) return;
    ripple.removeTimeout = setTimeout(() => {
      ripple.destroy();
    }, 400);
    ripple.shouldBeRemoved = true;
    if (ripple.$rippleWaveEl.hasClass("ripple-wave-in")) {
      ripple.out();
    }
  }
};
const TouchRipple2 = {
  name: "touch-ripple",
  static: {
    TouchRipple: TouchRipple$1
  },
  create() {
    const app2 = this;
    app2.touchRipple = {
      create() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return new TouchRipple$1(...args);
      }
    };
  }
};
const openedModals = [];
const dialogsQueue = [];
function clearDialogsQueue() {
  if (dialogsQueue.length === 0) return;
  const dialog = dialogsQueue.shift();
  dialog.open();
}
let Modal$1 = class Modal extends Framework7Class {
  constructor(app2, params) {
    super(params, [app2]);
    const modal = this;
    const defaults2 = {};
    modal.useModulesParams(defaults2);
    modal.params = extend$1(defaults2, params);
    modal.opened = false;
    let $containerEl = modal.params.containerEl ? $(modal.params.containerEl).eq(0) : app2.$el;
    if (!$containerEl.length) $containerEl = app2.$el;
    modal.$containerEl = $containerEl;
    modal.containerEl = $containerEl[0];
    modal.useModules();
    return this;
  }
  onOpen() {
    const modal = this;
    modal.opened = true;
    openedModals.push(modal);
    $("html").addClass(`with-modal-${modal.type.toLowerCase()}`);
    modal.$el.trigger(`modal:open ${modal.type.toLowerCase()}:open`);
    modal.emit(`local::open modalOpen ${modal.type}Open`, modal);
  }
  onOpened() {
    const modal = this;
    modal.$el.trigger(`modal:opened ${modal.type.toLowerCase()}:opened`);
    modal.emit(`local::opened modalOpened ${modal.type}Opened`, modal);
  }
  onClose() {
    const modal = this;
    modal.opened = false;
    if (!modal.type || !modal.$el) return;
    openedModals.splice(openedModals.indexOf(modal), 1);
    $("html").removeClass(`with-modal-${modal.type.toLowerCase()}`);
    modal.$el.trigger(`modal:close ${modal.type.toLowerCase()}:close`);
    modal.emit(`local::close modalClose ${modal.type}Close`, modal);
  }
  onClosed() {
    const modal = this;
    if (!modal.type || !modal.$el) return;
    modal.$el.removeClass("modal-out");
    modal.$el.hide();
    if (modal.params.backdrop && (modal.params.backdropUnique || modal.forceBackdropUnique) && modal.$backdropEl) {
      modal.$backdropEl.remove();
    }
    modal.$el.trigger(`modal:closed ${modal.type.toLowerCase()}:closed`);
    modal.emit(`local::closed modalClosed ${modal.type}Closed`, modal);
  }
  open(animateModal, force) {
    const modal = this;
    const document2 = getDocument();
    const app2 = modal.app;
    const $el = modal.$el;
    const $backdropEl = modal.$backdropEl;
    const type = modal.type;
    let animate2 = true;
    if (typeof animateModal !== "undefined") animate2 = animateModal;
    else if (typeof modal.params.animate !== "undefined") {
      animate2 = modal.params.animate;
    }
    if (!$el || $el.hasClass("modal-in")) {
      if (animateModal === false && $el[0] && type !== "dialog") {
        $el[0].style.display = "block";
      }
      if (!force) return modal;
    }
    if (type === "dialog" && app2.params.modal.queueDialogs) {
      let pushToQueue;
      if ($(".dialog.modal-in").length > 0) {
        pushToQueue = true;
      } else if (openedModals.length > 0) {
        openedModals.forEach((openedModal) => {
          if (openedModal.type === "dialog") pushToQueue = true;
        });
      }
      if (pushToQueue) {
        dialogsQueue.push(modal);
        return modal;
      }
    }
    const $modalParentEl = $el.parent();
    const wasInDom = $el.parents(document2).length > 0;
    if (!$modalParentEl.is(modal.$containerEl)) {
      modal.$containerEl.append($el);
      modal.once(`${type}Closed`, () => {
        if (wasInDom) {
          $modalParentEl.append($el);
        } else {
          $el.remove();
        }
      });
    }
    $el.show();
    if (modal.params.backdrop && (modal.params.backdropUnique || modal.forceBackdropUnique) && modal.$backdropEl) {
      modal.$backdropEl.insertBefore($el);
    }
    modal._clientLeft = $el[0].clientLeft;
    function transitionEnd2() {
      if ($el.hasClass("modal-out")) {
        modal.onClosed();
      } else if ($el.hasClass("modal-in")) {
        modal.onOpened();
      }
    }
    if (animate2) {
      if ($backdropEl) {
        $backdropEl.removeClass("not-animated");
        $backdropEl.addClass("backdrop-in");
      }
      $el.animationEnd(() => {
        transitionEnd2();
      });
      $el.transitionEnd(() => {
        transitionEnd2();
      });
      $el.removeClass("modal-out not-animated").addClass("modal-in");
      modal.onOpen();
    } else {
      if ($backdropEl) {
        $backdropEl.addClass("backdrop-in not-animated");
      }
      $el.removeClass("modal-out").addClass("modal-in not-animated");
      modal.onOpen();
      modal.onOpened();
    }
    return modal;
  }
  close(animateModal) {
    const modal = this;
    const $el = modal.$el;
    const $backdropEl = modal.$backdropEl;
    let animate2 = true;
    if (typeof animateModal !== "undefined") animate2 = animateModal;
    else if (typeof modal.params.animate !== "undefined") {
      animate2 = modal.params.animate;
    }
    if (!$el || !$el.hasClass("modal-in")) {
      if (dialogsQueue.indexOf(modal) >= 0) {
        dialogsQueue.splice(dialogsQueue.indexOf(modal), 1);
      }
      return modal;
    }
    if ($backdropEl) {
      let needToHideBackdrop = true;
      if (modal.type === "popup") {
        modal.$el.prevAll(".popup.modal-in").add(modal.$el.nextAll(".popup.modal-in")).each((popupEl) => {
          const popupInstance = popupEl.f7Modal;
          if (!popupInstance) return;
          if (popupInstance.params.closeByBackdropClick && popupInstance.params.backdrop && popupInstance.backdropEl === modal.backdropEl) {
            needToHideBackdrop = false;
          }
        });
      }
      if (needToHideBackdrop) {
        $backdropEl[animate2 ? "removeClass" : "addClass"]("not-animated");
        $backdropEl.removeClass("backdrop-in");
      }
    }
    $el[animate2 ? "removeClass" : "addClass"]("not-animated");
    function transitionEnd2() {
      if ($el.hasClass("modal-out")) {
        modal.onClosed();
      } else if ($el.hasClass("modal-in")) {
        modal.onOpened();
      }
    }
    if (animate2) {
      $el.animationEnd(() => {
        transitionEnd2();
      });
      $el.transitionEnd(() => {
        transitionEnd2();
      });
      $el.removeClass("modal-in").addClass("modal-out");
      modal.onClose();
    } else {
      $el.addClass("not-animated").removeClass("modal-in").addClass("modal-out");
      modal.onClose();
      modal.onClosed();
    }
    if (modal.type === "dialog") {
      clearDialogsQueue();
    }
    return modal;
  }
  destroy() {
    const modal = this;
    if (modal.destroyed) return;
    modal.emit(`local::beforeDestroy modalBeforeDestroy ${modal.type}BeforeDestroy`, modal);
    if (modal.$el) {
      modal.$el.trigger(`modal:beforedestroy ${modal.type.toLowerCase()}:beforedestroy`);
      if (modal.$el.length && modal.$el[0].f7Modal) {
        delete modal.$el[0].f7Modal;
      }
    }
    deleteProps(modal);
    modal.destroyed = true;
  }
};
class CustomModal extends Modal$1 {
  constructor(app2, params) {
    const extendedParams = extend$1({
      backdrop: true,
      closeByBackdropClick: true,
      on: {}
    }, params);
    super(app2, extendedParams);
    const customModal = this;
    customModal.params = extendedParams;
    let $el;
    if (!customModal.params.el) {
      $el = $(customModal.params.content);
    } else {
      $el = $(customModal.params.el);
    }
    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }
    if ($el.length === 0) {
      return customModal.destroy();
    }
    let $backdropEl;
    if (customModal.params.backdrop) {
      $backdropEl = app2.$el.children(".custom-modal-backdrop");
      if ($backdropEl.length === 0) {
        $backdropEl = $('<div class="custom-modal-backdrop"></div>');
        app2.$el.append($backdropEl);
      }
    }
    function handleClick(e) {
      if (!customModal || customModal.destroyed) return;
      if ($backdropEl && e.target === $backdropEl[0]) {
        customModal.close();
      }
    }
    customModal.on("customModalOpened", () => {
      if (customModal.params.closeByBackdropClick && customModal.params.backdrop) {
        app2.on("click", handleClick);
      }
    });
    customModal.on("customModalClose", () => {
      if (customModal.params.closeByBackdropClick && customModal.params.backdrop) {
        app2.off("click", handleClick);
      }
    });
    extend$1(customModal, {
      app: app2,
      $el,
      el: $el[0],
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0],
      type: "customModal"
    });
    $el[0].f7Modal = customModal;
    return customModal;
  }
}
const Modal2 = {
  name: "modal",
  static: {
    Modal: Modal$1,
    CustomModal
  },
  create() {
    const app2 = this;
    app2.customModal = {
      create(params) {
        return new CustomModal(app2, params);
      }
    };
  },
  params: {
    modal: {
      queueDialogs: true
    }
  }
};
Router.use([RouterComponentLoaderModule]);
Framework7.use([DeviceModule, SupportModule, UtilsModule, ResizeModule, TouchModule, ClicksModule, RouterModule, HistoryModule, ComponentModule, ServiceWorkerModule, StoreModule, Statusbar$1, View$1, Navbar$2, Toolbar$1, Subnavbar, TouchRipple2, Modal2]);
function swipePanel(panel) {
  const app2 = panel.app;
  if (panel.swipeInitialized) {
    return;
  }
  extend$1(panel, {
    swipeable: true,
    swipeInitialized: true
  });
  const params = panel.params;
  const {
    $el,
    $backdropEl,
    side,
    effect
  } = panel;
  let otherPanel;
  let isTouched;
  let isGestureStarted;
  let isMoved;
  let isScrolling;
  let isInterrupted;
  const touchesStart = {};
  let touchStartTime;
  let touchesDiff;
  let translate;
  let backdropOpacity;
  let panelWidth;
  let direction;
  let $viewEl;
  let touchMoves = 0;
  function handleTouchStart(e) {
    if (!panel.swipeable || isGestureStarted) return;
    if (!app2.panel.allowOpen || !params.swipe && !params.swipeOnlyClose || isTouched) return;
    if ($(".modal-in:not(.toast):not(.notification), .photo-browser-in").length > 0) return;
    otherPanel = app2.panel.get(side === "left" ? "right" : "left") || {};
    const otherPanelOpened = otherPanel.opened && otherPanel.$el && !otherPanel.$el.hasClass("panel-in-breakpoint");
    if (!panel.opened && otherPanelOpened) {
      return;
    }
    if (!params.swipeOnlyClose) {
      if (otherPanelOpened) return;
    }
    if (e.target && e.target.nodeName.toLowerCase() === "input" && e.target.type === "range") return;
    if ($(e.target).closest(".range-slider, swiper-container.tabs, .calendar-months, .no-swipe-panel, .card-opened").length > 0) return;
    touchesStart.x = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
    touchesStart.y = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
    if (params.swipeOnlyClose && !panel.opened) {
      return;
    }
    if (params.swipeActiveArea && !panel.opened) {
      if (side === "left") {
        if (touchesStart.x > params.swipeActiveArea) return;
      }
      if (side === "right") {
        if (touchesStart.x < app2.width - params.swipeActiveArea) return;
      }
    }
    touchMoves = 0;
    $viewEl = $(panel.getViewEl());
    isMoved = false;
    isTouched = true;
    isScrolling = void 0;
    isInterrupted = false;
    touchStartTime = now$1();
    direction = void 0;
  }
  function handleTouchMove(e) {
    if (!isTouched || isGestureStarted || isInterrupted) return;
    touchMoves += 1;
    if (touchMoves < 2) return;
    if (e.f7PreventSwipePanel || app2.preventSwipePanelBySwipeBack || app2.preventSwipePanel) {
      isTouched = false;
      return;
    }
    const pageX = e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
    const pageY = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
    if (typeof isScrolling === "undefined") {
      isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
    }
    if (isScrolling) {
      isTouched = false;
      return;
    }
    if (!direction) {
      if (pageX > touchesStart.x) {
        direction = "to-right";
      } else {
        direction = "to-left";
      }
      if (params.swipeActiveArea > 0 && !panel.opened) {
        if (side === "left" && touchesStart.x > params.swipeActiveArea) {
          isTouched = false;
          return;
        }
        if (side === "right" && touchesStart.x < app2.width - params.swipeActiveArea) {
          isTouched = false;
          return;
        }
      }
      if ($el.hasClass("panel-in-breakpoint")) {
        isTouched = false;
        return;
      }
      if (side === "left" && direction === "to-left" && !$el.hasClass("panel-in") || side === "right" && direction === "to-right" && !$el.hasClass("panel-in")) {
        isTouched = false;
        return;
      }
    }
    let threshold = panel.opened ? 0 : -params.swipeThreshold;
    if (side === "right") threshold = -threshold;
    if (!isMoved) {
      if (!panel.opened) {
        panel.insertToRoot();
        $el.addClass("panel-in-swipe");
        if ($backdropEl) $backdropEl.css("visibility", "visible");
        $el.trigger("panel:swipeopen");
        panel.emit("local::swipeOpen panelSwipeOpen", panel);
      }
      panelWidth = $el[0].offsetWidth;
      if (effect === "reveal" && $el.hasClass("panel-in-collapsed")) {
        panelWidth -= parseFloat($viewEl.css(`margin-${side}`));
      }
      $el.transition(0);
    }
    isMoved = true;
    if (e.cancelable) {
      e.preventDefault();
    }
    touchesDiff = pageX - touchesStart.x + threshold;
    const startTranslate = effect === "floating" ? 8 : 0;
    if (side === "right") {
      if (effect === "cover" || effect === "push" || effect === "floating") {
        translate = touchesDiff + (panel.opened ? startTranslate : panelWidth);
        if (translate < 0 - startTranslate) translate = -startTranslate;
        if (translate > panelWidth) {
          translate = panelWidth;
        }
      } else {
        translate = touchesDiff - (panel.opened ? panelWidth : 0);
        if (translate > 0) translate = 0;
        if (translate < -panelWidth) {
          translate = -panelWidth;
        }
      }
    } else {
      translate = touchesDiff + (panel.opened ? panelWidth : startTranslate);
      if (translate < 0) translate = 0;
      if (translate > panelWidth + startTranslate) {
        translate = panelWidth + startTranslate;
      }
    }
    const noFollowProgress = Math.abs(translate / panelWidth);
    if (effect === "reveal") {
      if (!params.swipeNoFollow) {
        $viewEl.transform(`translate3d(${translate}px,0,0)`).transition(0);
        if ($backdropEl) $backdropEl.transform(`translate3d(${translate}px,0,0)`).transition(0);
      }
      $el.trigger("panel:swipe", Math.abs(translate / panelWidth));
      panel.emit("local::swipe panelSwipe", panel, Math.abs(translate / panelWidth));
    } else {
      if (side === "left") translate -= panelWidth;
      if (!params.swipeNoFollow) {
        backdropOpacity = 1 - Math.abs(translate / panelWidth);
        if ($backdropEl) {
          $backdropEl.transition(0);
          $backdropEl.css({
            opacity: backdropOpacity
          });
        }
        $el.transform(`translate3d(${translate}px,0,0)`).transition(0);
        if (effect === "push") {
          const viewTranslate = side === "left" ? translate + panelWidth : translate - panelWidth;
          $viewEl.transform(`translate3d(${viewTranslate}px,0,0)`).transition(0);
          if ($backdropEl) {
            $backdropEl.transform(`translate3d(${viewTranslate}px,0,0)`).transition(0);
          }
        }
      }
      $el.trigger("panel:swipe", Math.abs(translate / panelWidth));
      panel.emit("local::swipe panelSwipe", panel, Math.abs(translate / panelWidth));
    }
    if (params.swipeNoFollow) {
      const stateChanged = panel.opened && noFollowProgress === 0 || !panel.opened && noFollowProgress === 1;
      if (stateChanged) {
        isInterrupted = true;
        handleTouchEnd(e);
      }
    }
  }
  function handleTouchEnd(e) {
    if (!isTouched || !isMoved) {
      isTouched = false;
      isMoved = false;
      return;
    }
    const isGesture = e.type === "gesturestart" || isGestureStarted;
    isTouched = false;
    isMoved = false;
    const timeDiff = (/* @__PURE__ */ new Date()).getTime() - touchStartTime;
    let action;
    const startTranslate = effect === "floating" ? side === "left" ? 8 : -8 : 0;
    const edge = (translate === startTranslate || Math.abs(translate) === panelWidth) && !params.swipeNoFollow;
    const threshold = params.swipeThreshold || 0;
    if (isGesture) {
      action = "reset";
    } else if (!panel.opened) {
      if (Math.abs(touchesDiff) < threshold) {
        action = "reset";
      } else if (effect === "cover" || effect === "push" || effect === "floating") {
        if (translate === 0 + startTranslate) {
          action = "swap";
        } else if (timeDiff < 300 && Math.abs(translate) > 0) {
          action = "swap";
        } else if (timeDiff >= 300 && Math.abs(translate) < panelWidth / 2) {
          action = "swap";
        } else {
          action = "reset";
        }
      } else if (translate === 0) {
        action = "reset";
      } else if (timeDiff < 300 && Math.abs(translate) > 0 || timeDiff >= 300 && Math.abs(translate) >= panelWidth / 2) {
        action = "swap";
      } else {
        action = "reset";
      }
    } else if (effect === "cover" || effect === "push" || effect === "floating") {
      if (translate === 0) {
        action = "reset";
      } else if (timeDiff < 300 && Math.abs(translate) > 0) {
        action = "swap";
      } else if (timeDiff >= 300 && Math.abs(translate) < panelWidth / 2) {
        action = "reset";
      } else {
        action = "swap";
      }
    } else if (translate === -panelWidth) {
      action = "reset";
    } else if (timeDiff < 300 && Math.abs(translate) >= 0 || timeDiff >= 300 && Math.abs(translate) <= panelWidth / 2) {
      if (side === "left" && translate === panelWidth) action = "reset";
      else action = "swap";
    } else {
      action = "reset";
    }
    if (action === "swap") {
      if (panel.opened) {
        panel.close(!edge);
      } else {
        panel.open(!edge);
      }
    }
    let removePanelInClass = true;
    if (action === "reset") {
      if (!panel.opened) {
        if (edge) {
          $el.removeClass("panel-in-swipe");
        } else {
          removePanelInClass = false;
          const target = effect === "reveal" ? $viewEl : $el;
          panel.setStateClasses("before-closing");
          target.transitionEnd(() => {
            if ($el.hasClass("panel-in")) return;
            $el.removeClass("panel-in-swipe");
            panel.setStateClasses("after-closing");
          });
        }
      }
    }
    if (effect === "reveal" || effect === "push") {
      nextFrame$1(() => {
        $viewEl.transition("");
        $viewEl.transform("");
      });
    }
    if (removePanelInClass) {
      $el.removeClass("panel-in-swipe");
    }
    $el.transition("").transform("");
    if ($backdropEl) {
      $backdropEl.transform("").transition("").css({
        opacity: "",
        visibility: ""
      });
    }
  }
  function handleGestureStart(e) {
    isGestureStarted = true;
    handleTouchEnd(e);
  }
  function handleGestureEnd() {
    isGestureStarted = false;
  }
  app2.on("touchstart:passive", handleTouchStart);
  app2.on("touchmove:active", handleTouchMove);
  app2.on("touchend:passive", handleTouchEnd);
  app2.on("gesturestart", handleGestureStart);
  app2.on("gestureend", handleGestureEnd);
  panel.on("panelDestroy", () => {
    app2.off("touchstart:passive", handleTouchStart);
    app2.off("touchmove:active", handleTouchMove);
    app2.off("touchend:passive", handleTouchEnd);
    app2.off("gesturestart", handleGestureStart);
    app2.off("gestureend", handleGestureEnd);
  });
}
function resizablePanel(panel) {
  const app2 = panel.app;
  const support2 = getSupport();
  if (panel.resizableInitialized) return;
  extend$1(panel, {
    resizable: true,
    resizableWidth: null,
    resizableInitialized: true
  });
  const $htmlEl = $("html");
  const {
    $el,
    $backdropEl,
    side,
    effect
  } = panel;
  if (!$el) return;
  let isTouched;
  let isMoved;
  const touchesStart = {};
  let touchesDiff;
  let panelWidth;
  let $viewEl;
  let panelMinWidth;
  let panelMaxWidth;
  let visibleByBreakpoint;
  const isPushingPanel = effect !== "cover" && effect !== "floating";
  function transformCSSWidth(v) {
    if (!v) return null;
    if (v.indexOf("%") >= 0 || v.indexOf("vw") >= 0) {
      return parseInt(v, 10) / 100 * app2.width;
    }
    const newV = parseInt(v, 10);
    if (Number.isNaN(newV)) return null;
    return newV;
  }
  function isResizable() {
    return panel.resizable && $el.hasClass("panel-resizable");
  }
  function handleTouchStart(e) {
    if (!isResizable()) return;
    touchesStart.x = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
    touchesStart.y = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
    isMoved = false;
    isTouched = true;
    panelMinWidth = transformCSSWidth($el.css("min-width"));
    panelMaxWidth = transformCSSWidth($el.css("max-width"));
    visibleByBreakpoint = $el.hasClass("panel-in-breakpoint");
  }
  function handleTouchMove(e) {
    if (!isTouched) return;
    const pageX = e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
    if (!isMoved) {
      panelWidth = $el[0].offsetWidth;
      $el.transition(0);
      $el.addClass("panel-resizing");
      $htmlEl.css("cursor", "col-resize");
      if (isPushingPanel || visibleByBreakpoint) {
        $viewEl = $(panel.getViewEl());
        if (panel.$containerEl && panel.$containerEl.hasClass("page")) {
          $viewEl.add(panel.$containerEl.children(".page-content, .tabs, .fab"));
        }
      }
      if (isPushingPanel && !visibleByBreakpoint) {
        $backdropEl.transition(0);
        $viewEl.transition(0);
      }
    }
    isMoved = true;
    e.preventDefault();
    touchesDiff = pageX - touchesStart.x;
    let newPanelWidth = side === "left" ? panelWidth + touchesDiff : panelWidth - touchesDiff;
    if (panelMinWidth && !Number.isNaN(panelMinWidth)) {
      newPanelWidth = Math.max(newPanelWidth, panelMinWidth);
    }
    if (panelMaxWidth && !Number.isNaN(panelMaxWidth)) {
      newPanelWidth = Math.min(newPanelWidth, panelMaxWidth);
    }
    newPanelWidth = Math.min(Math.max(newPanelWidth, 0), app2.width);
    panel.resizableWidth = newPanelWidth;
    $el[0].style.width = `${newPanelWidth}px`;
    if (isPushingPanel && !visibleByBreakpoint) {
      if ($viewEl) {
        $viewEl.transform(`translate3d(${side === "left" ? newPanelWidth : -newPanelWidth}px, 0, 0)`);
      }
      if ($backdropEl) {
        $backdropEl.transform(`translate3d(${side === "left" ? newPanelWidth : -newPanelWidth}px, 0, 0)`);
      }
    } else if (visibleByBreakpoint && $viewEl) {
      $viewEl.css(`margin-${side}`, `${newPanelWidth}px`);
    }
    $el.trigger("panel:resize", newPanelWidth);
    panel.emit("local::resize panelResize", panel, newPanelWidth);
  }
  function handleTouchEnd() {
    $("html").css("cursor", "");
    if (!isTouched || !isMoved) {
      isTouched = false;
      isMoved = false;
      return;
    }
    isTouched = false;
    isMoved = false;
    $htmlEl[0].style.setProperty(`--f7-panel-${side}-width`, `${panel.resizableWidth}px`);
    $el[0].style.width = "";
    if (isPushingPanel && !visibleByBreakpoint) {
      $viewEl.transform("");
      $backdropEl.transform("");
    }
    $el.removeClass("panel-resizing");
    nextFrame$1(() => {
      $el.transition("");
      if (isPushingPanel) {
        $backdropEl.transition("");
        if ($viewEl) $viewEl.transition("");
      }
    });
  }
  function handleResize() {
    if (!panel.opened || !panel.resizableWidth) return;
    panelMinWidth = transformCSSWidth($el.css("min-width"));
    panelMaxWidth = transformCSSWidth($el.css("max-width"));
    if (panelMinWidth && !Number.isNaN(panelMinWidth) && panel.resizableWidth < panelMinWidth) {
      panel.resizableWidth = Math.max(panel.resizableWidth, panelMinWidth);
    }
    if (panelMaxWidth && !Number.isNaN(panelMaxWidth) && panel.resizableWidth > panelMaxWidth) {
      panel.resizableWidth = Math.min(panel.resizableWidth, panelMaxWidth);
    }
    panel.resizableWidth = Math.min(Math.max(panel.resizableWidth, 0), app2.width);
    $htmlEl[0].style.setProperty(`--f7-panel-${side}-width`, `${panel.resizableWidth}px`);
  }
  if (panel.$el.find(".panel-resize-handler").length === 0) {
    panel.$el.append('<div class="panel-resize-handler"></div>');
  }
  panel.$resizeHandlerEl = panel.$el.children(".panel-resize-handler");
  $el.addClass("panel-resizable");
  const passive = support2.passiveListener ? {
    passive: true
  } : false;
  panel.$el.on(app2.touchEvents.start, ".panel-resize-handler", handleTouchStart, passive);
  app2.on("touchmove:active", handleTouchMove);
  app2.on("touchend:passive", handleTouchEnd);
  app2.on("resize", handleResize);
  panel.on("beforeOpen", handleResize);
  panel.once("panelDestroy", () => {
    $el.removeClass("panel-resizable");
    panel.$resizeHandlerEl.remove();
    panel.$el.off(app2.touchEvents.start, ".panel-resize-handler", handleTouchStart, passive);
    app2.off("touchmove:active", handleTouchMove);
    app2.off("touchend:passive", handleTouchEnd);
    app2.off("resize", handleResize);
    panel.off("beforeOpen", handleResize);
  });
}
let Panel$2 = class Panel extends Framework7Class {
  constructor(app2, params) {
    if (params === void 0) {
      params = {};
    }
    const extendedParams = extend$1({
      on: {}
    }, app2.params.panel, params);
    super(extendedParams, [app2]);
    const panel = this;
    panel.params = extendedParams;
    panel.$containerEl = panel.params.containerEl ? $(panel.params.containerEl).eq(0) : app2.$el;
    panel.containerEl = panel.$containerEl[0];
    if (!panel.containerEl) {
      panel.$containerEl = app2.$el;
      panel.containerEl = app2.$el[0];
    }
    let $el;
    if (panel.params.el) {
      $el = $(panel.params.el).eq(0);
    } else if (panel.params.content) {
      $el = $(panel.params.content).filter((node) => node.nodeType === 1).eq(0);
    }
    if ($el.length === 0) return panel;
    if ($el[0].f7Panel) return $el[0].f7Panel;
    $el[0].f7Panel = panel;
    let {
      side,
      effect,
      resizable
    } = panel.params;
    if (typeof side === "undefined") side = $el.hasClass("panel-left") ? "left" : "right";
    if (typeof effect === "undefined")
      effect = $el.hasClass("panel-cover") ? "cover" : $el.hasClass("panel-push") ? "push" : $el.hasClass("panel-floating") ? "floating" : "reveal";
    if (typeof resizable === "undefined") resizable = $el.hasClass("panel-resizable");
    let $backdropEl;
    if (panel.params.backdrop && panel.params.backdropEl) {
      $backdropEl = $(panel.params.backdropEl);
    } else if (panel.params.backdrop) {
      $backdropEl = panel.$containerEl.children(".panel-backdrop");
      if ($backdropEl.length === 0) {
        $backdropEl = $('<div class="panel-backdrop"></div>');
        panel.$containerEl.prepend($backdropEl);
      }
    }
    extend$1(panel, {
      app: app2,
      side,
      effect,
      resizable,
      $el,
      el: $el[0],
      opened: false,
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0]
    });
    panel.useModules();
    panel.init();
    return panel;
  }
  getViewEl() {
    const panel = this;
    let viewEl;
    if (panel.$containerEl.children(".views").length > 0) {
      viewEl = panel.$containerEl.children(".views")[0];
    } else {
      viewEl = panel.$containerEl.children(".view")[0];
    }
    return viewEl;
  }
  setStateClasses(state) {
    const panel = this;
    const {
      side,
      el,
      effect
    } = panel;
    const viewEl = panel.getViewEl();
    const panelInView = viewEl && viewEl.contains(el);
    const $targetEl = !viewEl || panelInView ? panel.$containerEl : $("html");
    if (state === "open") {
      $targetEl.addClass(`with-panel with-panel-${panel.side}-${panel.effect}`);
    }
    if (state === "before-closing") {
      $targetEl.addClass("with-panel-closing");
    }
    if (state === "closing") {
      $targetEl.addClass("with-panel-closing");
      $targetEl.removeClass(`with-panel with-panel-${panel.side}-${panel.effect}`);
    }
    if (state === "after-closing") {
      $targetEl.removeClass("with-panel-closing");
    }
    if (state === "closed") {
      $targetEl.removeClass(`with-panel-${side}-${effect}`);
    }
  }
  enableVisibleBreakpoint() {
    const panel = this;
    panel.visibleBreakpointDisabled = false;
    panel.setVisibleBreakpoint();
    return panel;
  }
  disableVisibleBreakpoint() {
    const panel = this;
    panel.visibleBreakpointDisabled = true;
    panel.setVisibleBreakpoint();
    return panel;
  }
  toggleVisibleBreakpoint() {
    const panel = this;
    panel.visibleBreakpointDisabled = !panel.visibleBreakpointDisabled;
    panel.setVisibleBreakpoint();
    return panel;
  }
  setVisibleBreakpoint(emitEvents) {
    if (emitEvents === void 0) {
      emitEvents = true;
    }
    const panel = this;
    const app2 = panel.app;
    if (!panel.visibleBreakpointResizeHandler) {
      panel.visibleBreakpointResizeHandler = function visibleBreakpointResizeHandler() {
        panel.setVisibleBreakpoint();
      };
      app2.on("resize", panel.visibleBreakpointResizeHandler);
    }
    const {
      side,
      $el,
      $containerEl,
      params,
      visibleBreakpointDisabled
    } = panel;
    const breakpoint = params.visibleBreakpoint;
    const $viewEl = $(panel.getViewEl());
    const wasVisible = $el.hasClass("panel-in-breakpoint");
    if ($containerEl && $containerEl.hasClass("page")) {
      $viewEl.add($containerEl.children(".page-content, .tabs, .fab"));
    }
    if (app2.width >= breakpoint && typeof breakpoint !== "undefined" && breakpoint !== null && !visibleBreakpointDisabled) {
      if (!wasVisible) {
        panel.setStateClasses("closed");
        $el.addClass("panel-in-breakpoint").removeClass("panel-in panel-in-collapsed");
        panel.onOpen(false);
        panel.onOpened();
        $viewEl.css({
          [`margin-${side}`]: `${$el.width()}px`
        });
        app2.allowPanelOpen = true;
        if (emitEvents) {
          panel.emit("local::breakpoint panelBreakpoint", panel);
          panel.$el.trigger("panel:breakpoint");
        }
      } else {
        $viewEl.css({
          [`margin-${side}`]: `${$el.width()}px`
        });
      }
    } else if (wasVisible) {
      $el.removeClass("panel-in-breakpoint panel-in");
      panel.onClose();
      panel.onClosed();
      $viewEl.css({
        [`margin-${side}`]: ""
      });
      if (emitEvents) {
        panel.emit("local::breakpoint panelBreakpoint", panel);
        panel.$el.trigger("panel:breakpoint");
      }
    }
  }
  enableCollapsedBreakpoint() {
    const panel = this;
    panel.collapsedBreakpointDisabled = false;
    panel.setCollapsedBreakpoint();
    return panel;
  }
  disableCollapsedBreakpoint() {
    const panel = this;
    panel.collapsedBreakpointDisabled = true;
    panel.setCollapsedBreakpoint();
    return panel;
  }
  toggleCollapsedBreakpoint() {
    const panel = this;
    panel.collapsedBreakpointDisabled = !panel.collapsedBreakpointDisabled;
    panel.setCollapsedBreakpoint();
    return panel;
  }
  setCollapsedBreakpoint(emitEvents) {
    if (emitEvents === void 0) {
      emitEvents = true;
    }
    const panel = this;
    const app2 = panel.app;
    if (!panel.collapsedBreakpointResizeHandler) {
      panel.collapsedBreakpointResizeHandler = function collapsedBreakpointResizeHandler() {
        panel.setCollapsedBreakpoint();
      };
      app2.on("resize", panel.collapsedBreakpointResizeHandler);
    }
    const {
      $el,
      params,
      collapsedBreakpointDisabled
    } = panel;
    if ($el.hasClass("panel-in-breakpoint")) return;
    const breakpoint = params.collapsedBreakpoint;
    const wasVisible = $el.hasClass("panel-in-collapsed");
    if (app2.width >= breakpoint && typeof breakpoint !== "undefined" && breakpoint !== null && !collapsedBreakpointDisabled) {
      if (!wasVisible) {
        panel.setStateClasses("closed");
        $el.addClass("panel-in-collapsed").removeClass("panel-in");
        panel.collapsed = true;
        app2.allowPanelOpen = true;
        if (emitEvents) {
          panel.emit("local::collapsedBreakpoint panelCollapsedBreakpoint", panel);
          panel.$el.trigger("panel:collapsedbreakpoint");
        }
      }
    } else if (wasVisible) {
      $el.removeClass("panel-in-collapsed panel-in");
      panel.collapsed = false;
      if (emitEvents) {
        panel.emit("local::collapsedBreakpoint panelCollapsedBreakpoint", panel);
        panel.$el.trigger("panel:collapsedbreakpoint");
      }
    }
  }
  enableResizable() {
    const panel = this;
    if (panel.resizableInitialized) {
      panel.resizable = true;
      panel.$el.addClass("panel-resizable");
    } else {
      resizablePanel(panel);
    }
    return panel;
  }
  disableResizable() {
    const panel = this;
    panel.resizable = false;
    panel.$el.removeClass("panel-resizable");
    return panel;
  }
  enableSwipe() {
    const panel = this;
    if (panel.swipeInitialized) {
      panel.swipeable = true;
    } else {
      swipePanel(panel);
    }
    return panel;
  }
  disableSwipe() {
    const panel = this;
    panel.swipeable = false;
    return panel;
  }
  onOpen(modifyHtmlClasses) {
    if (modifyHtmlClasses === void 0) {
      modifyHtmlClasses = true;
    }
    const panel = this;
    panel._openTransitionStarted = false;
    const app2 = panel.app;
    panel.opened = true;
    app2.panel.allowOpen = false;
    panel.$el.trigger("panel:beforeopen");
    panel.emit("local::beforeOpen panelBeforeOpen", panel);
    if (modifyHtmlClasses) {
      panel.setStateClasses("open");
    }
    panel.$el.trigger("panel:open");
    panel.emit("local::open panelOpen", panel);
  }
  onOpened() {
    const panel = this;
    const app2 = panel.app;
    app2.panel.allowOpen = true;
    panel.$el.trigger("panel:opened");
    panel.emit("local::opened panelOpened", panel);
  }
  onClose() {
    const panel = this;
    const app2 = panel.app;
    panel.opened = false;
    app2.panel.allowOpen = false;
    panel.$el.trigger("panel:beforeclose");
    panel.emit("local::beforeClose panelBeforeClose", panel);
    panel.setStateClasses("closing");
    panel.$el.trigger("panel:close");
    panel.emit("local::close panelClose", panel);
  }
  onClosed() {
    const panel = this;
    const app2 = panel.app;
    app2.panel.allowOpen = true;
    panel.setStateClasses("after-closing");
    panel.$el.removeClass("panel-out");
    if (panel.$backdropEl) {
      const otherPanel = app2.panel.get(".panel-in");
      const shouldHideBackdrop = !otherPanel || otherPanel && !otherPanel.$backdropEl;
      if (shouldHideBackdrop) {
        panel.$backdropEl.removeClass("panel-backdrop-in");
      }
    }
    panel.$el.trigger("panel:closed");
    panel.emit("local::closed panelClosed", panel);
  }
  toggle(animate2) {
    if (animate2 === void 0) {
      animate2 = true;
    }
    const panel = this;
    const breakpoint = panel.params.visibleBreakpoint;
    const app2 = panel.app;
    if (app2.width >= breakpoint && typeof breakpoint !== "undefined" && breakpoint !== null) {
      return panel.toggleVisibleBreakpoint();
    }
    if (panel.opened) panel.close(animate2);
    else panel.open(animate2);
    return panel;
  }
  insertToRoot() {
    const panel = this;
    const document2 = getDocument();
    const {
      $el,
      $backdropEl,
      $containerEl
    } = panel;
    const $panelParentEl = $el.parent();
    const wasInDom = $el.parents(document2).length > 0;
    if (!$panelParentEl.is($containerEl) || $el.prevAll(".views, .view").length) {
      const $insertBeforeEl = $containerEl.children(".panel, .views, .view").eq(0);
      const $insertAfterEl = $containerEl.children(".panel-backdrop").eq(0);
      if ($insertBeforeEl.length) {
        $el.insertBefore($insertBeforeEl);
      } else if ($insertAfterEl) {
        $el.insertBefore($insertAfterEl);
      } else {
        $containerEl.prepend($el);
      }
      if ($backdropEl && $backdropEl.length && (!$backdropEl.parent().is($containerEl) && $backdropEl.nextAll(".panel").length === 0 || $backdropEl.parent().is($containerEl) && $backdropEl.nextAll(".panel").length === 0)) {
        $backdropEl.insertBefore($el);
      }
      panel.once("panelClosed", () => {
        if (wasInDom) {
          $panelParentEl.append($el);
        } else {
          $el.remove();
        }
      });
    }
  }
  open(animate2) {
    if (animate2 === void 0) {
      animate2 = true;
    }
    const panel = this;
    const app2 = panel.app;
    if (!app2.panel.allowOpen) return false;
    const {
      effect,
      $el,
      $backdropEl,
      opened,
      $containerEl
    } = panel;
    if (!$el || $el.hasClass("panel-in")) {
      return panel;
    }
    panel.insertToRoot();
    if (opened || $el.hasClass("panel-in-breakpoint") || $el.hasClass("panel-in")) return false;
    const otherOpenedPanel = app2.panel.get(".panel-in");
    if (otherOpenedPanel && otherOpenedPanel !== panel) {
      otherOpenedPanel.close(animate2);
    }
    $el[animate2 ? "removeClass" : "addClass"]("not-animated");
    $el.addClass("panel-in");
    if ($backdropEl) {
      $backdropEl.addClass("panel-backdrop-in");
      $backdropEl[animate2 ? "removeClass" : "addClass"]("not-animated");
    }
    if (["cover", "push", "floating"].includes(panel.effect)) {
      panel._clientLeft = $el[0].clientLeft;
    }
    const $viewEl = $(panel.getViewEl());
    if ($containerEl && $containerEl.hasClass("page")) {
      $viewEl.add($containerEl.children(".page-content, .tabs"));
    }
    const transitionEndTarget = effect === "reveal" ? $viewEl : $el;
    function panelTransitionStart() {
      transitionEndTarget.transitionStart(() => {
        panel._openTransitionStarted = true;
      });
    }
    function panelTransitionEnd() {
      transitionEndTarget.transitionEnd((e) => {
        if ($(e.target).is(transitionEndTarget)) {
          if ($el.hasClass("panel-out")) {
            panel.onClosed();
          } else {
            panel.onOpened();
          }
        } else panelTransitionEnd();
      });
    }
    if (animate2) {
      if ($backdropEl) {
        $backdropEl.removeClass("not-animated");
      }
      panelTransitionStart();
      panelTransitionEnd();
      $el.removeClass("panel-out not-animated").addClass("panel-in");
      panel.onOpen();
    } else {
      if ($backdropEl) {
        $backdropEl.addClass("not-animated");
      }
      $el.removeClass("panel-out").addClass("panel-in not-animated");
      panel.onOpen();
      panel.onOpened();
      panel._openTransitionStarted = true;
    }
    return true;
  }
  close(animate2) {
    if (animate2 === void 0) {
      animate2 = true;
    }
    const panel = this;
    const {
      effect,
      $el,
      $backdropEl,
      opened,
      $containerEl
    } = panel;
    if (!opened || $el.hasClass("panel-in-breakpoint") || !$el.hasClass("panel-in")) return panel;
    $el[animate2 ? "removeClass" : "addClass"]("not-animated");
    if ($backdropEl) {
      $backdropEl[animate2 ? "removeClass" : "addClass"]("not-animated");
    }
    const $viewEl = $(panel.getViewEl());
    if ($containerEl && $containerEl.hasClass("page")) {
      $viewEl.add($containerEl.children(".page-content, .tabs"));
    }
    const transitionEndTarget = effect === "reveal" ? $viewEl : $el;
    if (!panel._openTransitionStarted) {
      animate2 = false;
    }
    function transitionEnd2() {
      if ($el.hasClass("panel-out")) {
        panel.onClosed();
      } else if ($el.hasClass("panel-in")) {
        panel.onOpened();
      }
      panel.setStateClasses("after-closing");
    }
    if (animate2) {
      transitionEndTarget.transitionEnd(() => {
        transitionEnd2();
      });
      $el.removeClass("panel-in").addClass("panel-out");
      panel.onClose();
    } else {
      $el.addClass("not-animated").removeClass("panel-in").addClass("panel-out");
      panel.onClose();
      panel.onClosed();
    }
    return panel;
  }
  init() {
    const panel = this;
    if (typeof panel.params.visibleBreakpoint !== "undefined") {
      panel.setVisibleBreakpoint();
    }
    if (typeof panel.params.collapsedBreakpoint !== "undefined") {
      panel.setCollapsedBreakpoint();
    }
    if (panel.params.swipe) {
      panel.enableSwipe();
    }
    if (panel.resizable) {
      panel.enableResizable();
    }
  }
  destroy() {
    let panel = this;
    const app2 = panel.app;
    const {
      $containerEl
    } = panel;
    if (!panel.$el) {
      return;
    }
    panel.emit("local::beforeDestroy panelBeforeDestroy", panel);
    panel.$el.trigger("panel:beforedestroy");
    if (panel.visibleBreakpointResizeHandler) {
      app2.off("resize", panel.visibleBreakpointResizeHandler);
    }
    if (panel.collapsedBreakpointResizeHandler) {
      app2.off("resize", panel.collapsedBreakpointResizeHandler);
    }
    if (panel.$el.hasClass("panel-in-breakpoint") || panel.$el.hasClass("panel-in-collapsed")) {
      const $viewEl = $(panel.getViewEl());
      if ($containerEl && $containerEl.hasClass("page")) {
        $viewEl.add($containerEl.children(".page-content, .tabs"));
      }
      panel.$el.removeClass("panel-in-breakpoint panel-in-collapsed panel-in");
      $viewEl.css({
        [`margin-${panel.side}`]: ""
      });
      panel.emit("local::breakpoint panelBreakpoint", panel);
      panel.$el.trigger("panel:breakpoint");
    }
    panel.$el.trigger("panel:destroy");
    panel.emit("local::destroy panelDestroy", panel);
    if (panel.el) {
      panel.el.f7Panel = null;
      delete panel.el.f7Panel;
    }
    deleteProps(panel);
    panel = null;
  }
};
const Panel$1 = {
  name: "panel",
  params: {
    panel: {
      opened: void 0,
      // default based on panel-in class
      side: void 0,
      // default based on panel class
      effect: void 0,
      // default based on panel class
      resizable: void 0,
      // default based on panel-resizable class
      backdrop: true,
      backdropEl: void 0,
      visibleBreakpoint: void 0,
      collapsedBreakpoint: void 0,
      swipe: false,
      // or true
      swipeNoFollow: false,
      // or true
      swipeOnlyClose: false,
      swipeActiveArea: 0,
      swipeThreshold: 0,
      closeByBackdropClick: true,
      containerEl: void 0
    }
  },
  static: {
    Panel: Panel$2
  },
  create() {
    const app2 = this;
    extend$1(app2, {
      panel: {
        allowOpen: true,
        create(params) {
          return new Panel$2(app2, params);
        },
        get(el) {
          if (el === void 0) {
            el = ".panel";
          }
          if (el instanceof Panel$2) return el;
          if (el === "left" || el === "right") el = `.panel-${el}`;
          const $el = $(el);
          if ($el.length === 0 || $el.length > 1) return void 0;
          return $el[0].f7Panel;
        },
        destroy(el) {
          if (el === void 0) {
            el = ".panel";
          }
          const panel = app2.panel.get(el);
          if (panel && panel.destroy) return panel.destroy();
          return void 0;
        },
        open(el, animate2) {
          if (el === void 0) {
            el = ".panel";
          }
          if (el === "left" || el === "right") el = `.panel-${el}`;
          let panel = app2.panel.get(el);
          if (panel && panel.open) return panel.open(animate2);
          if (!panel) {
            panel = app2.panel.create({
              el
            });
            return panel.open(animate2);
          }
          return void 0;
        },
        close(el, animate2) {
          if (el === void 0) {
            el = ".panel-in";
          }
          if (el === "left" || el === "right") el = `.panel-${el}`;
          let panel = app2.panel.get(el);
          if (panel && panel.open) return panel.close(animate2);
          if (!panel) {
            panel = app2.panel.create({
              el
            });
            return panel.close(animate2);
          }
          return void 0;
        },
        toggle(el, animate2) {
          if (el === void 0) {
            el = ".panel";
          }
          if (el === "left" || el === "right") el = `.panel-${el}`;
          let panel = app2.panel.get(el);
          if (panel && panel.toggle) return panel.toggle(animate2);
          if (!panel) {
            panel = app2.panel.create({
              el
            });
            return panel.toggle(animate2);
          }
          return void 0;
        }
      }
    });
  },
  on: {
    init() {
      const app2 = this;
      $(".panel-init").each((panelEl) => {
        const params = Object.assign({
          el: panelEl
        }, $(panelEl).dataset() || {});
        app2.panel.create(params);
      });
    },
    pageInit(page) {
      const app2 = this;
      page.$el.find(".panel-init").each((panelEl) => {
        const params = Object.assign({
          el: panelEl
        }, $(panelEl).dataset() || {});
        app2.panel.create(params);
      });
    },
    pageBeforeRemove(page) {
      const app2 = this;
      page.$el.find(".panel-init").each((panelEl) => {
        const panel = app2.panel.get(panelEl);
        if (panel && panel.destroy) panel.destroy();
      });
    }
  },
  vnode: {
    "panel-init": {
      insert(vnode2) {
        const app2 = this;
        const panelEl = vnode2.elm;
        const params = Object.assign({
          el: panelEl
        }, $(panelEl).dataset() || {});
        app2.panel.create(params);
      },
      destroy(vnode2) {
        const app2 = this;
        const panelEl = vnode2.elm;
        const panel = app2.panel.get(panelEl);
        if (panel && panel.destroy) panel.destroy();
      }
    }
  },
  clicks: {
    ".panel-open": function open(clickedEl, data2) {
      if (data2 === void 0) {
        data2 = {};
      }
      const app2 = this;
      app2.panel.open(data2.panel, data2.animate);
    },
    ".panel-close": function close(clickedEl, data2) {
      if (data2 === void 0) {
        data2 = {};
      }
      const app2 = this;
      app2.panel.close(data2.panel, data2.animate);
    },
    ".panel-toggle": function close2(clickedEl, data2) {
      if (data2 === void 0) {
        data2 = {};
      }
      const app2 = this;
      app2.panel.toggle(data2.panel, data2.animate);
    },
    ".panel-backdrop": function close3() {
      const app2 = this;
      const $panelEl = $(".panel-in:not(.panel-out)");
      if (!$panelEl.length) return;
      const instance2 = $panelEl[0] && $panelEl[0].f7Panel;
      $panelEl.trigger("panel:backdrop-click");
      if (instance2) {
        instance2.emit("backdropClick", instance2);
      }
      app2.emit("panelBackdropClick", instance2 || $panelEl[0]);
      if (instance2 && instance2.params.closeByBackdropClick === false) return;
      if (app2.params.panel.closeByBackdropClick) app2.panel.close();
    }
  }
};
let Popup$2 = class Popup extends Modal$1 {
  constructor(app2, params) {
    const extendedParams = extend$1({
      on: {}
    }, app2.params.popup, params);
    super(app2, extendedParams);
    const popup = this;
    const window2 = getWindow();
    const document2 = getDocument();
    const support2 = getSupport();
    const device = getDevice();
    popup.params = extendedParams;
    let $el;
    if (!popup.params.el) {
      $el = $(popup.params.content).filter((node) => node.nodeType === 1).eq(0);
    } else {
      $el = $(popup.params.el).eq(0);
    }
    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }
    if ($el.length === 0) {
      return popup.destroy();
    }
    let $backdropEl;
    if (popup.params.backdrop && popup.params.backdropEl) {
      $backdropEl = $(popup.params.backdropEl);
    } else if (popup.params.backdrop) {
      if (popup.params.backdropUnique) {
        $backdropEl = $('<div class="popup-backdrop popup-backdrop-unique"></div>');
        popup.$containerEl.append($backdropEl);
      } else {
        $backdropEl = popup.$containerEl.children(".popup-backdrop");
      }
      if ($backdropEl.length === 0) {
        $backdropEl = $('<div class="popup-backdrop"></div>');
        popup.$containerEl.append($backdropEl);
      }
    }
    extend$1(popup, {
      app: app2,
      push: $el.hasClass("popup-push") || popup.params.push,
      $el,
      el: $el[0],
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0],
      type: "popup",
      $htmlEl: $("html")
    });
    if (popup.params.push) {
      $el.addClass("popup-push");
    }
    function handleClick(e) {
      const target = e.target;
      const $target = $(target);
      const keyboardOpened = !device.desktop && device.cordova && (window2.Keyboard && window2.Keyboard.isVisible || window2.cordova.plugins && window2.cordova.plugins.Keyboard && window2.cordova.plugins.Keyboard.isVisible);
      if (keyboardOpened) return;
      if ($target.closest(popup.el).length === 0) {
        if (popup.params && popup.params.closeByBackdropClick && popup.params.backdrop && popup.backdropEl && popup.backdropEl === target) {
          let needToClose = true;
          popup.$el.nextAll(".popup.modal-in").each((popupEl) => {
            const popupInstance = popupEl.f7Modal;
            if (!popupInstance) return;
            if (popupInstance.params.closeByBackdropClick && popupInstance.params.backdrop && popupInstance.backdropEl === popup.backdropEl) {
              needToClose = false;
            }
          });
          if (needToClose) {
            popup.close();
          }
        }
      }
    }
    function onKeyDown(e) {
      const keyCode = e.keyCode;
      if (keyCode === 27 && popup.params.closeOnEscape) {
        popup.close();
      }
    }
    let pushOffset;
    let isPush;
    function pushViewScale(offset2) {
      return (app2.height - offset2 * 2) / app2.height;
    }
    let allowSwipeToClose = true;
    let isTouched = false;
    let startTouch;
    let currentTouch;
    let isScrolling;
    let touchStartTime;
    let touchesDiff;
    let isMoved = false;
    let pageContentEl;
    let pageContentScrollTop;
    let pageContentOffsetHeight;
    let pageContentScrollHeight;
    let popupHeight;
    let $pushEl;
    function handleTouchStart(e) {
      if (isTouched || !allowSwipeToClose || !popup.params.swipeToClose || !e.isTrusted) return;
      if (popup.params.swipeHandler && $(e.target).closest(popup.params.swipeHandler).length === 0) {
        return;
      }
      if ($(e.target).closest(".sortable-handler").length > 0) return;
      isTouched = true;
      isMoved = false;
      startTouch = {
        x: e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX,
        y: e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY
      };
      touchStartTime = now$1();
      isScrolling = void 0;
      if (!popup.params.swipeHandler && e.type === "touchstart") {
        pageContentEl = $(e.target).closest(".page-content")[0];
      }
    }
    function handleTouchMove(e) {
      if (!isTouched || !e.isTrusted) return;
      currentTouch = {
        x: e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX,
        y: e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY
      };
      if (typeof isScrolling === "undefined") {
        isScrolling = !!(isScrolling || Math.abs(currentTouch.x - startTouch.x) > Math.abs(currentTouch.y - startTouch.y));
      }
      if (isScrolling) {
        isTouched = false;
        isMoved = false;
        return;
      }
      touchesDiff = startTouch.y - currentTouch.y;
      if (isPush && pushOffset && touchesDiff > 0) {
        touchesDiff = 0;
      }
      const direction = touchesDiff < 0 ? "to-bottom" : "to-top";
      $el.transition(0);
      if (typeof popup.params.swipeToClose === "string" && direction !== popup.params.swipeToClose) {
        $el.transform("");
        $el.transition("");
        return;
      }
      if (!isMoved) {
        if (isPush && pushOffset) {
          popupHeight = $el[0].offsetHeight;
          $pushEl = $el.prevAll(".popup.modal-in").eq(0);
          if ($pushEl.length === 0) {
            $pushEl = app2.$el.children(".view, .views");
          }
        }
        if (pageContentEl) {
          pageContentScrollTop = pageContentEl.scrollTop;
          pageContentScrollHeight = pageContentEl.scrollHeight;
          pageContentOffsetHeight = pageContentEl.offsetHeight;
          if (!(pageContentScrollHeight === pageContentOffsetHeight) && !(direction === "to-bottom" && pageContentScrollTop === 0) && !(direction === "to-top" && pageContentScrollTop === pageContentScrollHeight - pageContentOffsetHeight)) {
            $el.transform("");
            $el.transition("");
            isTouched = false;
            isMoved = false;
            return;
          }
        }
        isMoved = true;
        popup.emit("local::swipeStart popupSwipeStart", popup);
        popup.$el.trigger("popup:swipestart");
      } else {
        popup.emit("local::swipeMove popupSwipeMove", popup);
        popup.$el.trigger("popup:swipemove");
      }
      e.preventDefault();
      if (isPush && pushOffset) {
        const pushProgress = 1 - Math.abs(touchesDiff / popupHeight);
        const scale = 1 - (1 - pushViewScale(pushOffset)) * pushProgress;
        if ($pushEl.hasClass("popup")) {
          if ($pushEl.hasClass("popup-push")) {
            $pushEl.transition(0).forEach((el) => {
              el.style.setProperty("transform", `translate3d(0, calc(-1 * ${pushProgress} * (var(--f7-popup-push-offset) + 10px)) , 0px) scale(${scale})`, "important");
            });
          } else {
            $pushEl.transition(0).forEach((el) => {
              el.style.setProperty("transform", `translate3d(0, 0px , 0px) scale(${scale})`, "important");
            });
          }
        } else {
          $pushEl.transition(0).forEach((el) => {
            el.style.setProperty("transform", `translate3d(0,0,0) scale(${scale})`, "important");
          });
        }
      }
      $el.transition(0).transform(`translate3d(0,${-touchesDiff}px,0)`);
    }
    function handleTouchEnd(e) {
      if (!e.isTrusted) return;
      isTouched = false;
      if (!isMoved) {
        return;
      }
      popup.emit("local::swipeEnd popupSwipeEnd", popup);
      popup.$el.trigger("popup:swipeend");
      isMoved = false;
      allowSwipeToClose = false;
      $el.transition("");
      if (isPush && pushOffset) {
        $pushEl.transition("").transform("");
      }
      const direction = touchesDiff <= 0 ? "to-bottom" : "to-top";
      if (typeof popup.params.swipeToClose === "string" && direction !== popup.params.swipeToClose) {
        $el.transform("");
        allowSwipeToClose = true;
        return;
      }
      const diff = Math.abs(touchesDiff);
      const timeDiff = (/* @__PURE__ */ new Date()).getTime() - touchStartTime;
      if (timeDiff < 300 && diff > 20 || timeDiff >= 300 && diff > 100) {
        nextTick(() => {
          if (direction === "to-bottom") {
            $el.addClass("swipe-close-to-bottom");
          } else {
            $el.addClass("swipe-close-to-top");
          }
          $el.transform("");
          popup.emit("local::swipeclose popupSwipeClose", popup);
          popup.$el.trigger("popup:swipeclose");
          popup.close();
          allowSwipeToClose = true;
        });
        return;
      }
      allowSwipeToClose = true;
      $el.transform("");
    }
    const passive = support2.passiveListener ? {
      passive: true
    } : false;
    if (popup.params.swipeToClose) {
      $el.on(app2.touchEvents.start, handleTouchStart, passive);
      app2.on("touchmove", handleTouchMove);
      app2.on("touchend:passive", handleTouchEnd);
      popup.once("popupDestroy", () => {
        $el.off(app2.touchEvents.start, handleTouchStart, passive);
        app2.off("touchmove", handleTouchMove);
        app2.off("touchend:passive", handleTouchEnd);
      });
    }
    let hasPreviousPushPopup;
    const updatePushOffset = () => {
      const wasPush = isPush;
      if (popup.push) {
        isPush = popup.push && (app2.width < 630 || app2.height < 630 || $el.hasClass("popup-tablet-fullscreen"));
      }
      if (isPush && !wasPush) {
        setPushOffset();
      } else if (isPush && wasPush) {
        popup.$htmlEl[0].style.setProperty("--f7-popup-push-scale", pushViewScale(pushOffset));
      } else if (!isPush && wasPush) {
        popup.$htmlEl.removeClass("with-modal-popup-push");
        popup.$htmlEl[0].style.removeProperty("--f7-popup-push-scale");
      }
    };
    const setPushOffset = () => {
      app2.off("resize", updatePushOffset);
      if (popup.push) {
        isPush = popup.push && (app2.width < 630 || app2.height < 630 || $el.hasClass("popup-tablet-fullscreen"));
      }
      if (isPush) {
        pushOffset = parseInt($el.css("--f7-popup-push-offset"), 10);
        if (Number.isNaN(pushOffset)) {
          pushOffset = 0;
        }
        if (!pushOffset) pushOffset = app2.theme === "ios" ? 44 : 48;
        popup.$htmlEl[0].style.setProperty("--f7-popup-push-offset", `${pushOffset}px`);
        $el.addClass("popup-push");
        popup.$htmlEl.addClass("with-modal-popup-push");
        popup.$htmlEl[0].style.setProperty("--f7-popup-push-scale", pushViewScale(pushOffset));
      }
      app2.on("resize", updatePushOffset);
    };
    popup.on("open", () => {
      hasPreviousPushPopup = false;
      if (popup.params.closeOnEscape) {
        $(document2).on("keydown", onKeyDown);
      }
      $el.prevAll(".popup.modal-in").addClass("popup-behind");
      setPushOffset();
    });
    popup.on("opened", () => {
      $el.removeClass("swipe-close-to-bottom swipe-close-to-top");
      if (popup.params.closeByBackdropClick) {
        app2.on("click", handleClick);
      }
    });
    popup.on("close", () => {
      hasPreviousPushPopup = popup.$el.prevAll(".popup-push.modal-in").length > 0;
      if (popup.params.closeOnEscape) {
        $(document2).off("keydown", onKeyDown);
      }
      if (popup.params.closeByBackdropClick) {
        app2.off("click", handleClick);
      }
      $el.prevAll(".popup.modal-in").eq(0).removeClass("popup-behind");
      if (isPush && pushOffset && !hasPreviousPushPopup) {
        popup.$htmlEl.removeClass("with-modal-popup-push");
        popup.$htmlEl.addClass("with-modal-popup-push-closing");
      }
      app2.off("resize", updatePushOffset);
    });
    popup.on("closed", () => {
      $el.removeClass("popup-behind");
      if (isPush && pushOffset && !hasPreviousPushPopup) {
        popup.$htmlEl.removeClass("with-modal-popup-push-closing");
        popup.$htmlEl[0].style.removeProperty("--f7-popup-push-scale");
        popup.$htmlEl[0].style.removeProperty("--f7-popup-push-offset");
      }
    });
    $el[0].f7Modal = popup;
    return popup;
  }
};
const Popup$1 = {
  name: "popup",
  params: {
    popup: {
      backdrop: true,
      backdropEl: void 0,
      backdropUnique: false,
      closeByBackdropClick: true,
      closeOnEscape: false,
      swipeToClose: false,
      swipeHandler: null,
      push: false,
      containerEl: null
    }
  },
  static: {
    Popup: Popup$2
  },
  create() {
    const app2 = this;
    app2.popup = ModalMethods({
      app: app2,
      constructor: Popup$2,
      defaultSelector: ".popup.modal-in",
      parentSelector: ".popup"
    });
  },
  clicks: {
    ".popup-open": function openPopup($clickedEl, data2) {
      if (data2 === void 0) {
        data2 = {};
      }
      const app2 = this;
      app2.popup.open(data2.popup, data2.animate, $clickedEl);
    },
    ".popup-close": function closePopup($clickedEl, data2) {
      if (data2 === void 0) {
        data2 = {};
      }
      const app2 = this;
      app2.popup.close(data2.popup, data2.animate, $clickedEl);
    }
  }
};
let Popover$1 = class Popover extends Modal$1 {
  constructor(app2, params) {
    const extendedParams = extend$1({
      on: {}
    }, app2.params.popover, params);
    super(app2, extendedParams);
    const popover = this;
    const device = getDevice();
    const window2 = getWindow();
    const document2 = getDocument();
    popover.params = extendedParams;
    let $el;
    if (!popover.params.el) {
      $el = $(popover.params.content).filter((node) => node.nodeType === 1).eq(0);
    } else {
      $el = $(popover.params.el).eq(0);
    }
    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }
    const $targetEl = $(popover.params.targetEl).eq(0);
    if ($el.length === 0) {
      return popover.destroy();
    }
    let $backdropEl;
    const forceBackdropUnique = popover.params.backdrop && app2.$el.find(".popover.modal-in").filter((anotherPopoverEl) => anotherPopoverEl !== $el[0]).length > 0;
    if (popover.params.backdrop && popover.params.backdropEl) {
      $backdropEl = $(popover.params.backdropEl);
    } else if (popover.params.backdrop) {
      if (popover.params.backdropUnique || forceBackdropUnique) {
        $backdropEl = $('<div class="popover-backdrop popover-backdrop-unique"></div>');
        $backdropEl[0].f7PopoverRef = popover;
        popover.$containerEl.append($backdropEl);
      } else {
        $backdropEl = popover.$containerEl.children(".popover-backdrop");
      }
      if ($backdropEl.length === 0) {
        $backdropEl = $('<div class="popover-backdrop"></div>');
        popover.$containerEl.append($backdropEl);
      }
    }
    let $arrowEl;
    if ($el.find(".popover-arrow").length === 0 && popover.params.arrow) {
      $arrowEl = $('<div class="popover-arrow"></div>');
      $el.prepend($arrowEl);
    } else {
      $arrowEl = $el.find(".popover-arrow");
    }
    const originalOpen = popover.open;
    extend$1(popover, {
      app: app2,
      $el,
      el: $el[0],
      $targetEl,
      targetEl: $targetEl[0],
      $arrowEl,
      arrowEl: $arrowEl[0],
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0],
      type: "popover",
      forceBackdropUnique,
      open() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        let [targetEl, animate2] = args;
        if (typeof args[0] === "boolean") [animate2, targetEl] = args;
        if (targetEl) {
          popover.$targetEl = $(targetEl);
          popover.targetEl = popover.$targetEl[0];
        }
        return originalOpen.call(popover, animate2);
      }
    });
    function handleResize() {
      popover.resize();
    }
    popover.on("popoverOpen", () => {
      popover.resize();
      app2.on("resize", handleResize);
      $(window2).on("keyboardDidShow keyboardDidHide", handleResize);
      popover.on("popoverClose popoverBeforeDestroy", () => {
        app2.off("resize", handleResize);
        $(window2).off("keyboardDidShow keyboardDidHide", handleResize);
      });
    });
    let touchStartTarget = null;
    function handleTouchStart(e) {
      touchStartTarget = e.target;
    }
    function handleClick(e) {
      const target = e.target;
      const $target = $(target);
      const keyboardOpened = !device.desktop && device.cordova && (window2.Keyboard && window2.Keyboard.isVisible || window2.cordova.plugins && window2.cordova.plugins.Keyboard && window2.cordova.plugins.Keyboard.isVisible);
      if (keyboardOpened) return;
      if ($target.closest(popover.el).length === 0) {
        if (popover.params.closeByBackdropClick && popover.params.backdrop && popover.backdropEl && popover.backdropEl === target && touchStartTarget === target) {
          popover.close();
        } else if (popover.params.closeByOutsideClick && touchStartTarget === target) {
          const isAnotherPopoverBackdrop = $target.hasClass("popover-backdrop-unique") && target.f7PopoverRef !== popover || $target.hasClass("popover-backdrop") && target !== popover.backdropEl;
          const isAnotherPopoverTarget = target.closest(".popover") && target.closest(".popover") !== popover.$el[0];
          if (!isAnotherPopoverBackdrop && !isAnotherPopoverTarget) {
            popover.close();
          }
        }
      }
    }
    function onKeyDown(e) {
      const keyCode = e.keyCode;
      if (keyCode === 27 && popover.params.closeOnEscape) {
        popover.close();
      }
    }
    if (popover.params.closeOnEscape) {
      popover.on("popoverOpen", () => {
        $(document2).on("keydown", onKeyDown);
      });
      popover.on("popoverClose", () => {
        $(document2).off("keydown", onKeyDown);
      });
    }
    popover.on("popoverOpened", () => {
      if (popover.params.closeByOutsideClick || popover.params.closeByBackdropClick) {
        app2.on("touchstart", handleTouchStart);
        app2.on("click", handleClick);
      }
    });
    popover.on("popoverClose", () => {
      if (popover.params.closeByOutsideClick || popover.params.closeByBackdropClick) {
        app2.off("touchstart", handleTouchStart);
        app2.off("click", handleClick);
      }
    });
    $el[0].f7Modal = popover;
    return popover;
  }
  resize() {
    const popover = this;
    const {
      app: app2,
      $el,
      $targetEl,
      $arrowEl
    } = popover;
    const {
      targetX,
      targetY,
      verticalPosition
    } = popover.params;
    $el.css({
      left: "",
      top: ""
    });
    const [width2, height2] = [$el.width(), $el.height()];
    let arrowSize = 0;
    let arrowLeft;
    let arrowTop;
    const hasArrow = $arrowEl.length > 0;
    const arrowMin = app2.theme === "ios" ? 13 : 24;
    if (hasArrow) {
      $arrowEl.removeClass("on-left on-right on-top on-bottom").css({
        left: "",
        top: ""
      });
      arrowSize = $arrowEl.width() / 2;
    }
    $el.removeClass("popover-on-left popover-on-right popover-on-top popover-on-bottom popover-on-middle").css({
      left: "",
      top: ""
    });
    let targetWidth;
    let targetHeight;
    let targetOffsetLeft;
    let targetOffsetTop;
    let safeAreaTop = parseInt($("html").css("--f7-safe-area-top"), 10);
    let safeAreaLeft = parseInt($("html").css("--f7-safe-area-left"), 10);
    let safeAreaRight = parseInt($("html").css("--f7-safe-area-right"), 10);
    if (Number.isNaN(safeAreaTop)) safeAreaTop = 0;
    if (Number.isNaN(safeAreaLeft)) safeAreaLeft = 0;
    if (Number.isNaN(safeAreaRight)) safeAreaRight = 0;
    if ($targetEl && $targetEl.length > 0) {
      targetWidth = $targetEl.outerWidth();
      targetHeight = $targetEl.outerHeight();
      const targetOffset = $targetEl.offset();
      targetOffsetLeft = targetOffset.left - app2.left;
      targetOffsetTop = targetOffset.top - app2.top;
      const targetParentPage = $targetEl.parents(".page");
      if (targetParentPage.length > 0) {
        targetOffsetTop -= targetParentPage[0].scrollTop;
      }
    } else if (typeof targetX !== "undefined" && targetY !== "undefined") {
      targetOffsetLeft = targetX;
      targetOffsetTop = targetY;
      targetWidth = popover.params.targetWidth || 0;
      targetHeight = popover.params.targetHeight || 0;
    }
    let [left, top, diff] = [0, 0, 0];
    const forcedPosition = verticalPosition === "auto" ? false : verticalPosition;
    let position = forcedPosition || "top";
    if (forcedPosition === "top" || !forcedPosition && height2 + arrowSize < targetOffsetTop - safeAreaTop) {
      top = targetOffsetTop - height2 - arrowSize;
    } else if (forcedPosition === "bottom" || !forcedPosition && height2 + arrowSize < app2.height - targetOffsetTop - targetHeight) {
      position = "bottom";
      top = targetOffsetTop + targetHeight + arrowSize;
    } else {
      position = "middle";
      top = targetHeight / 2 + targetOffsetTop - height2 / 2;
      diff = top;
      top = Math.max(5, Math.min(top, app2.height - height2 - 5));
      diff -= top;
    }
    if (position === "top" || position === "bottom") {
      left = targetWidth / 2 + targetOffsetLeft - width2 / 2;
      diff = left;
      left = Math.max(5, Math.min(left, app2.width - width2 - 5));
      if (safeAreaLeft) {
        left = Math.max(left, safeAreaLeft);
      }
      if (safeAreaRight && left + width2 > app2.width - 5 - safeAreaRight) {
        left = app2.width - 5 - safeAreaRight - width2;
      }
      diff -= left;
      if (hasArrow) {
        if (position === "top") {
          $arrowEl.addClass("on-bottom");
        }
        if (position === "bottom") {
          $arrowEl.addClass("on-top");
        }
        arrowLeft = width2 / 2 - arrowSize + diff;
        arrowLeft = Math.max(Math.min(arrowLeft, width2 - arrowSize * 2 - arrowMin), arrowMin);
        $arrowEl.css({
          left: `${arrowLeft}px`
        });
      }
    } else if (position === "middle") {
      left = targetOffsetLeft - width2 - arrowSize;
      if (hasArrow) $arrowEl.addClass("on-right");
      if (left < 5 || left + width2 + safeAreaRight > app2.width || left < safeAreaLeft) {
        if (left < 5) left = targetOffsetLeft + targetWidth + arrowSize;
        if (left + width2 + safeAreaRight > app2.width) left = app2.width - width2 - 5 - safeAreaRight;
        if (left < safeAreaLeft) left = safeAreaLeft;
        if (hasArrow) $arrowEl.removeClass("on-right").addClass("on-left");
      }
      if (hasArrow) {
        arrowTop = height2 / 2 - arrowSize + diff;
        arrowTop = Math.max(Math.min(arrowTop, height2 - arrowSize * 2 - arrowMin), arrowMin);
        $arrowEl.css({
          top: `${arrowTop}px`
        });
      }
    }
    let hPosition;
    if (targetOffsetLeft < app2.width / 2) {
      hPosition = "right";
    } else {
      hPosition = "left";
    }
    $el.addClass(`popover-on-${position} popover-on-${hPosition}`);
    $el.css({
      top: `${top}px`,
      left: `${left}px`
    });
  }
};
const PopoverComponent = {
  name: "popover",
  params: {
    popover: {
      verticalPosition: "auto",
      arrow: true,
      backdrop: true,
      backdropEl: void 0,
      backdropUnique: false,
      closeByBackdropClick: true,
      closeByOutsideClick: true,
      closeOnEscape: false,
      containerEl: null
    }
  },
  static: {
    Popover: Popover$1
  },
  create() {
    const app2 = this;
    app2.popover = extend$1(ModalMethods({
      app: app2,
      constructor: Popover$1,
      defaultSelector: ".popover.modal-in"
    }), {
      open(popoverEl, targetEl, animate2) {
        let $popoverEl = $(popoverEl);
        if ($popoverEl.length > 1) {
          const $targetPage = $(targetEl).parents(".page");
          if ($targetPage.length) {
            $popoverEl.each((el) => {
              const $el = $(el);
              if ($el.parents($targetPage)[0] === $targetPage[0]) {
                $popoverEl = $el;
              }
            });
          }
        }
        if ($popoverEl.length > 1) {
          $popoverEl = $popoverEl.eq($popoverEl.length - 1);
        }
        let popover = $popoverEl[0].f7Modal;
        const data2 = $popoverEl.dataset();
        if (!popover) {
          popover = new Popover$1(app2, Object.assign({
            el: $popoverEl,
            targetEl
          }, data2));
        }
        return popover.open(targetEl, animate2);
      }
    });
  },
  clicks: {
    ".popover-open": function openPopover($clickedEl, data2) {
      if (data2 === void 0) {
        data2 = {};
      }
      const app2 = this;
      app2.popover.open(data2.popover, $clickedEl, data2.animate);
    },
    ".popover-close": function closePopover($clickedEl, data2) {
      if (data2 === void 0) {
        data2 = {};
      }
      const app2 = this;
      app2.popover.close(data2.popover, data2.animate, $clickedEl);
    }
  }
};
function pickerColumn(colEl, updateItems) {
  const picker = this;
  const $colEl = $(colEl);
  const colIndex = $colEl.index();
  const col = picker.cols[colIndex];
  if (col.divider) return;
  col.$el = $colEl;
  col.el = $colEl[0];
  col.$itemsEl = col.$el.find(".picker-items");
  col.items = col.$itemsEl.find(".picker-item");
  let itemHeight;
  let colHeight;
  col.replaceValues = function replaceColValues(values, displayValues) {
    col.detachEvents();
    col.values = values;
    col.displayValues = displayValues;
    col.$itemsEl.html(picker.renderColumn(col, true));
    col.items = col.$itemsEl.find(".picker-item");
    col.calcSize();
    col.setValue(col.values[0], true);
    col.attachEvents();
  };
  col.calcSize = function calcColSize() {
    colHeight = col.$el[0].offsetHeight;
    itemHeight = col.items[0].offsetHeight;
    const hadPadding = col.el.style.getPropertyValue("--f7-picker-scroll-padding");
    col.el.style.setProperty("--f7-picker-scroll-padding", `${(colHeight - itemHeight) / 2}px`);
    if (!hadPadding) {
      col.$itemsEl[0].scrollTop = 0;
    }
  };
  col.setValue = function setColValue(newValue, valueCallbacks) {
    const newActiveIndex = col.$itemsEl.find(`.picker-item[data-picker-value="${newValue}"]`).index();
    if (typeof newActiveIndex === "undefined" || newActiveIndex === -1) {
      return;
    }
    const newScrollTop = newActiveIndex * itemHeight;
    col.$itemsEl[0].scrollTop = newScrollTop;
    col.updateItems(newActiveIndex, newScrollTop, valueCallbacks);
  };
  col.updateItems = function updateColItems(activeIndex, scrollTop2, valueCallbacks) {
    if (typeof scrollTop2 === "undefined") {
      scrollTop2 = col.$itemsEl[0].scrollTop;
    }
    if (typeof activeIndex === "undefined") {
      activeIndex = Math.round(scrollTop2 / itemHeight);
    }
    if (activeIndex < 0) activeIndex = 0;
    if (activeIndex >= col.items.length) activeIndex = col.items.length - 1;
    const previousActiveIndex = col.activeIndex;
    col.activeIndex = activeIndex;
    col.$itemsEl.find(".picker-item-selected").removeClass("picker-item-selected");
    const selectedItem = col.items.eq(activeIndex);
    selectedItem.addClass("picker-item-selected").children().transform("");
    if (picker.params.rotateEffect) {
      col.items.each((itemEl) => {
        const $itemEl = $(itemEl);
        const itemOffset = itemEl.offsetTop - (colHeight - itemHeight) / 2 - scrollTop2;
        const percentage = itemOffset / itemHeight;
        const itemsFit = Math.ceil(col.height / itemHeight / 2) + 1;
        let angle = -24 * percentage;
        if (angle > 180) angle = 180;
        if (angle < -180) angle = -180;
        if (Math.abs(percentage) > itemsFit) {
          $itemEl.addClass("picker-item-far");
        } else {
          $itemEl.removeClass("picker-item-far");
        }
        $itemEl.children("span").transform(`translate3d(0, ${-percentage * itemHeight}px, -100px) rotateX(${angle}deg)`);
      });
    }
    if (valueCallbacks || typeof valueCallbacks === "undefined") {
      col.value = selectedItem.attr("data-picker-value");
      col.displayValue = col.displayValues ? col.displayValues[activeIndex] : col.value;
      if (previousActiveIndex !== activeIndex) {
        if (col.onChange) {
          col.onChange(picker, col.value, col.displayValue);
        }
        picker.updateValue();
      }
    }
  };
  function handleScroll() {
    col.updateItems();
  }
  function handleClick() {
    const value2 = $(this).attr("data-picker-value");
    col.setValue(value2);
  }
  col.attachEvents = function attachColEvents() {
    col.$itemsEl.on("scroll", handleScroll);
    col.items.on("click", handleClick);
  };
  col.detachEvents = function detachColEvents() {
    col.items.off("click", handleClick);
  };
  col.init = function initCol() {
    col.calcSize();
    if (colIndex === 0) col.$el.addClass("picker-column-first");
    if (colIndex === picker.cols.length - 1) col.$el.addClass("picker-column-last");
    if (picker.params.freeMode) col.$el.addClass("picker-column-free-mode");
    if (updateItems) col.updateItems(0);
    col.attachEvents();
  };
  col.destroy = function destroyCol() {
    col.detachEvents();
  };
  col.init();
}
class Picker extends Framework7Class {
  constructor(app2, params) {
    if (params === void 0) {
      params = {};
    }
    super(params, [app2]);
    const picker = this;
    const device = getDevice();
    const window2 = getWindow();
    picker.params = extend$1({}, app2.params.picker, params);
    let $containerEl;
    if (picker.params.containerEl) {
      $containerEl = $(picker.params.containerEl);
      if ($containerEl.length === 0) return picker;
    }
    let $inputEl;
    if (picker.params.inputEl) {
      $inputEl = $(picker.params.inputEl);
    }
    let $scrollToEl = picker.params.scrollToInput ? $inputEl : void 0;
    if (picker.params.scrollToEl) {
      const scrollToEl = $(picker.params.scrollToEl);
      if (scrollToEl.length > 0) {
        $scrollToEl = scrollToEl;
      }
    }
    extend$1(picker, {
      app: app2,
      $containerEl,
      containerEl: $containerEl && $containerEl[0],
      inline: $containerEl && $containerEl.length > 0,
      needsOriginFix: device.ios || window2.navigator.userAgent.toLowerCase().indexOf("safari") >= 0 && window2.navigator.userAgent.toLowerCase().indexOf("chrome") < 0 && !device.android,
      cols: [],
      $inputEl,
      inputEl: $inputEl && $inputEl[0],
      $scrollToEl,
      initialized: false,
      opened: false,
      url: picker.params.url
    });
    function onResize() {
      picker.resizeCols();
    }
    function onInputClick() {
      picker.open();
    }
    function onInputFocus(e) {
      e.preventDefault();
    }
    let htmlTouchStartTarget = null;
    function onHtmlTouchStart(e) {
      htmlTouchStartTarget = e.target;
    }
    function onHtmlClick(e) {
      if (picker.destroyed || !picker.params) return;
      const $targetEl = $(e.target);
      if (picker.isPopover()) return;
      if (!picker.opened || picker.closing) return;
      if ($targetEl.closest('[class*="backdrop"]').length) return;
      if ($inputEl && $inputEl.length > 0) {
        if (htmlTouchStartTarget === e.target && $targetEl[0] !== $inputEl[0] && $targetEl.closest(".sheet-modal").length === 0) {
          picker.close();
        }
      } else if ($(e.target).closest(".sheet-modal").length === 0) {
        picker.close();
      }
    }
    extend$1(picker, {
      attachResizeEvent() {
        app2.on("resize", onResize);
      },
      detachResizeEvent() {
        app2.off("resize", onResize);
      },
      attachInputEvents() {
        picker.$inputEl.on("click", onInputClick);
        if (picker.params.inputReadOnly) {
          picker.$inputEl.on("focus mousedown", onInputFocus);
          if (picker.$inputEl[0]) {
            picker.$inputEl[0].f7ValidateReadonly = true;
          }
        }
      },
      detachInputEvents() {
        picker.$inputEl.off("click", onInputClick);
        if (picker.params.inputReadOnly) {
          picker.$inputEl.off("focus mousedown", onInputFocus);
          if (picker.$inputEl[0]) {
            delete picker.$inputEl[0].f7ValidateReadonly;
          }
        }
      },
      attachHtmlEvents() {
        app2.on("click", onHtmlClick);
        app2.on("touchstart", onHtmlTouchStart);
      },
      detachHtmlEvents() {
        app2.off("click", onHtmlClick);
        app2.off("touchstart", onHtmlTouchStart);
      }
    });
    picker.init();
    return picker;
  }
  get view() {
    const {
      app: app2,
      params,
      $inputEl
    } = this;
    let view;
    if (params.view) {
      view = params.view;
    } else if ($inputEl) {
      view = $inputEl.parents(".view").length && $inputEl.parents(".view")[0].f7View;
    }
    if (!view) view = app2.views.main;
    return view;
  }
  initInput() {
    const picker = this;
    if (!picker.$inputEl) return;
    if (picker.params.inputReadOnly) picker.$inputEl.prop("readOnly", true);
  }
  resizeCols() {
    const picker = this;
    if (!picker.opened) return;
    for (let i = 0; i < picker.cols.length; i += 1) {
      if (!picker.cols[i].divider) {
        picker.cols[i].calcSize();
        picker.cols[i].setValue(picker.cols[i].value, false);
      }
    }
  }
  isPopover() {
    const picker = this;
    const {
      app: app2,
      modal,
      params
    } = picker;
    const device = getDevice();
    if (params.openIn === "sheet") return false;
    if (modal && modal.type !== "popover") return false;
    if (!picker.inline && picker.inputEl) {
      if (params.openIn === "popover") return true;
      if (device.ios) {
        return !!device.ipad;
      }
      if (app2.width >= 768) {
        return true;
      }
    }
    return false;
  }
  formatValue() {
    const picker = this;
    const {
      value: value2,
      displayValue
    } = picker;
    if (picker.params.formatValue) {
      return picker.params.formatValue.call(picker, value2, displayValue);
    }
    return value2.join(" ");
  }
  setValue(values) {
    const picker = this;
    let valueIndex = 0;
    if (picker.cols.length === 0) {
      picker.value = values;
      picker.updateValue(values);
      return;
    }
    for (let i = 0; i < picker.cols.length; i += 1) {
      if (picker.cols[i] && !picker.cols[i].divider) {
        picker.cols[i].setValue(values[valueIndex]);
        valueIndex += 1;
      }
    }
  }
  getValue() {
    const picker = this;
    return picker.value;
  }
  updateValue(forceValues) {
    const picker = this;
    const newValue = forceValues || [];
    const newDisplayValue = [];
    let column;
    if (picker.cols.length === 0) {
      const noDividerColumns = picker.params.cols.filter((c) => !c.divider);
      for (let i = 0; i < noDividerColumns.length; i += 1) {
        column = noDividerColumns[i];
        if (column.displayValues !== void 0 && column.values !== void 0 && column.values.indexOf(newValue[i]) !== -1) {
          newDisplayValue.push(column.displayValues[column.values.indexOf(newValue[i])]);
        } else {
          newDisplayValue.push(newValue[i]);
        }
      }
    } else {
      for (let i = 0; i < picker.cols.length; i += 1) {
        if (!picker.cols[i].divider) {
          newValue.push(picker.cols[i].value);
          newDisplayValue.push(picker.cols[i].displayValue);
        }
      }
    }
    if (newValue.indexOf(void 0) >= 0) {
      return;
    }
    picker.value = newValue;
    picker.displayValue = newDisplayValue;
    picker.emit("local::change pickerChange", picker, picker.value, picker.displayValue);
    if (picker.inputEl) {
      picker.$inputEl.val(picker.formatValue());
      picker.$inputEl.trigger("change");
    }
  }
  initColumn(colEl, updateItems) {
    const picker = this;
    pickerColumn.call(picker, colEl, updateItems);
  }
  // eslint-disable-next-line
  destroyColumn(colEl) {
    const picker = this;
    const $colEl = $(colEl);
    const index2 = $colEl.index();
    if (picker.cols[index2] && picker.cols[index2].destroy) {
      picker.cols[index2].destroy();
    }
  }
  renderToolbar() {
    const picker = this;
    if (picker.params.renderToolbar) return picker.params.renderToolbar.call(picker, picker);
    return $jsx$1("div", {
      class: "toolbar toolbar-top"
    }, $jsx$1("div", {
      class: "toolbar-inner"
    }, $jsx$1("div", {
      class: "left"
    }), $jsx$1("div", {
      class: "right"
    }, $jsx$1("a", {
      class: "link sheet-close popover-close"
    }, picker.params.toolbarCloseText))));
  }
  // eslint-disable-next-line
  renderColumn(col, onlyItems) {
    const colClasses = `picker-column ${col.textAlign ? `picker-column-${col.textAlign}` : ""} ${col.cssClass || ""}`;
    let columnHtml;
    let columnItemsHtml;
    if (col.divider) {
      columnHtml = `
        <div class="${colClasses} picker-column-divider">${col.content}</div>
      `;
    } else {
      columnItemsHtml = col.values.map((value2, index2) => `
        <div class="picker-item" data-picker-value="${value2}">
          <span>${col.displayValues ? col.displayValues[index2] : value2}</span>
        </div>
      `).join("");
      columnHtml = `
        <div class="${colClasses}">
          <div class="picker-items">${columnItemsHtml}</div>
        </div>
      `;
    }
    return onlyItems ? columnItemsHtml.trim() : columnHtml.trim();
  }
  renderInline() {
    const picker = this;
    const {
      rotateEffect,
      cssClass,
      toolbar
    } = picker.params;
    const inlineHtml = $jsx$1("div", {
      class: `picker picker-inline ${rotateEffect ? "picker-3d" : ""} ${cssClass || ""}`
    }, toolbar && picker.renderToolbar(), $jsx$1("div", {
      class: "picker-columns"
    }, picker.cols.map((col) => picker.renderColumn(col)), $jsx$1("div", {
      class: "picker-center-highlight"
    })));
    return inlineHtml;
  }
  renderSheet() {
    const picker = this;
    const {
      rotateEffect,
      cssClass,
      toolbar
    } = picker.params;
    const sheetHtml = $jsx$1("div", {
      class: `sheet-modal picker picker-sheet ${rotateEffect ? "picker-3d" : ""} ${cssClass || ""}`
    }, toolbar && picker.renderToolbar(), $jsx$1("div", {
      class: "sheet-modal-inner picker-columns"
    }, picker.cols.map((col) => picker.renderColumn(col)), $jsx$1("div", {
      class: "picker-center-highlight"
    })));
    return sheetHtml;
  }
  renderPopover() {
    const picker = this;
    const {
      rotateEffect,
      cssClass,
      toolbar
    } = picker.params;
    const popoverHtml = $jsx$1("div", {
      class: "popover picker-popover"
    }, $jsx$1("div", {
      class: "popover-inner"
    }, $jsx$1("div", {
      class: `picker ${rotateEffect ? "picker-3d" : ""} ${cssClass || ""}`
    }, toolbar && picker.renderToolbar(), $jsx$1("div", {
      class: "picker-columns"
    }, picker.cols.map((col) => picker.renderColumn(col)), $jsx$1("div", {
      class: "picker-center-highlight"
    })))));
    return popoverHtml;
  }
  render() {
    const picker = this;
    if (picker.params.render) return picker.params.render.call(picker);
    if (!picker.inline) {
      if (picker.isPopover()) return picker.renderPopover();
      return picker.renderSheet();
    }
    return picker.renderInline();
  }
  onOpen() {
    const picker = this;
    const {
      initialized,
      $el,
      app: app2,
      $inputEl,
      inline,
      value: value2,
      params
    } = picker;
    picker.opened = true;
    picker.closing = false;
    picker.opening = true;
    picker.attachResizeEvent();
    $el.find(".picker-column").each((colEl) => {
      let updateItems = true;
      if (!initialized && params.value || initialized && value2) {
        updateItems = false;
      }
      picker.initColumn(colEl, updateItems);
    });
    if (!initialized) {
      if (value2) picker.setValue(value2);
      else if (params.value) {
        picker.setValue(params.value);
      }
    } else if (value2) {
      picker.setValue(value2);
    }
    if (!inline && $inputEl && $inputEl.length && app2.theme === "md") {
      $inputEl.trigger("focus");
    }
    picker.initialized = true;
    if ($el) {
      $el.trigger("picker:open");
    }
    if ($inputEl) {
      $inputEl.trigger("picker:open");
    }
    picker.emit("local::open pickerOpen", picker);
  }
  onOpened() {
    const picker = this;
    picker.opening = false;
    if (picker.$el) {
      picker.$el.trigger("picker:opened");
    }
    if (picker.$inputEl) {
      picker.$inputEl.trigger("picker:opened");
    }
    picker.emit("local::opened pickerOpened", picker);
  }
  onClose() {
    const picker = this;
    const app2 = picker.app;
    picker.opening = false;
    picker.closing = true;
    picker.detachResizeEvent();
    picker.cols.forEach((col) => {
      if (col.destroy) col.destroy();
    });
    if (picker.$inputEl) {
      if (app2.theme === "md") {
        picker.$inputEl.trigger("blur");
      } else {
        const validate = picker.$inputEl.attr("validate");
        const required = picker.$inputEl.attr("required");
        if (validate && required) {
          app2.input.validate(picker.$inputEl);
        }
      }
    }
    if (picker.$el) {
      picker.$el.trigger("picker:close");
    }
    if (picker.$inputEl) {
      picker.$inputEl.trigger("picker:close");
    }
    picker.emit("local::close pickerClose", picker);
  }
  onClosed() {
    const picker = this;
    picker.opened = false;
    picker.closing = false;
    if (!picker.inline) {
      nextTick(() => {
        if (picker.modal && picker.modal.el && picker.modal.destroy) {
          if (!picker.params.routableModals) {
            picker.modal.destroy();
          }
        }
        delete picker.modal;
      });
    }
    if (picker.$el) {
      picker.$el.trigger("picker:closed");
    }
    if (picker.$inputEl) {
      picker.$inputEl.trigger("picker:closed");
    }
    picker.emit("local::closed pickerClosed", picker);
  }
  open() {
    const picker = this;
    const {
      app: app2,
      opened,
      inline,
      $inputEl,
      $scrollToEl,
      params
    } = picker;
    if (opened) return;
    if (picker.cols.length === 0 && params.cols.length) {
      params.cols.forEach((col) => {
        picker.cols.push(col);
      });
    }
    if (inline) {
      picker.$el = $(picker.render());
      picker.$el[0].f7Picker = picker;
      picker.$containerEl.append(picker.$el);
      picker.onOpen();
      picker.onOpened();
      return;
    }
    const isPopover = picker.isPopover();
    const modalType = isPopover ? "popover" : "sheet";
    const modalParams = {
      targetEl: $inputEl,
      scrollToEl: $scrollToEl,
      content: picker.render(),
      backdrop: typeof params.backdrop !== "undefined" ? params.backdrop : isPopover,
      on: {
        open() {
          const modal = this;
          picker.modal = modal;
          picker.$el = isPopover ? modal.$el.find(".picker") : modal.$el;
          picker.$el[0].f7Picker = picker;
          picker.onOpen();
        },
        opened() {
          picker.onOpened();
        },
        close() {
          picker.onClose();
        },
        closed() {
          picker.onClosed();
        }
      }
    };
    if (modalType === "sheet") {
      modalParams.push = params.sheetPush;
      modalParams.swipeToClose = params.sheetSwipeToClose;
    }
    if (params.routableModals && picker.view) {
      picker.view.router.navigate({
        url: picker.url,
        route: {
          path: picker.url,
          [modalType]: modalParams
        }
      });
    } else {
      picker.modal = app2[modalType].create(modalParams);
      picker.modal.open();
    }
  }
  close() {
    const picker = this;
    const {
      opened,
      inline
    } = picker;
    if (!opened) return;
    if (inline) {
      picker.onClose();
      picker.onClosed();
      return;
    }
    if (picker.params.routableModals && picker.view) {
      picker.view.router.back();
    } else {
      picker.modal.close();
    }
  }
  init() {
    const picker = this;
    picker.initInput();
    if (picker.inline) {
      picker.open();
      picker.emit("local::init pickerInit", picker);
      return;
    }
    if (!picker.initialized && picker.params.value) {
      picker.setValue(picker.params.value);
    }
    if (picker.$inputEl) {
      picker.attachInputEvents();
    }
    if (picker.params.closeByOutsideClick) {
      picker.attachHtmlEvents();
    }
    picker.emit("local::init pickerInit", picker);
  }
  destroy() {
    const picker = this;
    if (picker.destroyed) return;
    const {
      $el
    } = picker;
    picker.emit("local::beforeDestroy pickerBeforeDestroy", picker);
    if ($el) $el.trigger("picker:beforedestroy");
    picker.close();
    if (picker.$inputEl) {
      picker.detachInputEvents();
    }
    if (picker.params.closeByOutsideClick) {
      picker.detachHtmlEvents();
    }
    if ($el && $el.length) delete picker.$el[0].f7Picker;
    deleteProps(picker);
    picker.destroyed = true;
  }
}
const PickerComponent = {
  name: "picker",
  static: {
    Picker
  },
  create() {
    const app2 = this;
    app2.picker = ConstructorMethods({
      defaultSelector: ".picker",
      constructor: Picker,
      app: app2,
      domProp: "f7Picker"
    });
    app2.picker.close = function close4(el) {
      if (el === void 0) {
        el = ".picker";
      }
      const $el = $(el);
      if ($el.length === 0) return;
      const picker = $el[0].f7Picker;
      if (!picker || picker && !picker.opened) return;
      picker.close();
    };
  },
  params: {
    picker: {
      // Picker settings
      rotateEffect: false,
      freeMode: false,
      cols: [],
      // Common opener settings
      containerEl: null,
      openIn: "auto",
      // or 'popover' or 'sheet'
      sheetPush: false,
      sheetSwipeToClose: void 0,
      backdrop: void 0,
      // uses Popover or Sheet defaults
      formatValue: null,
      inputEl: null,
      inputReadOnly: true,
      closeByOutsideClick: true,
      scrollToInput: true,
      scrollToEl: void 0,
      toolbar: true,
      toolbarCloseText: "Done",
      cssClass: null,
      routableModals: false,
      view: null,
      url: "select/",
      // Render functions
      renderToolbar: null,
      render: null
    }
  }
};
let Calendar$1 = class Calendar extends Framework7Class {
  constructor(app2, params) {
    if (params === void 0) {
      params = {};
    }
    super(params, [app2]);
    const calendar = this;
    calendar.params = extend$1({}, app2.params.calendar, params);
    let $containerEl;
    if (calendar.params.containerEl) {
      $containerEl = $(calendar.params.containerEl);
      if ($containerEl.length === 0) return calendar;
    }
    let $inputEl;
    if (calendar.params.inputEl) {
      $inputEl = $(calendar.params.inputEl);
    }
    const isHorizontal = calendar.params.direction === "horizontal";
    let inverter = 1;
    if (isHorizontal) {
      inverter = app2.rtl ? -1 : 1;
    }
    extend$1(calendar, {
      app: app2,
      $containerEl,
      containerEl: $containerEl && $containerEl[0],
      inline: $containerEl && $containerEl.length > 0,
      $inputEl,
      inputEl: $inputEl && $inputEl[0],
      initialized: false,
      opened: false,
      url: calendar.params.url,
      isHorizontal,
      inverter,
      animating: false,
      allowTouchMove: true,
      hasTimePicker: calendar.params.timePicker && !calendar.params.rangePicker && !calendar.params.multiple
    });
    calendar.dayFormatter = (date) => {
      const formatter = new Intl.DateTimeFormat(calendar.params.locale, {
        day: "numeric"
      });
      return formatter.format(date).replace(//, "");
    };
    calendar.monthFormatter = (date) => {
      const formatter = new Intl.DateTimeFormat(calendar.params.locale, {
        month: "long"
      });
      return formatter.format(date);
    };
    calendar.yearFormatter = (date) => {
      const formatter = new Intl.DateTimeFormat(calendar.params.locale, {
        year: "numeric"
      });
      return formatter.format(date);
    };
    calendar.timeSelectorFormatter = (date) => {
      const formatter = new Intl.DateTimeFormat(calendar.params.locale, calendar.params.timePickerFormat);
      return formatter.format(date);
    };
    const timeFormatCheckDate = calendar.timeSelectorFormatter(/* @__PURE__ */ new Date()).toLowerCase();
    calendar.is12HoursFormat = timeFormatCheckDate.indexOf("pm") >= 0 || timeFormatCheckDate.indexOf("am") >= 0;
    let {
      monthNames,
      monthNamesShort,
      dayNames,
      dayNamesShort
    } = calendar.params;
    const {
      monthNamesIntl,
      monthNamesShortIntl,
      dayNamesIntl,
      dayNamesShortIntl
    } = calendar.getIntlNames();
    if (monthNames === "auto") monthNames = monthNamesIntl;
    if (monthNamesShort === "auto") monthNamesShort = monthNamesShortIntl;
    if (dayNames === "auto") dayNames = dayNamesIntl;
    if (dayNamesShort === "auto") dayNamesShort = dayNamesShortIntl;
    extend$1(calendar, {
      monthNames,
      monthNamesShort,
      dayNames,
      dayNamesShort
    });
    function onInputClick() {
      calendar.open();
    }
    function onInputFocus(e) {
      e.preventDefault();
    }
    function onInputClear() {
      calendar.setValue([]);
      if (calendar.opened) {
        calendar.update();
      }
    }
    function onHtmlClick(e) {
      const $targetEl = $(e.target);
      if (calendar.destroyed || !calendar.params) return;
      if (calendar.isPopover()) return;
      if (!calendar.opened || calendar.closing) return;
      if ($targetEl.closest('[class*="backdrop"]').length) return;
      if (calendar.monthPickerPopover || calendar.yearPickerPopover || calendar.timePickerPopover) return;
      if ($inputEl && $inputEl.length > 0) {
        if ($targetEl[0] !== $inputEl[0] && $targetEl.closest(".sheet-modal, .calendar-modal").length === 0) {
          calendar.close();
        }
      } else if ($(e.target).closest(".sheet-modal, .calendar-modal").length === 0) {
        calendar.close();
      }
    }
    extend$1(calendar, {
      attachInputEvents() {
        calendar.$inputEl.on("click", onInputClick);
        calendar.$inputEl.on("input:clear", onInputClear);
        if (calendar.params.inputReadOnly) {
          calendar.$inputEl.on("focus mousedown", onInputFocus);
          if (calendar.$inputEl[0]) {
            calendar.$inputEl[0].f7ValidateReadonly = true;
          }
        }
      },
      detachInputEvents() {
        calendar.$inputEl.off("click", onInputClick);
        calendar.$inputEl.off("input:clear", onInputClear);
        if (calendar.params.inputReadOnly) {
          calendar.$inputEl.off("focus mousedown", onInputFocus);
          if (calendar.$inputEl[0]) {
            delete calendar.$inputEl[0].f7ValidateReadonly;
          }
        }
      },
      attachHtmlEvents() {
        app2.on("click", onHtmlClick);
      },
      detachHtmlEvents() {
        app2.off("click", onHtmlClick);
      }
    });
    calendar.attachCalendarEvents = function attachCalendarEvents() {
      let allowItemClick = true;
      let isTouched;
      let isMoved;
      let touchStartX;
      let touchStartY;
      let touchCurrentX;
      let touchCurrentY;
      let touchStartTime;
      let touchEndTime;
      let currentTranslate;
      let wrapperWidth;
      let wrapperHeight;
      let percentage;
      let touchesDiff;
      let isScrolling;
      const {
        $el,
        $wrapperEl
      } = calendar;
      function handleTouchStart(e) {
        if (isMoved || isTouched || !e.isTrusted) return;
        isTouched = true;
        touchStartX = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
        touchCurrentX = touchStartX;
        touchStartY = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
        touchCurrentY = touchStartY;
        touchStartTime = (/* @__PURE__ */ new Date()).getTime();
        percentage = 0;
        allowItemClick = true;
        isScrolling = void 0;
        currentTranslate = calendar.monthsTranslate;
      }
      function handleTouchMove(e) {
        if (!isTouched || !e.isTrusted) return;
        const {
          isHorizontal: isH
        } = calendar;
        touchCurrentX = e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
        touchCurrentY = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
        if (typeof isScrolling === "undefined") {
          isScrolling = !!(isScrolling || Math.abs(touchCurrentY - touchStartY) > Math.abs(touchCurrentX - touchStartX));
        }
        if (isH && isScrolling || !calendar.allowTouchMove) {
          isTouched = false;
          return;
        }
        e.preventDefault();
        if (calendar.animating) {
          isTouched = false;
          return;
        }
        allowItemClick = false;
        if (!isMoved) {
          isMoved = true;
          wrapperWidth = $wrapperEl[0].offsetWidth;
          wrapperHeight = $wrapperEl[0].offsetHeight;
          $wrapperEl.transition(0);
        }
        touchesDiff = isH ? touchCurrentX - touchStartX : touchCurrentY - touchStartY;
        percentage = touchesDiff / (isH ? wrapperWidth : wrapperHeight);
        currentTranslate = (calendar.monthsTranslate * calendar.inverter + percentage) * 100;
        $wrapperEl.transform(`translate3d(${isH ? currentTranslate : 0}%, ${isH ? 0 : currentTranslate}%, 0)`);
      }
      function handleTouchEnd(e) {
        if (!isTouched || !isMoved || !e.isTrusted) {
          isTouched = false;
          isMoved = false;
          return;
        }
        isTouched = false;
        isMoved = false;
        touchEndTime = (/* @__PURE__ */ new Date()).getTime();
        if (touchEndTime - touchStartTime < 300) {
          if (Math.abs(touchesDiff) < 10) {
            calendar.resetMonth();
          } else if (touchesDiff >= 10) {
            if (app2.rtl) calendar.nextMonth();
            else calendar.prevMonth();
          } else if (app2.rtl) calendar.prevMonth();
          else calendar.nextMonth();
        } else if (percentage <= -0.5) {
          if (app2.rtl) calendar.prevMonth();
          else calendar.nextMonth();
        } else if (percentage >= 0.5) {
          if (app2.rtl) calendar.nextMonth();
          else calendar.prevMonth();
        } else {
          calendar.resetMonth();
        }
        setTimeout(() => {
          allowItemClick = true;
        }, 100);
      }
      function handleDayClick(e) {
        if (!allowItemClick) return;
        let $dayEl = $(e.target).parents(".calendar-day");
        if ($dayEl.length === 0 && $(e.target).hasClass("calendar-day")) {
          $dayEl = $(e.target);
        }
        if ($dayEl.length === 0) return;
        if ($dayEl.hasClass("calendar-day-disabled")) return;
        if (!calendar.params.rangePicker) {
          if ($dayEl.hasClass("calendar-day-next")) calendar.nextMonth();
          if ($dayEl.hasClass("calendar-day-prev")) calendar.prevMonth();
        }
        const dateYear = parseInt($dayEl.attr("data-year"), 10);
        const dateMonth = parseInt($dayEl.attr("data-month"), 10);
        const dateDay = parseInt($dayEl.attr("data-day"), 10);
        calendar.emit("local::dayClick calendarDayClick", calendar, $dayEl[0], dateYear, dateMonth, dateDay);
        if (!$dayEl.hasClass("calendar-day-selected") || calendar.params.multiple || calendar.params.rangePicker) {
          const valueToAdd = new Date(dateYear, dateMonth, dateDay, 0, 0, 0);
          if (calendar.hasTimePicker) {
            if (calendar.value && calendar.value[0]) {
              valueToAdd.setHours(calendar.value[0].getHours(), calendar.value[0].getMinutes());
            } else {
              valueToAdd.setHours((/* @__PURE__ */ new Date()).getHours(), (/* @__PURE__ */ new Date()).getMinutes());
            }
          }
          calendar.addValue(valueToAdd);
        }
        if (calendar.params.closeOnSelect) {
          if (calendar.params.rangePicker && calendar.value.length === 2 || !calendar.params.rangePicker) {
            calendar.close();
          }
        }
      }
      function onNextMonthClick() {
        calendar.nextMonth();
      }
      function onPrevMonthClick() {
        calendar.prevMonth();
      }
      function onNextYearClick() {
        calendar.nextYear();
      }
      function onPrevYearClick() {
        calendar.prevYear();
      }
      function onMonthSelectorClick() {
        calendar.openMonthPicker();
      }
      function onYearSelectorClick() {
        calendar.openYearPicker();
      }
      function onTimeSelectorClick() {
        calendar.openTimePicker();
      }
      const passiveListener = app2.touchEvents.start === "touchstart" && getSupport().passiveListener ? {
        passive: true,
        capture: false
      } : false;
      $el.find(".calendar-prev-month-button").on("click", onPrevMonthClick);
      $el.find(".calendar-next-month-button").on("click", onNextMonthClick);
      $el.find(".calendar-prev-year-button").on("click", onPrevYearClick);
      $el.find(".calendar-next-year-button").on("click", onNextYearClick);
      if (calendar.params.monthPicker) {
        $el.find(".current-month-value").on("click", onMonthSelectorClick);
      }
      if (calendar.params.yearPicker) {
        $el.find(".current-year-value").on("click", onYearSelectorClick);
      }
      if (calendar.hasTimePicker) {
        $el.find(".calendar-time-selector a").on("click", onTimeSelectorClick);
      }
      $wrapperEl.on("click", handleDayClick);
      if (calendar.params.touchMove) {
        $wrapperEl.on(app2.touchEvents.start, handleTouchStart, passiveListener);
        app2.on("touchmove:active", handleTouchMove);
        app2.on("touchend:passive", handleTouchEnd);
      }
      calendar.detachCalendarEvents = function detachCalendarEvents() {
        $el.find(".calendar-prev-month-button").off("click", onPrevMonthClick);
        $el.find(".calendar-next-month-button").off("click", onNextMonthClick);
        $el.find(".calendar-prev-year-button").off("click", onPrevYearClick);
        $el.find(".calendar-next-year-button").off("click", onNextYearClick);
        if (calendar.params.monthPicker) {
          $el.find(".current-month-value").off("click", onMonthSelectorClick);
        }
        if (calendar.params.yearPicker) {
          $el.find(".current-year-value").off("click", onYearSelectorClick);
        }
        if (calendar.hasTimePicker) {
          $el.find(".calendar-time-selector a").off("click", onTimeSelectorClick);
        }
        $wrapperEl.off("click", handleDayClick);
        if (calendar.params.touchMove) {
          $wrapperEl.off(app2.touchEvents.start, handleTouchStart, passiveListener);
          app2.off("touchmove:active", handleTouchMove);
          app2.off("touchend:passive", handleTouchEnd);
        }
      };
    };
    calendar.init();
    return calendar;
  }
  get view() {
    const {
      $inputEl,
      app: app2,
      params
    } = this;
    let view;
    if (params.view) {
      view = params.view;
    } else if ($inputEl) {
      view = $inputEl.parents(".view").length && $inputEl.parents(".view")[0].f7View;
    }
    if (!view) view = app2.views.main;
    return view;
  }
  getIntlNames() {
    const calendar = this;
    const locale = calendar.params.locale;
    const monthNamesIntl = [];
    const monthNamesShortIntl = [];
    const dayNamesIntl = [];
    const dayNamesShortIntl = [];
    const formatterMonthNames = new Intl.DateTimeFormat(locale, {
      month: "long"
    });
    const formatterMonthNamesShort = new Intl.DateTimeFormat(locale, {
      month: "short"
    });
    const formatterDayNames = new Intl.DateTimeFormat(locale, {
      weekday: "long"
    });
    const formatterDayNamesShort = new Intl.DateTimeFormat(locale, {
      weekday: "short"
    });
    let year;
    let yearStarted;
    let yearEnded;
    for (let i = 0; i < 24; i += 1) {
      const date = (/* @__PURE__ */ new Date()).setMonth(i, 1);
      const currentYear = calendar.yearFormatter(date);
      if (year && currentYear !== year) {
        if (yearStarted) yearEnded = true;
        yearStarted = true;
        year = currentYear;
      }
      if (!year) {
        year = currentYear;
      }
      if (yearStarted && year === currentYear && !yearEnded) {
        monthNamesIntl.push(formatterMonthNames.format(date));
        monthNamesShortIntl.push(formatterMonthNamesShort.format(date));
      }
    }
    const weekDay = (/* @__PURE__ */ new Date()).getDay();
    for (let i = 0; i < 7; i += 1) {
      const date = (/* @__PURE__ */ new Date()).getTime() + (i - weekDay) * 24 * 60 * 60 * 1e3;
      dayNamesIntl.push(formatterDayNames.format(date));
      dayNamesShortIntl.push(formatterDayNamesShort.format(date));
    }
    return {
      monthNamesIntl,
      monthNamesShortIntl,
      dayNamesIntl,
      dayNamesShortIntl
    };
  }
  normalizeDate(date) {
    const calendar = this;
    const d = new Date(date);
    if (calendar.hasTimePicker) {
      return new Date(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes());
    }
    return new Date(d.getFullYear(), d.getMonth(), d.getDate());
  }
  normalizeValues(values) {
    const calendar = this;
    let newValues = [];
    if (values && Array.isArray(values)) {
      newValues = values.map((val2) => calendar.normalizeDate(val2));
    }
    return newValues;
  }
  initInput() {
    const calendar = this;
    if (!calendar.$inputEl) return;
    if (calendar.params.inputReadOnly) calendar.$inputEl.prop("readOnly", true);
  }
  isPopover() {
    const calendar = this;
    const {
      app: app2,
      modal,
      params
    } = calendar;
    const device = getDevice();
    if (params.openIn === "sheet") return false;
    if (modal && modal.type !== "popover") return false;
    if (!calendar.inline && calendar.inputEl) {
      if (params.openIn === "popover") return true;
      if (device.ios) {
        return !!device.ipad;
      }
      if (app2.width >= 768) {
        return true;
      }
    }
    return false;
  }
  formatDate(d) {
    const calendar = this;
    const date = new Date(d);
    const year = date.getFullYear();
    const month = date.getMonth();
    const month1 = month + 1;
    const day = date.getDate();
    const weekDay = date.getDay();
    const {
      monthNames,
      monthNamesShort,
      dayNames,
      dayNamesShort
    } = calendar;
    const {
      dateFormat,
      locale
    } = calendar.params;
    function twoDigits(number) {
      return number < 10 ? `0${number}` : number;
    }
    if (typeof dateFormat === "string") {
      const tokens = {
        yyyy: year,
        yy: String(year).substring(2),
        mm: twoDigits(month1),
        m: month1,
        MM: monthNames[month],
        M: monthNamesShort[month],
        dd: twoDigits(day),
        d: day,
        DD: dayNames[weekDay],
        D: dayNamesShort[weekDay]
      };
      if (calendar.params.timePicker) {
        const hours = date.getHours();
        const minutes = date.getMinutes();
        const seconds = date.getSeconds();
        let hours12 = hours;
        if (hours > 12) hours12 = hours - 12;
        if (hours === 0) hours12 = 12;
        const a = hours >= 12 && hours !== 0 ? "pm" : "am";
        Object.assign(tokens, {
          HH: twoDigits(hours),
          H: hours,
          hh: twoDigits(hours12),
          h: hours12,
          ss: twoDigits(seconds),
          s: seconds,
          ":mm": twoDigits(minutes),
          ":m": minutes,
          a,
          A: a.toUpperCase()
        });
      }
      const regexp = new RegExp(Object.keys(tokens).map((t2) => `(${t2})`).join("|"), "g");
      return dateFormat.replace(regexp, (token) => {
        if (token in tokens) return tokens[token];
        return token;
      });
    }
    if (typeof dateFormat === "function") {
      return dateFormat(date);
    }
    const formatter = new Intl.DateTimeFormat(locale, dateFormat);
    return formatter.format(date);
  }
  formatValue() {
    const calendar = this;
    const {
      value: value2
    } = calendar;
    if (calendar.params.formatValue) {
      return calendar.params.formatValue.call(calendar, value2);
    }
    return value2.map((v) => calendar.formatDate(v)).join(calendar.params.rangePicker ? " - " : ", ");
  }
  addValue(newValue) {
    const calendar = this;
    const {
      multiple,
      rangePicker,
      rangePickerMinDays,
      rangePickerMaxDays
    } = calendar.params;
    if (multiple) {
      if (!calendar.value) calendar.value = [];
      let inValuesIndex;
      for (let i = 0; i < calendar.value.length; i += 1) {
        if (new Date(newValue).getTime() === new Date(calendar.value[i]).getTime()) {
          inValuesIndex = i;
        }
      }
      if (typeof inValuesIndex === "undefined") {
        calendar.value.push(newValue);
      } else {
        calendar.value.splice(inValuesIndex, 1);
      }
      calendar.updateValue();
    } else if (rangePicker) {
      if (!calendar.value) calendar.value = [];
      if (calendar.value.length === 2 || calendar.value.length === 0) {
        calendar.value = [];
      }
      if (calendar.value.length === 0 || Math.abs(calendar.value[0].getTime() - newValue.getTime()) >= (rangePickerMinDays - 1) * 60 * 60 * 24 * 1e3 && (rangePickerMaxDays === 0 || Math.abs(calendar.value[0].getTime() - newValue.getTime()) <= (rangePickerMaxDays - 1) * 60 * 60 * 24 * 1e3)) calendar.value.push(newValue);
      else calendar.value = [];
      calendar.value.sort((a, b) => a - b);
      calendar.updateValue();
    } else {
      calendar.value = [newValue];
      calendar.updateValue();
    }
  }
  setValue(values) {
    const calendar = this;
    const currentValue = calendar.value;
    if (Array.isArray(currentValue) && Array.isArray(values) && currentValue.length === values.length) {
      let equal = true;
      currentValue.forEach((v, index2) => {
        if (v !== values[index2]) equal = false;
      });
      if (equal) return;
    }
    calendar.value = values;
    calendar.updateValue();
  }
  getValue() {
    const calendar = this;
    return calendar.value;
  }
  updateValue(onlyHeader) {
    const calendar = this;
    const {
      $el,
      $wrapperEl,
      $inputEl,
      value: value2,
      params
    } = calendar;
    let i;
    if ($el && $el.length > 0) {
      $wrapperEl.find(".calendar-day-selected").removeClass("calendar-day-selected calendar-day-selected-range calendar-day-selected-left calendar-day-selected-right");
      let valueDate;
      if (params.rangePicker && value2.length === 2) {
        const leftDate = new Date(value2[0]).getTime();
        const rightDate = new Date(value2[1]).getTime();
        for (i = leftDate; i <= rightDate; i += 24 * 60 * 60 * 1e3) {
          valueDate = new Date(i);
          let addClass2 = "calendar-day-selected";
          if (leftDate !== rightDate) {
            if (i !== leftDate && i !== rightDate) {
              addClass2 += " calendar-day-selected-range";
            }
            if (i === leftDate) {
              addClass2 += " calendar-day-selected-left";
            }
            if (i === rightDate) {
              addClass2 += " calendar-day-selected-right";
            }
          }
          $wrapperEl.find(`.calendar-day[data-date="${valueDate.getFullYear()}-${valueDate.getMonth()}-${valueDate.getDate()}"]`).addClass(addClass2);
        }
        valueDate = new Date(leftDate);
        $wrapperEl.find(`.calendar-day[data-date="${valueDate.getFullYear()}-${valueDate.getMonth()}-${valueDate.getDate()}"]`).removeClass("calendar-day-selected-range").addClass("calendar-day-selected calendar-day-selected-left");
        valueDate = new Date(rightDate);
        $wrapperEl.find(`.calendar-day[data-date="${valueDate.getFullYear()}-${valueDate.getMonth()}-${valueDate.getDate()}"]`).removeClass("calendar-day-selected-range").addClass("calendar-day-selected calendar-day-selected-right");
      } else {
        for (i = 0; i < calendar.value.length; i += 1) {
          valueDate = new Date(value2[i]);
          $wrapperEl.find(`.calendar-day[data-date="${valueDate.getFullYear()}-${valueDate.getMonth()}-${valueDate.getDate()}"]`).addClass("calendar-day-selected");
        }
      }
    }
    if (!onlyHeader) {
      calendar.emit("local::change calendarChange", calendar, value2);
    }
    if ($el && $el.length > 0 && calendar.hasTimePicker) {
      $el.find(".calendar-time-selector a").text(value2 && value2.length ? calendar.timeSelectorFormatter(value2[0]) : calendar.params.timePickerPlaceholder);
    }
    if ($inputEl && $inputEl.length || params.header) {
      const inputValue = calendar.formatValue(value2);
      if (params.header && $el && $el.length) {
        $el.find(".calendar-selected-date").text(inputValue);
      }
      if ($inputEl && $inputEl.length && !onlyHeader) {
        $inputEl.val(inputValue);
        $inputEl.trigger("change");
      }
    }
  }
  updateCurrentMonthYear(dir) {
    const calendar = this;
    const {
      $months,
      $el,
      monthNames
    } = calendar;
    let currentLocaleMonth;
    let currentLocaleYear;
    if (typeof dir === "undefined") {
      calendar.currentMonth = parseInt($months.eq(1).attr("data-month"), 10);
      calendar.currentYear = parseInt($months.eq(1).attr("data-year"), 10);
      currentLocaleMonth = $months.eq(1).attr("data-locale-month");
      currentLocaleYear = $months.eq(1).attr("data-locale-year");
    } else {
      calendar.currentMonth = parseInt($months.eq(dir === "next" ? $months.length - 1 : 0).attr("data-month"), 10);
      calendar.currentYear = parseInt($months.eq(dir === "next" ? $months.length - 1 : 0).attr("data-year"), 10);
      currentLocaleMonth = $months.eq(dir === "next" ? $months.length - 1 : 0).attr("data-locale-month");
      currentLocaleYear = $months.eq(dir === "next" ? $months.length - 1 : 0).attr("data-locale-year");
    }
    $el.find(".current-month-value").text(monthNames[currentLocaleMonth]);
    $el.find(".current-year-value").text(currentLocaleYear);
  }
  update() {
    const calendar = this;
    const {
      currentYear,
      currentMonth,
      $wrapperEl
    } = calendar;
    const currentDate = new Date(currentYear, currentMonth);
    const prevMonthHtml = calendar.renderMonth(currentDate, "prev");
    const currentMonthHtml = calendar.renderMonth(currentDate);
    const nextMonthHtml = calendar.renderMonth(currentDate, "next");
    $wrapperEl.transition(0).html(`${prevMonthHtml}${currentMonthHtml}${nextMonthHtml}`).transform("translate3d(0,0,0)");
    calendar.$months = $wrapperEl.find(".calendar-month");
    calendar.monthsTranslate = 0;
    calendar.setMonthsTranslate();
    calendar.$months.each((monthEl) => {
      calendar.emit("local::monthAdd calendarMonthAdd", monthEl);
    });
  }
  onMonthChangeStart(dir) {
    const calendar = this;
    const {
      $months,
      currentYear,
      currentMonth
    } = calendar;
    calendar.updateCurrentMonthYear(dir);
    $months.removeClass("calendar-month-current calendar-month-prev calendar-month-next");
    const currentIndex = dir === "next" ? $months.length - 1 : 0;
    $months.eq(currentIndex).addClass("calendar-month-current");
    $months.eq(dir === "next" ? currentIndex - 1 : currentIndex + 1).addClass(dir === "next" ? "calendar-month-prev" : "calendar-month-next");
    calendar.emit("local::monthYearChangeStart calendarMonthYearChangeStart", calendar, currentYear, currentMonth);
  }
  onMonthChangeEnd(dir, rebuildBoth) {
    const calendar = this;
    const {
      currentYear,
      currentMonth,
      $wrapperEl,
      monthsTranslate
    } = calendar;
    calendar.animating = false;
    let nextMonthHtml;
    let prevMonthHtml;
    let currentMonthHtml;
    $wrapperEl.find(".calendar-month:not(.calendar-month-prev):not(.calendar-month-current):not(.calendar-month-next)").remove();
    if (typeof dir === "undefined") {
      dir = "next";
      rebuildBoth = true;
    }
    if (!rebuildBoth) {
      currentMonthHtml = calendar.renderMonth(new Date(currentYear, currentMonth), dir);
    } else {
      $wrapperEl.find(".calendar-month-next, .calendar-month-prev").remove();
      prevMonthHtml = calendar.renderMonth(new Date(currentYear, currentMonth), "prev");
      nextMonthHtml = calendar.renderMonth(new Date(currentYear, currentMonth), "next");
    }
    if (dir === "next" || rebuildBoth) {
      $wrapperEl.append(currentMonthHtml || nextMonthHtml);
    }
    if (dir === "prev" || rebuildBoth) {
      $wrapperEl.prepend(currentMonthHtml || prevMonthHtml);
    }
    const $months = $wrapperEl.find(".calendar-month");
    calendar.$months = $months;
    calendar.setMonthsTranslate(monthsTranslate);
    calendar.emit("local::monthAdd calendarMonthAdd", calendar, dir === "next" ? $months.eq($months.length - 1)[0] : $months.eq(0)[0]);
    calendar.emit("local::monthYearChangeEnd calendarMonthYearChangeEnd", calendar, currentYear, currentMonth);
  }
  setMonthsTranslate(translate) {
    const calendar = this;
    const {
      $months,
      isHorizontal: isH,
      inverter
    } = calendar;
    translate = translate || calendar.monthsTranslate || 0;
    if (typeof calendar.monthsTranslate === "undefined") {
      calendar.monthsTranslate = translate;
    }
    $months.removeClass("calendar-month-current calendar-month-prev calendar-month-next");
    const prevMonthTranslate = -(translate + 1) * 100 * inverter;
    const currentMonthTranslate = -translate * 100 * inverter;
    const nextMonthTranslate = -(translate - 1) * 100 * inverter;
    $months.eq(0).transform(`translate3d(${isH ? prevMonthTranslate : 0}%, ${isH ? 0 : prevMonthTranslate}%, 0)`).addClass("calendar-month-prev");
    $months.eq(1).transform(`translate3d(${isH ? currentMonthTranslate : 0}%, ${isH ? 0 : currentMonthTranslate}%, 0)`).addClass("calendar-month-current");
    $months.eq(2).transform(`translate3d(${isH ? nextMonthTranslate : 0}%, ${isH ? 0 : nextMonthTranslate}%, 0)`).addClass("calendar-month-next");
  }
  nextMonth(transition2) {
    const calendar = this;
    const {
      params,
      $wrapperEl,
      inverter,
      isHorizontal: isH
    } = calendar;
    if (typeof transition2 === "undefined" || typeof transition2 === "object") {
      transition2 = "";
      if (!params.animate) transition2 = 0;
    }
    const nextMonth = parseInt(calendar.$months.eq(calendar.$months.length - 1).attr("data-month"), 10);
    const nextYear = parseInt(calendar.$months.eq(calendar.$months.length - 1).attr("data-year"), 10);
    const nextDate = new Date(nextYear, nextMonth);
    const nextDateTime = nextDate.getTime();
    const transitionEndCallback = !calendar.animating;
    if (params.maxDate) {
      if (nextDateTime > new Date(params.maxDate).getTime()) {
        calendar.resetMonth();
        return;
      }
    }
    calendar.monthsTranslate -= 1;
    if (nextMonth === calendar.currentMonth) {
      const nextMonthTranslate = -calendar.monthsTranslate * 100 * inverter;
      const nextMonthHtml = $(calendar.renderMonth(nextDateTime, "next")).transform(`translate3d(${isH ? nextMonthTranslate : 0}%, ${isH ? 0 : nextMonthTranslate}%, 0)`).addClass("calendar-month-next");
      $wrapperEl.append(nextMonthHtml[0]);
      calendar.$months = $wrapperEl.find(".calendar-month");
      calendar.emit("local::monthAdd calendarMonthAdd", calendar.$months.eq(calendar.$months.length - 1)[0]);
    }
    calendar.animating = true;
    calendar.onMonthChangeStart("next");
    const translate = calendar.monthsTranslate * 100 * inverter;
    $wrapperEl.transition(transition2).transform(`translate3d(${isH ? translate : 0}%, ${isH ? 0 : translate}%, 0)`);
    if (transitionEndCallback) {
      $wrapperEl.transitionEnd(() => {
        calendar.onMonthChangeEnd("next");
      });
    }
    if (!params.animate) {
      calendar.onMonthChangeEnd("next");
    }
  }
  prevMonth(transition2) {
    const calendar = this;
    const {
      params,
      $wrapperEl,
      inverter,
      isHorizontal: isH
    } = calendar;
    if (typeof transition2 === "undefined" || typeof transition2 === "object") {
      transition2 = "";
      if (!params.animate) transition2 = 0;
    }
    const prevMonth = parseInt(calendar.$months.eq(0).attr("data-month"), 10);
    const prevYear = parseInt(calendar.$months.eq(0).attr("data-year"), 10);
    const prevDate = new Date(prevYear, prevMonth + 1, -1);
    const prevDateTime = prevDate.getTime();
    const transitionEndCallback = !calendar.animating;
    if (params.minDate) {
      let minDate = new Date(params.minDate);
      minDate = new Date(minDate.getFullYear(), minDate.getMonth(), 1);
      if (prevDateTime < minDate.getTime()) {
        calendar.resetMonth();
        return;
      }
    }
    calendar.monthsTranslate += 1;
    if (prevMonth === calendar.currentMonth) {
      const prevMonthTranslate = -calendar.monthsTranslate * 100 * inverter;
      const prevMonthHtml = $(calendar.renderMonth(prevDateTime, "prev")).transform(`translate3d(${isH ? prevMonthTranslate : 0}%, ${isH ? 0 : prevMonthTranslate}%, 0)`).addClass("calendar-month-prev");
      $wrapperEl.prepend(prevMonthHtml[0]);
      calendar.$months = $wrapperEl.find(".calendar-month");
      calendar.emit("local::monthAdd calendarMonthAdd", calendar.$months.eq(0)[0]);
    }
    calendar.animating = true;
    calendar.onMonthChangeStart("prev");
    const translate = calendar.monthsTranslate * 100 * inverter;
    $wrapperEl.transition(transition2).transform(`translate3d(${isH ? translate : 0}%, ${isH ? 0 : translate}%, 0)`);
    if (transitionEndCallback) {
      $wrapperEl.transitionEnd(() => {
        calendar.onMonthChangeEnd("prev");
      });
    }
    if (!params.animate) {
      calendar.onMonthChangeEnd("prev");
    }
  }
  resetMonth(transition2) {
    if (transition2 === void 0) {
      transition2 = "";
    }
    const calendar = this;
    const {
      $wrapperEl,
      inverter,
      isHorizontal: isH,
      monthsTranslate
    } = calendar;
    const translate = monthsTranslate * 100 * inverter;
    $wrapperEl.transition(transition2).transform(`translate3d(${isH ? translate : 0}%, ${isH ? 0 : translate}%, 0)`);
  }
  // eslint-disable-next-line
  setYearMonth(year, month, transition2) {
    const calendar = this;
    const {
      params,
      isHorizontal: isH,
      $wrapperEl,
      inverter
    } = calendar;
    if (typeof year === "undefined") year = calendar.currentYear;
    if (typeof month === "undefined") month = calendar.currentMonth;
    if (typeof transition2 === "undefined" || typeof transition2 === "object") {
      transition2 = "";
      if (!params.animate) transition2 = 0;
    }
    let targetDate;
    if (year < calendar.currentYear) {
      targetDate = new Date(year, month + 1, -1).getTime();
    } else {
      targetDate = new Date(year, month).getTime();
    }
    if (params.maxDate && targetDate > new Date(params.maxDate).getTime()) {
      return false;
    }
    if (params.minDate) {
      let minDate = new Date(params.minDate);
      minDate = new Date(minDate.getFullYear(), minDate.getMonth(), 1);
      if (targetDate < minDate.getTime()) {
        return false;
      }
    }
    const currentDate = new Date(calendar.currentYear, calendar.currentMonth).getTime();
    const dir = targetDate > currentDate ? "next" : "prev";
    const newMonthHTML = calendar.renderMonth(new Date(year, month));
    calendar.monthsTranslate = calendar.monthsTranslate || 0;
    const prevTranslate = calendar.monthsTranslate;
    let monthTranslate;
    const transitionEndCallback = !calendar.animating && transition2 !== 0;
    if (targetDate > currentDate) {
      calendar.monthsTranslate -= 1;
      if (!calendar.animating) calendar.$months.eq(calendar.$months.length - 1).remove();
      $wrapperEl.append(newMonthHTML);
      calendar.$months = $wrapperEl.find(".calendar-month");
      monthTranslate = -(prevTranslate - 1) * 100 * inverter;
      calendar.$months.eq(calendar.$months.length - 1).transform(`translate3d(${isH ? monthTranslate : 0}%, ${isH ? 0 : monthTranslate}%, 0)`).addClass("calendar-month-next");
    } else {
      calendar.monthsTranslate += 1;
      if (!calendar.animating) calendar.$months.eq(0).remove();
      $wrapperEl.prepend(newMonthHTML);
      calendar.$months = $wrapperEl.find(".calendar-month");
      monthTranslate = -(prevTranslate + 1) * 100 * inverter;
      calendar.$months.eq(0).transform(`translate3d(${isH ? monthTranslate : 0}%, ${isH ? 0 : monthTranslate}%, 0)`).addClass("calendar-month-prev");
    }
    calendar.emit("local::monthAdd calendarMonthAdd", dir === "next" ? calendar.$months.eq(calendar.$months.length - 1)[0] : calendar.$months.eq(0)[0]);
    calendar.animating = true;
    calendar.onMonthChangeStart(dir);
    const wrapperTranslate = calendar.monthsTranslate * 100 * inverter;
    $wrapperEl.transition(transition2).transform(`translate3d(${isH ? wrapperTranslate : 0}%, ${isH ? 0 : wrapperTranslate}%, 0)`);
    if (transitionEndCallback) {
      $wrapperEl.transitionEnd(() => {
        calendar.onMonthChangeEnd(dir, true);
      });
    }
    if (!params.animate || transition2 === 0) {
      calendar.onMonthChangeEnd(dir, true);
    }
  }
  nextYear() {
    const calendar = this;
    calendar.setYearMonth(calendar.currentYear + 1);
  }
  prevYear() {
    const calendar = this;
    calendar.setYearMonth(calendar.currentYear - 1);
  }
  // eslint-disable-next-line
  dateInRange(dayDate, range) {
    let match = false;
    let i;
    if (!range) return false;
    if (Array.isArray(range)) {
      for (i = 0; i < range.length; i += 1) {
        if (range[i].from || range[i].to) {
          if (range[i].from && range[i].to) {
            if (dayDate <= new Date(range[i].to).getTime() && dayDate >= new Date(range[i].from).getTime()) {
              match = true;
            }
          } else if (range[i].from) {
            if (dayDate >= new Date(range[i].from).getTime()) {
              match = true;
            }
          } else if (range[i].to) {
            if (dayDate <= new Date(range[i].to).getTime()) {
              match = true;
            }
          }
        } else if (range[i].date) {
          if (dayDate === new Date(range[i].date).getTime()) {
            match = true;
          }
        } else if (dayDate === new Date(range[i]).getTime()) {
          match = true;
        }
      }
    } else if (range.from || range.to) {
      if (range.from && range.to) {
        if (dayDate <= new Date(range.to).getTime() && dayDate >= new Date(range.from).getTime()) {
          match = true;
        }
      } else if (range.from) {
        if (dayDate >= new Date(range.from).getTime()) {
          match = true;
        }
      } else if (range.to) {
        if (dayDate <= new Date(range.to).getTime()) {
          match = true;
        }
      }
    } else if (range.date) {
      match = dayDate === new Date(range.date).getTime();
    } else if (typeof range === "function") {
      match = range(new Date(dayDate));
    }
    return match;
  }
  // eslint-disable-next-line
  daysInMonth(date) {
    const d = new Date(date);
    return new Date(d.getFullYear(), d.getMonth() + 1, 0).getDate();
  }
  renderMonths(date) {
    const calendar = this;
    if (calendar.params.renderMonths) {
      return calendar.params.renderMonths.call(calendar, date);
    }
    return $jsx$1("div", {
      class: "calendar-months-wrapper"
    }, calendar.renderMonth(date, "prev"), calendar.renderMonth(date), calendar.renderMonth(date, "next"));
  }
  renderMonth(d, offset2) {
    const calendar = this;
    const {
      params,
      value: value2
    } = calendar;
    if (params.renderMonth) {
      return params.renderMonth.call(calendar, d, offset2);
    }
    let date = new Date(d);
    let year = date.getFullYear();
    let month = date.getMonth();
    let localeMonth = calendar.monthNames.indexOf(calendar.monthFormatter(date));
    if (localeMonth < 0) localeMonth = month;
    let localeYear = calendar.yearFormatter(date);
    if (offset2 === "next") {
      if (month === 11) date = new Date(year + 1, 0);
      else date = new Date(year, month + 1, 1);
    }
    if (offset2 === "prev") {
      if (month === 0) date = new Date(year - 1, 11);
      else date = new Date(year, month - 1, 1);
    }
    if (offset2 === "next" || offset2 === "prev") {
      month = date.getMonth();
      year = date.getFullYear();
      localeMonth = calendar.monthNames.indexOf(calendar.monthFormatter(date));
      if (localeMonth < 0) localeMonth = month;
      localeYear = calendar.yearFormatter(date);
    }
    const currentValues = [];
    const today = (/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0);
    const minDate = params.minDate ? new Date(params.minDate).getTime() : null;
    const maxDate = params.maxDate ? new Date(params.maxDate).getTime() : null;
    const rows = 6;
    const cols = 7;
    const daysInPrevMonth = calendar.daysInMonth(new Date(date.getFullYear(), date.getMonth()).getTime() - 10 * 24 * 60 * 60 * 1e3);
    const daysInMonth = calendar.daysInMonth(date);
    const minDayNumber = params.firstDay === 6 ? 0 : 1;
    let monthHtml = "";
    let dayIndex = 0 + (params.firstDay - 1);
    let disabled;
    let hasEvents;
    let firstDayOfMonthIndex = new Date(date.getFullYear(), date.getMonth()).getDay();
    if (firstDayOfMonthIndex === 0) firstDayOfMonthIndex = 7;
    if (value2 && value2.length) {
      for (let i = 0; i < value2.length; i += 1) {
        currentValues.push(new Date(value2[i]).setHours(0, 0, 0, 0));
      }
    }
    for (let row = 1; row <= rows; row += 1) {
      let rowHtml = "";
      for (let col = 1; col <= cols; col += 1) {
        dayIndex += 1;
        let dayDate;
        let dayNumber = dayIndex - firstDayOfMonthIndex;
        let addClass2 = "";
        if (row === 1 && col === 1 && dayNumber > minDayNumber && params.firstDay !== 1) {
          dayIndex -= 7;
          dayNumber = dayIndex - firstDayOfMonthIndex;
        }
        const weekDayIndex = col - 1 + params.firstDay > 6 ? col - 1 - 7 + params.firstDay : col - 1 + params.firstDay;
        if (dayNumber < 0) {
          dayNumber = daysInPrevMonth + dayNumber + 1;
          addClass2 += " calendar-day-prev";
          dayDate = new Date(month - 1 < 0 ? year - 1 : year, month - 1 < 0 ? 11 : month - 1, dayNumber).getTime();
        } else {
          dayNumber += 1;
          if (dayNumber > daysInMonth) {
            dayNumber -= daysInMonth;
            addClass2 += " calendar-day-next";
            dayDate = new Date(month + 1 > 11 ? year + 1 : year, month + 1 > 11 ? 0 : month + 1, dayNumber).getTime();
          } else {
            dayDate = new Date(year, month, dayNumber).getTime();
          }
        }
        if (dayDate === today) addClass2 += " calendar-day-today";
        if (params.rangePicker && currentValues.length === 2) {
          if (dayDate >= currentValues[0] && dayDate <= currentValues[1]) {
            addClass2 += " calendar-day-selected";
          }
          if (currentValues[0] !== currentValues[1]) {
            if (dayDate > currentValues[0] && dayDate < currentValues[1]) {
              addClass2 += " calendar-day-selected-range";
            }
            if (dayDate === currentValues[0]) {
              addClass2 += " calendar-day-selected-left";
            }
            if (dayDate === currentValues[1]) {
              addClass2 += " calendar-day-selected-right";
            }
          }
        } else if (currentValues.indexOf(dayDate) >= 0) addClass2 += " calendar-day-selected";
        if (params.weekendDays.indexOf(weekDayIndex) >= 0) {
          addClass2 += " calendar-day-weekend";
        }
        let eventsHtml = "";
        hasEvents = false;
        if (params.events) {
          if (calendar.dateInRange(dayDate, params.events)) {
            hasEvents = true;
          }
        }
        if (hasEvents) {
          addClass2 += " calendar-day-has-events";
          eventsHtml = `
            <span class="calendar-day-events">
              <span class="calendar-day-event"></span>
            </span>
          `;
          if (Array.isArray(params.events)) {
            const eventDots = [];
            params.events.forEach((ev) => {
              const color = ev.color || "";
              if (eventDots.indexOf(color) < 0 && calendar.dateInRange(dayDate, ev)) {
                eventDots.push(color);
              }
            });
            eventsHtml = `
              <span class="calendar-day-events">
                ${eventDots.map((color) => `
                  <span class="calendar-day-event" style="${color ? `background-color: ${color}` : ""}"></span>
                `.trim()).join("")}
              </span>
            `;
          }
        }
        if (params.rangesClasses) {
          for (let k = 0; k < params.rangesClasses.length; k += 1) {
            if (calendar.dateInRange(dayDate, params.rangesClasses[k].range)) {
              addClass2 += ` ${params.rangesClasses[k].cssClass}`;
            }
          }
        }
        disabled = false;
        if (minDate && dayDate < minDate || maxDate && dayDate > maxDate) {
          disabled = true;
        }
        if (params.disabled) {
          if (calendar.dateInRange(dayDate, params.disabled)) {
            disabled = true;
          }
        }
        if (disabled) {
          addClass2 += " calendar-day-disabled";
        }
        dayDate = new Date(dayDate);
        const dayYear = dayDate.getFullYear();
        const dayMonth = dayDate.getMonth();
        const dayNumberDisplay = calendar.dayFormatter(dayDate);
        rowHtml += `
          <div data-year="${dayYear}" data-month="${dayMonth}" data-day="${dayNumber}" class="calendar-day${addClass2}" data-date="${dayYear}-${dayMonth}-${dayNumber}">
            <span class="calendar-day-number">${dayNumberDisplay}${eventsHtml}</span>
          </div>`.trim();
      }
      monthHtml += `<div class="calendar-row">${rowHtml}</div>`;
    }
    monthHtml = `<div class="calendar-month" data-year="${year}" data-month="${month}" data-locale-year="${localeYear}" data-locale-month="${localeMonth}">${monthHtml}</div>`;
    return monthHtml;
  }
  renderWeekHeader() {
    const calendar = this;
    if (calendar.params.renderWeekHeader) {
      return calendar.params.renderWeekHeader.call(calendar);
    }
    const {
      params
    } = calendar;
    let weekDaysHtml = "";
    for (let i = 0; i < 7; i += 1) {
      const dayIndex = i + params.firstDay > 6 ? i - 7 + params.firstDay : i + params.firstDay;
      const dayName = calendar.dayNamesShort[dayIndex];
      weekDaysHtml += `<div class="calendar-week-day">${dayName}</div>`;
    }
    return $jsx$1("div", {
      class: "calendar-week-header"
    }, weekDaysHtml);
  }
  renderMonthSelector() {
    const calendar = this;
    if (calendar.params.renderMonthSelector) {
      return calendar.params.renderMonthSelector.call(calendar);
    }
    return $jsx$1("div", {
      class: "calendar-month-selector"
    }, $jsx$1("a", {
      class: "link icon-only calendar-prev-month-button"
    }, $jsx$1("i", {
      class: "icon icon-prev"
    })), calendar.params.monthPicker ? $jsx$1("a", {
      class: "current-month-value link"
    }) : $jsx$1("span", {
      class: "current-month-value"
    }), $jsx$1("a", {
      class: "link icon-only calendar-next-month-button"
    }, $jsx$1("i", {
      class: "icon icon-next"
    })));
  }
  renderYearSelector() {
    const calendar = this;
    if (calendar.params.renderYearSelector) {
      return calendar.params.renderYearSelector.call(calendar);
    }
    return $jsx$1("div", {
      class: "calendar-year-selector"
    }, $jsx$1("a", {
      class: "link icon-only calendar-prev-year-button"
    }, $jsx$1("i", {
      class: "icon icon-prev"
    })), calendar.params.yearPicker ? $jsx$1("a", {
      class: "current-year-value link"
    }) : $jsx$1("span", {
      class: "current-year-value"
    }), $jsx$1("a", {
      class: "link icon-only calendar-next-year-button"
    }, $jsx$1("i", {
      class: "icon icon-next"
    })));
  }
  // eslint-disable-next-line
  renderTimeSelector() {
    const calendar = this;
    const value2 = calendar.value && calendar.value[0];
    let timeString;
    if (value2) timeString = calendar.timeSelectorFormatter(value2);
    return $jsx$1("div", {
      class: "calendar-time-selector"
    }, $jsx$1("span", null, calendar.params.timePickerLabel), $jsx$1("a", {
      class: "link"
    }, timeString || calendar.params.timePickerPlaceholder));
  }
  renderHeader() {
    const calendar = this;
    if (calendar.params.renderHeader) {
      return calendar.params.renderHeader.call(calendar);
    }
    return $jsx$1("div", {
      class: "calendar-header"
    }, $jsx$1("div", {
      class: "calendar-selected-date"
    }, calendar.params.headerPlaceholder));
  }
  renderFooter() {
    const calendar = this;
    const app2 = calendar.app;
    if (calendar.params.renderFooter) {
      return calendar.params.renderFooter.call(calendar);
    }
    return $jsx$1("div", {
      class: "calendar-footer"
    }, $jsx$1("a", {
      class: `${app2.theme === "md" ? "button button-round" : "link"} calendar-close sheet-close popover-close`
    }, calendar.params.toolbarCloseText));
  }
  renderToolbar() {
    const calendar = this;
    if (calendar.params.renderToolbar) {
      return calendar.params.renderToolbar.call(calendar, calendar);
    }
    return $jsx$1("div", {
      class: "toolbar toolbar-top"
    }, $jsx$1("div", {
      class: "toolbar-inner"
    }, calendar.params.monthSelector ? calendar.renderMonthSelector() : "", calendar.params.yearSelector ? calendar.renderYearSelector() : ""));
  }
  // eslint-disable-next-line
  renderInline() {
    const calendar = this;
    const {
      cssClass,
      toolbar,
      header,
      footer,
      rangePicker,
      weekHeader
    } = calendar.params;
    const {
      value: value2,
      hasTimePicker
    } = calendar;
    const date = value2 && value2.length ? value2[0] : (/* @__PURE__ */ new Date()).setHours(0, 0, 0);
    return $jsx$1("div", {
      class: `calendar calendar-inline ${rangePicker ? "calendar-range" : ""} ${cssClass || ""}`
    }, header && calendar.renderHeader(), toolbar && calendar.renderToolbar(), weekHeader && calendar.renderWeekHeader(), $jsx$1("div", {
      class: "calendar-months"
    }, calendar.renderMonths(date)), hasTimePicker && calendar.renderTimeSelector(), footer && calendar.renderFooter());
  }
  renderCustomModal() {
    const calendar = this;
    const {
      cssClass,
      toolbar,
      header,
      footer,
      rangePicker,
      weekHeader
    } = calendar.params;
    const {
      value: value2,
      hasTimePicker
    } = calendar;
    const date = value2 && value2.length ? value2[0] : (/* @__PURE__ */ new Date()).setHours(0, 0, 0);
    return $jsx$1("div", {
      class: `calendar calendar-modal ${rangePicker ? "calendar-range" : ""} ${cssClass || ""}`
    }, header && calendar.renderHeader(), toolbar && calendar.renderToolbar(), weekHeader && calendar.renderWeekHeader(), $jsx$1("div", {
      class: "calendar-months"
    }, calendar.renderMonths(date)), hasTimePicker && calendar.renderTimeSelector(), footer && calendar.renderFooter());
  }
  renderSheet() {
    const calendar = this;
    const {
      cssClass,
      toolbar,
      header,
      footer,
      rangePicker,
      weekHeader
    } = calendar.params;
    const {
      value: value2,
      hasTimePicker
    } = calendar;
    const date = value2 && value2.length ? value2[0] : (/* @__PURE__ */ new Date()).setHours(0, 0, 0);
    return $jsx$1("div", {
      class: `sheet-modal calendar calendar-sheet ${rangePicker ? "calendar-range" : ""} ${cssClass || ""}`
    }, header && calendar.renderHeader(), toolbar && calendar.renderToolbar(), weekHeader && calendar.renderWeekHeader(), $jsx$1("div", {
      class: "sheet-modal-inner calendar-months"
    }, calendar.renderMonths(date)), hasTimePicker && calendar.renderTimeSelector(), footer && calendar.renderFooter());
  }
  renderPopover() {
    const calendar = this;
    const {
      cssClass,
      toolbar,
      header,
      footer,
      rangePicker,
      weekHeader
    } = calendar.params;
    const {
      value: value2,
      hasTimePicker
    } = calendar;
    const date = value2 && value2.length ? value2[0] : (/* @__PURE__ */ new Date()).setHours(0, 0, 0);
    return $jsx$1("div", {
      class: "popover calendar-popover"
    }, $jsx$1("div", {
      class: "popover-inner"
    }, $jsx$1("div", {
      class: `calendar ${rangePicker ? "calendar-range" : ""} ${cssClass || ""}`
    }, header && calendar.renderHeader(), toolbar && calendar.renderToolbar(), weekHeader && calendar.renderWeekHeader(), $jsx$1("div", {
      class: "calendar-months"
    }, calendar.renderMonths(date)), hasTimePicker && calendar.renderTimeSelector(), footer && calendar.renderFooter())));
  }
  render() {
    const calendar = this;
    const {
      params
    } = calendar;
    if (params.render) return params.render.call(calendar);
    if (!calendar.inline) {
      let modalType = params.openIn;
      if (modalType === "auto") modalType = calendar.isPopover() ? "popover" : "sheet";
      if (modalType === "popover") return calendar.renderPopover();
      if (modalType === "sheet") return calendar.renderSheet();
      return calendar.renderCustomModal();
    }
    return calendar.renderInline();
  }
  openMonthPicker() {
    const calendar = this;
    const {
      $el,
      app: app2
    } = calendar;
    if (!$el || !$el.length) return;
    $el.append('<div class="popover calendar-popover calendar-month-picker-popover"><div class="popover-inner"><div class="calendar-month-picker"></div></div></div>');
    calendar.monthPickerPopover = app2.popover.create({
      el: $el.find(".calendar-month-picker-popover"),
      targetEl: $el.find(".calendar-month-selector"),
      backdrop: true,
      backdropUnique: true,
      on: {
        close() {
          calendar.closeMonthPicker();
        },
        closed() {
          if (calendar.monthPickerPopover.$el) calendar.monthPickerPopover.$el.remove();
          calendar.monthPickerPopover.destroy();
          if (calendar.monthPickerInstance) {
            calendar.monthPickerInstance.close();
            calendar.monthPickerInstance.destroy();
          }
          delete calendar.monthPickerInstance;
          delete calendar.monthPickerPopover;
        }
      }
    });
    calendar.monthPickerPopover.open();
    const localeMonth = parseInt(calendar.$el.find(".calendar-month-current").attr("data-locale-month"), 10);
    const values = [];
    const displayValues = [];
    calendar.monthNames.forEach((m, index2) => {
      values.push(index2);
      displayValues.push(m);
    });
    calendar.monthPickerInstance = app2.picker.create({
      containerEl: calendar.monthPickerPopover.$el.find(".calendar-month-picker"),
      value: [localeMonth],
      toolbar: calendar.params.monthPickerToolbar,
      rotateEffect: false,
      toolbarCloseText: calendar.params.monthPickerCloseText,
      cols: [{
        values,
        displayValues
      }]
    });
  }
  closeMonthPicker() {
    const calendar = this;
    if (calendar.monthPickerPopover && calendar.monthPickerPopover.opened) calendar.monthPickerPopover.close();
    const index2 = calendar.monthPickerInstance.value[0];
    const localeMonthIndex = parseInt(calendar.$el.find(".calendar-month-current").attr("data-locale-month"), 10);
    const monthIndex = calendar.currentMonth;
    const diff = localeMonthIndex - monthIndex;
    const diffIndex = index2 - diff;
    calendar.setYearMonth(calendar.currentYear, diffIndex, 0);
  }
  openYearPicker() {
    const calendar = this;
    const {
      $el,
      app: app2
    } = calendar;
    if (!$el || !$el.length) return;
    $el.append('<div class="popover calendar-popover calendar-year-picker-popover"><div class="popover-inner"><div class="calendar-year-picker"></div></div></div>');
    calendar.yearPickerPopover = app2.popover.create({
      el: $el.find(".calendar-year-picker-popover"),
      targetEl: $el.find(".calendar-year-selector"),
      backdrop: true,
      backdropUnique: true,
      on: {
        close() {
          calendar.closeYearPicker();
        },
        closed() {
          if (calendar.yearPickerPopover.$el) calendar.yearPickerPopover.$el.remove();
          calendar.yearPickerPopover.destroy();
          if (calendar.yearPickerInstance) {
            calendar.yearPickerInstance.close();
            calendar.yearPickerInstance.destroy();
          }
          delete calendar.yearPickerInstance;
          delete calendar.yearPickerPopover;
        }
      }
    });
    calendar.yearPickerPopover.open();
    const currentYear = calendar.currentYear;
    let yearMin = calendar.params.yearPickerMin || (/* @__PURE__ */ new Date()).getFullYear() - 100;
    if (calendar.params.minDate) {
      yearMin = Math.max(yearMin, new Date(calendar.params.minDate).getFullYear());
    }
    let yearMax = calendar.params.yearPickerMax || (/* @__PURE__ */ new Date()).getFullYear() + 100;
    if (calendar.params.maxDate) {
      yearMax = Math.min(yearMax, new Date(calendar.params.maxDate).getFullYear());
    }
    const years = [];
    for (let i = yearMin; i <= yearMax; i += 1) {
      years.push(i);
    }
    calendar.yearPickerInstance = app2.picker.create({
      containerEl: calendar.yearPickerPopover.$el.find(".calendar-year-picker"),
      value: [currentYear],
      toolbar: calendar.params.yearPickerToolbar,
      rotateEffect: false,
      toolbarCloseText: calendar.params.yearPickerCloseText,
      cols: [{
        values: years
      }]
    });
  }
  closeYearPicker() {
    const calendar = this;
    if (calendar.yearPickerPopover && calendar.yearPickerPopover.opened) calendar.yearPickerPopover.close();
    calendar.setYearMonth(calendar.yearPickerInstance.value[0], void 0, 0);
  }
  openTimePicker() {
    const calendar = this;
    const {
      $el,
      app: app2,
      is12HoursFormat
    } = calendar;
    if (!$el || !$el.length) return;
    $el.append('<div class="popover calendar-popover calendar-time-picker-popover"><div class="popover-inner"><div class="calendar-time-picker"></div></div></div>');
    const hoursArr = [];
    const minutesArr = [];
    const hoursMin = is12HoursFormat ? 1 : 0;
    const hoursMax = is12HoursFormat ? 12 : 23;
    for (let i = hoursMin; i <= hoursMax; i += 1) {
      hoursArr.push(i);
    }
    for (let i = 0; i <= 59; i += 1) {
      minutesArr.push(i);
    }
    let value2;
    if (calendar.value && calendar.value.length) {
      value2 = [calendar.value[0].getHours(), calendar.value[0].getMinutes()];
    } else {
      value2 = [(/* @__PURE__ */ new Date()).getHours(), (/* @__PURE__ */ new Date()).getMinutes()];
    }
    if (is12HoursFormat) {
      value2.push(value2[0] < 12 ? "AM" : "PM");
      if (value2[0] > 12) value2[0] -= 12;
      if (value2[0] === 0) value2[0] = 12;
    }
    calendar.timePickerPopover = app2.popover.create({
      el: $el.find(".calendar-time-picker-popover"),
      targetEl: $el.find(".calendar-time-selector .link"),
      backdrop: true,
      backdropUnique: true,
      on: {
        close() {
          calendar.closeTimePicker();
        },
        closed() {
          if (calendar.timePickerPopover.$el) calendar.timePickerPopover.$el.remove();
          calendar.timePickerPopover.destroy();
          if (calendar.timePickerInstance) {
            calendar.timePickerInstance.close();
            calendar.timePickerInstance.destroy();
          }
          delete calendar.timePickerInstance;
          delete calendar.timePickerPopover;
        }
      }
    });
    calendar.timePickerPopover.open();
    calendar.timePickerInstance = app2.picker.create({
      containerEl: calendar.timePickerPopover.$el.find(".calendar-time-picker"),
      value: value2,
      toolbar: calendar.params.timePickerToolbar,
      rotateEffect: false,
      toolbarCloseText: calendar.params.timePickerCloseText,
      cols: [{
        values: hoursArr
      }, {
        divider: true,
        content: ":"
      }, {
        values: minutesArr,
        displayValues: minutesArr.map((m) => m < 10 ? `0${m}` : m)
      }, ...is12HoursFormat ? [{
        values: ["AM", "PM"]
      }] : []]
    });
  }
  closeTimePicker() {
    const calendar = this;
    const {
      is12HoursFormat
    } = calendar;
    if (calendar.timePickerInstance) {
      const timePickerValue = calendar.timePickerInstance.value;
      let hours = parseInt(timePickerValue[0], 10);
      const minutes = parseInt(timePickerValue[1], 10);
      const period = calendar.timePickerInstance.value[2];
      if (is12HoursFormat) {
        if (period === "AM" && hours === 12) {
          hours = 0;
        } else if (period === "PM" && hours !== 12) {
          hours += 12;
        }
      }
      let value2 = calendar.value && calendar.value.length && calendar.value[0];
      if (!value2) {
        value2 = /* @__PURE__ */ new Date();
        value2.setHours(hours, minutes, 0, 0);
      } else {
        value2 = new Date(value2);
        value2.setHours(hours, minutes);
      }
      calendar.setValue([value2]);
      if (calendar.timePickerPopover && calendar.timePickerPopover.opened) calendar.timePickerPopover.close();
    }
  }
  onOpen() {
    const calendar = this;
    const {
      initialized,
      $el,
      app: app2,
      $inputEl,
      inline,
      value: value2,
      params
    } = calendar;
    calendar.closing = false;
    calendar.opened = true;
    calendar.opening = true;
    calendar.attachCalendarEvents();
    const updateValue = !value2 && params.value;
    if (!initialized) {
      if (value2) calendar.setValue(value2, 0);
      else if (params.value) {
        calendar.setValue(calendar.normalizeValues(params.value), 0);
      }
    } else if (value2) {
      calendar.setValue(value2, 0);
    }
    calendar.updateCurrentMonthYear();
    calendar.monthsTranslate = 0;
    calendar.setMonthsTranslate();
    if (updateValue) calendar.updateValue();
    else if (params.header && value2) {
      calendar.updateValue(true);
    }
    if (!inline && $inputEl && $inputEl.length && app2.theme === "md") {
      $inputEl.trigger("focus");
    }
    calendar.initialized = true;
    calendar.$months.each((monthEl) => {
      calendar.emit("local::monthAdd calendarMonthAdd", monthEl);
    });
    if ($el) {
      $el.trigger("calendar:open");
    }
    if ($inputEl) {
      $inputEl.trigger("calendar:open");
    }
    calendar.emit("local::open calendarOpen", calendar);
  }
  onOpened() {
    const calendar = this;
    calendar.opening = false;
    if (calendar.$el) {
      calendar.$el.trigger("calendar:opened");
    }
    if (calendar.$inputEl) {
      calendar.$inputEl.trigger("calendar:opened");
    }
    calendar.emit("local::opened calendarOpened", calendar);
  }
  onClose() {
    const calendar = this;
    const app2 = calendar.app;
    calendar.opening = false;
    calendar.closing = true;
    if (calendar.$inputEl) {
      if (app2.theme === "md") {
        calendar.$inputEl.trigger("blur");
      } else {
        const validate = calendar.$inputEl.attr("validate");
        const required = calendar.$inputEl.attr("required");
        if (validate && required) {
          app2.input.validate(calendar.$inputEl);
        }
      }
    }
    if (calendar.detachCalendarEvents) {
      calendar.detachCalendarEvents();
    }
    if (calendar.$el) {
      calendar.$el.trigger("calendar:close");
    }
    if (calendar.$inputEl) {
      calendar.$inputEl.trigger("calendar:close");
    }
    calendar.emit("local::close calendarClose", calendar);
  }
  onClosed() {
    const calendar = this;
    calendar.opened = false;
    calendar.closing = false;
    if (!calendar.inline) {
      nextTick(() => {
        if (calendar.modal && calendar.modal.el && calendar.modal.destroy) {
          if (!calendar.params.routableModals) {
            calendar.modal.destroy();
          }
        }
        delete calendar.modal;
      });
    }
    if (calendar.timePickerInstance) {
      if (calendar.timePickerInstance.destroy) calendar.timePickerInstance.destroy();
      delete calendar.timePickerInstance;
    }
    if (calendar.$el) {
      calendar.$el.trigger("calendar:closed");
    }
    if (calendar.$inputEl) {
      calendar.$inputEl.trigger("calendar:closed");
    }
    calendar.emit("local::closed calendarClosed", calendar);
  }
  open() {
    const calendar = this;
    const {
      app: app2,
      opened,
      inline,
      $inputEl,
      params
    } = calendar;
    if (opened) return;
    if (inline) {
      calendar.$el = $(calendar.render());
      calendar.$el[0].f7Calendar = calendar;
      calendar.$wrapperEl = calendar.$el.find(".calendar-months-wrapper");
      calendar.$months = calendar.$wrapperEl.find(".calendar-month");
      calendar.$containerEl.append(calendar.$el);
      calendar.onOpen();
      calendar.onOpened();
      return;
    }
    let modalType = params.openIn;
    if (modalType === "auto") {
      modalType = calendar.isPopover() ? "popover" : "sheet";
    }
    const modalContent = calendar.render();
    const modalParams = {
      targetEl: $inputEl,
      scrollToEl: params.scrollToInput ? $inputEl : void 0,
      content: modalContent,
      backdrop: params.backdrop === true || (modalType === "popover" || modalType === "customModal") && app2.params.popover.backdrop !== false && params.backdrop !== false,
      closeByBackdropClick: params.closeByBackdropClick,
      on: {
        open() {
          const modal = this;
          calendar.modal = modal;
          calendar.$el = modalType === "popover" ? modal.$el.find(".calendar") : modal.$el;
          calendar.$wrapperEl = calendar.$el.find(".calendar-months-wrapper");
          calendar.$months = calendar.$wrapperEl.find(".calendar-month");
          calendar.$el[0].f7Calendar = calendar;
          if (modalType === "customModal") {
            $(calendar.$el).find(".calendar-close").once("click", () => {
              calendar.close();
            });
          }
          calendar.onOpen();
        },
        opened() {
          calendar.onOpened();
        },
        close() {
          calendar.onClose();
        },
        closed() {
          calendar.onClosed();
        }
      }
    };
    if (modalType === "sheet") {
      modalParams.push = params.sheetPush;
      modalParams.swipeToClose = params.sheetSwipeToClose;
    }
    if (params.routableModals && calendar.view) {
      calendar.view.router.navigate({
        url: calendar.url,
        route: {
          path: calendar.url,
          [modalType]: modalParams
        }
      });
    } else {
      calendar.modal = app2[modalType].create(modalParams);
      calendar.modal.open();
    }
  }
  close() {
    const calendar = this;
    const {
      opened,
      inline
    } = calendar;
    if (!opened) return;
    if (inline) {
      calendar.onClose();
      calendar.onClosed();
      return;
    }
    if (calendar.params.routableModals && calendar.view) {
      calendar.view.router.back();
    } else {
      calendar.modal.close();
    }
  }
  init() {
    const calendar = this;
    calendar.initInput();
    if (calendar.inline) {
      calendar.open();
      calendar.emit("local::init calendarInit", calendar);
      return;
    }
    if (!calendar.initialized && calendar.params.value) {
      calendar.setValue(calendar.normalizeValues(calendar.params.value));
    }
    if (calendar.$inputEl) {
      calendar.attachInputEvents();
    }
    if (calendar.params.closeByOutsideClick) {
      calendar.attachHtmlEvents();
    }
    calendar.emit("local::init calendarInit", calendar);
  }
  destroy() {
    const calendar = this;
    if (calendar.destroyed) return;
    const {
      $el
    } = calendar;
    calendar.emit("local::beforeDestroy calendarBeforeDestroy", calendar);
    if ($el) $el.trigger("calendar:beforedestroy");
    calendar.close();
    if (calendar.$inputEl) {
      calendar.detachInputEvents();
    }
    if (calendar.params.closeByOutsideClick) {
      calendar.detachHtmlEvents();
    }
    if (calendar.timePickerInstance) {
      if (calendar.timePickerInstance.destroy) calendar.timePickerInstance.destroy();
      delete calendar.timePickerInstance;
    }
    if ($el && $el.length) delete calendar.$el[0].f7Calendar;
    deleteProps(calendar);
    calendar.destroyed = true;
  }
};
const Calendar2 = {
  name: "calendar",
  static: {
    Calendar: Calendar$1
  },
  create() {
    const app2 = this;
    app2.calendar = ConstructorMethods({
      defaultSelector: ".calendar",
      constructor: Calendar$1,
      app: app2,
      domProp: "f7Calendar"
    });
    app2.calendar.close = function close4(el) {
      if (el === void 0) {
        el = ".calendar";
      }
      const $el = $(el);
      if ($el.length === 0) return;
      const calendar = $el[0].f7Calendar;
      if (!calendar || calendar && !calendar.opened) return;
      calendar.close();
    };
  },
  params: {
    calendar: {
      // Calendar settings
      dateFormat: void 0,
      monthNames: "auto",
      monthNamesShort: "auto",
      dayNames: "auto",
      dayNamesShort: "auto",
      locale: void 0,
      firstDay: 1,
      // First day of the week, Monday
      weekendDays: [0, 6],
      // Sunday and Saturday
      multiple: false,
      rangePicker: false,
      rangePickerMinDays: 1,
      // when calendar is used as rangePicker
      rangePickerMaxDays: 0,
      // when calendar is used as rangePicker, 0 means unlimited
      direction: "horizontal",
      // or 'vertical'
      minDate: null,
      maxDate: null,
      disabled: null,
      // dates range of disabled days
      events: null,
      // dates range of days with events
      rangesClasses: null,
      // array with custom classes date ranges
      touchMove: true,
      animate: true,
      closeOnSelect: false,
      monthSelector: true,
      monthPicker: true,
      monthPickerToolbar: true,
      monthPickerCloseText: "Done",
      yearSelector: true,
      yearPicker: true,
      yearPickerToolbar: true,
      yearPickerMin: void 0,
      yearPickerMax: void 0,
      yearPickerCloseText: "Done",
      timePicker: false,
      timePickerToolbar: true,
      timePickerLabel: "Time",
      timePickerFormat: {
        hour: "numeric",
        minute: "numeric"
      },
      timePickerPlaceholder: "Select time",
      timePickerCloseText: "Done",
      weekHeader: true,
      value: null,
      // Common opener settings
      containerEl: null,
      openIn: "auto",
      // or 'popover' or 'sheet' or 'customModal'
      sheetPush: false,
      sheetSwipeToClose: void 0,
      formatValue: null,
      inputEl: null,
      inputReadOnly: true,
      closeByOutsideClick: true,
      scrollToInput: true,
      header: false,
      headerPlaceholder: "Select date",
      toolbar: true,
      toolbarCloseText: "Done",
      footer: false,
      cssClass: null,
      routableModals: false,
      view: null,
      url: "date/",
      backdrop: null,
      closeByBackdropClick: true,
      // Render functions
      renderWeekHeader: null,
      renderMonths: null,
      renderMonth: null,
      renderMonthSelector: null,
      renderYearSelector: null,
      renderHeader: null,
      renderFooter: null,
      renderToolbar: null,
      renderInline: null,
      renderPopover: null,
      renderSheet: null,
      render: null
    }
  }
};
const defaultDiacriticsRemovalap = [{
  base: "A",
  letters: "A"
}, {
  base: "AA",
  letters: ""
}, {
  base: "AE",
  letters: ""
}, {
  base: "AO",
  letters: ""
}, {
  base: "AU",
  letters: ""
}, {
  base: "AV",
  letters: ""
}, {
  base: "AY",
  letters: ""
}, {
  base: "B",
  letters: "B"
}, {
  base: "C",
  letters: "C"
}, {
  base: "D",
  letters: "D"
}, {
  base: "DZ",
  letters: ""
}, {
  base: "Dz",
  letters: ""
}, {
  base: "E",
  letters: "E"
}, {
  base: "F",
  letters: "F"
}, {
  base: "G",
  letters: "G"
}, {
  base: "H",
  letters: "H"
}, {
  base: "I",
  letters: "I"
}, {
  base: "J",
  letters: "J"
}, {
  base: "K",
  letters: "K"
}, {
  base: "L",
  letters: "L"
}, {
  base: "LJ",
  letters: ""
}, {
  base: "Lj",
  letters: ""
}, {
  base: "M",
  letters: "M"
}, {
  base: "N",
  letters: "N"
}, {
  base: "NJ",
  letters: ""
}, {
  base: "Nj",
  letters: ""
}, {
  base: "O",
  letters: "O"
}, {
  base: "OI",
  letters: ""
}, {
  base: "OO",
  letters: ""
}, {
  base: "OU",
  letters: ""
}, {
  base: "OE",
  letters: ""
}, {
  base: "oe",
  letters: ""
}, {
  base: "P",
  letters: "P"
}, {
  base: "Q",
  letters: "Q"
}, {
  base: "R",
  letters: "R"
}, {
  base: "S",
  letters: "S"
}, {
  base: "T",
  letters: "T"
}, {
  base: "TZ",
  letters: ""
}, {
  base: "U",
  letters: "U"
}, {
  base: "V",
  letters: "V"
}, {
  base: "VY",
  letters: ""
}, {
  base: "W",
  letters: "W"
}, {
  base: "X",
  letters: "X"
}, {
  base: "Y",
  letters: "Y"
}, {
  base: "Z",
  letters: "Z"
}, {
  base: "a",
  letters: "a"
}, {
  base: "aa",
  letters: ""
}, {
  base: "ae",
  letters: ""
}, {
  base: "ao",
  letters: ""
}, {
  base: "au",
  letters: ""
}, {
  base: "av",
  letters: ""
}, {
  base: "ay",
  letters: ""
}, {
  base: "b",
  letters: "b"
}, {
  base: "c",
  letters: "c"
}, {
  base: "d",
  letters: "d"
}, {
  base: "dz",
  letters: ""
}, {
  base: "e",
  letters: "e"
}, {
  base: "f",
  letters: "f"
}, {
  base: "g",
  letters: "g"
}, {
  base: "h",
  letters: "h"
}, {
  base: "hv",
  letters: ""
}, {
  base: "i",
  letters: "i"
}, {
  base: "j",
  letters: "j"
}, {
  base: "k",
  letters: "k"
}, {
  base: "l",
  letters: "l"
}, {
  base: "lj",
  letters: ""
}, {
  base: "m",
  letters: "m"
}, {
  base: "n",
  letters: "n"
}, {
  base: "nj",
  letters: ""
}, {
  base: "o",
  letters: "o"
}, {
  base: "oi",
  letters: ""
}, {
  base: "ou",
  letters: ""
}, {
  base: "oo",
  letters: ""
}, {
  base: "p",
  letters: "p"
}, {
  base: "q",
  letters: "q"
}, {
  base: "r",
  letters: "r"
}, {
  base: "s",
  letters: "s"
}, {
  base: "t",
  letters: "t"
}, {
  base: "tz",
  letters: ""
}, {
  base: "u",
  letters: "u"
}, {
  base: "v",
  letters: "v"
}, {
  base: "vy",
  letters: ""
}, {
  base: "w",
  letters: "w"
}, {
  base: "x",
  letters: "x"
}, {
  base: "y",
  letters: "y"
}, {
  base: "z",
  letters: "z"
}];
const diacriticsMap = {};
for (let i = 0; i < defaultDiacriticsRemovalap.length; i += 1) {
  const letters = defaultDiacriticsRemovalap[i].letters;
  for (let j = 0; j < letters.length; j += 1) {
    diacriticsMap[letters[j]] = defaultDiacriticsRemovalap[i].base;
  }
}
function removeDiacritics(str) {
  return str.replace(/[^\u0000-\u007E]/g, (a) => diacriticsMap[a] || a);
}
class SmartSelect extends Framework7Class {
  constructor(app2, params) {
    if (params === void 0) {
      params = {};
    }
    super(params, [app2]);
    const ss = this;
    const defaults2 = extend$1({
      on: {}
    }, app2.params.smartSelect);
    ss.useModulesParams(defaults2);
    ss.params = extend$1({}, defaults2, params);
    ss.app = app2;
    const $el = $(ss.params.el).eq(0);
    if ($el.length === 0) return ss;
    if ($el[0].f7SmartSelect) return $el[0].f7SmartSelect;
    const $selectEl = $el.find("select").eq(0);
    if ($selectEl.length === 0) return ss;
    let $valueEl;
    if (ss.params.setValueText) {
      $valueEl = $(ss.params.valueEl);
      if ($valueEl.length === 0) {
        $valueEl = $el.find(".item-after");
      }
      if ($valueEl.length === 0) {
        $valueEl = $('<div class="item-after"></div>');
        $valueEl.insertAfter($el.find(".item-title"));
      }
    }
    let url = params.url;
    if (!url) {
      if ($el.attr("href") && $el.attr("href") !== "#") url = $el.attr("href");
      else if ($selectEl.attr("name")) url = `${$selectEl.attr("name").toLowerCase()}-select/`;
    }
    if (!url) url = ss.params.url;
    const multiple = $selectEl[0].multiple;
    const inputType = multiple ? "checkbox" : "radio";
    const selectId = id();
    extend$1(ss, {
      $el,
      el: $el[0],
      $selectEl,
      selectEl: $selectEl[0],
      $valueEl,
      valueEl: $valueEl && $valueEl[0],
      url,
      multiple,
      inputType,
      id: selectId,
      inputName: `${inputType}-${selectId}`,
      selectName: $selectEl.attr("name"),
      maxLength: $selectEl.attr("maxlength") || params.maxLength
    });
    $el[0].f7SmartSelect = ss;
    function onClick() {
      ss.open();
    }
    function onChange() {
      const value2 = ss.$selectEl.val();
      ss.$el.trigger("smartselect:change", value2);
      ss.emit("local::change smartSelectChange", ss, value2);
      if (ss.vl) {
        ss.vl.clearCache();
      }
      ss.setValueText();
    }
    ss.attachEvents = function attachEvents() {
      $el.on("click", onClick);
      $el.on("change", "select", onChange);
    };
    ss.detachEvents = function detachEvents() {
      $el.off("click", onClick);
      $el.off("change", "select", onChange);
    };
    function handleInputChange() {
      let optionEl;
      let text2;
      const inputEl = this;
      const value2 = inputEl.value;
      let optionText = [];
      let displayAs;
      if (inputEl.type === "checkbox") {
        for (let i = 0; i < ss.selectEl.options.length; i += 1) {
          optionEl = ss.selectEl.options[i];
          if (optionEl.value === value2) {
            optionEl.selected = inputEl.checked;
          }
          if (optionEl.selected) {
            displayAs = optionEl.dataset ? optionEl.dataset.displayAs : $(optionEl).data("display-value-as");
            text2 = displayAs && typeof displayAs !== "undefined" ? displayAs : optionEl.textContent;
            optionText.push(text2.trim());
          }
        }
        if (ss.maxLength) {
          ss.checkMaxLength();
        }
      } else {
        optionEl = ss.$selectEl.find(`option[value="${value2}"]`)[0];
        if (!optionEl) {
          optionEl = ss.$selectEl.find("option").filter((optEl) => optEl.value === value2)[0];
        }
        displayAs = optionEl.dataset ? optionEl.dataset.displayAs : $(optionEl).data("display-as");
        text2 = displayAs && typeof displayAs !== "undefined" ? displayAs : optionEl.textContent;
        optionText = [text2];
        ss.selectEl.value = value2;
      }
      ss.$selectEl.trigger("change");
      if (ss.params.setValueText) {
        ss.formatValueTextContent(optionText);
      }
      if (ss.params.closeOnSelect && ss.inputType === "radio") {
        ss.close();
      }
    }
    ss.attachInputsEvents = function attachInputsEvents() {
      ss.$containerEl.on("change", 'input[type="checkbox"], input[type="radio"]', handleInputChange);
    };
    ss.detachInputsEvents = function detachInputsEvents() {
      ss.$containerEl.off("change", 'input[type="checkbox"], input[type="radio"]', handleInputChange);
    };
    ss.useModules();
    ss.init();
    return ss;
  }
  setValue(value2) {
    const ss = this;
    let newValue = value2;
    let optionText = [];
    let optionEl;
    let displayAs;
    let text2;
    if (ss.multiple) {
      if (!Array.isArray(newValue)) newValue = [newValue];
      for (let i = 0; i < ss.selectEl.options.length; i += 1) {
        optionEl = ss.selectEl.options[i];
        if (newValue.indexOf(optionEl.value) >= 0) {
          optionEl.selected = true;
        } else {
          optionEl.selected = false;
        }
        if (optionEl.selected) {
          displayAs = optionEl.dataset ? optionEl.dataset.displayAs : $(optionEl).data("display-value-as");
          text2 = displayAs && typeof displayAs !== "undefined" ? displayAs : optionEl.textContent;
          optionText.push(text2.trim());
        }
      }
    } else {
      optionEl = ss.$selectEl.find(`option[value="${newValue}"]`)[0];
      if (optionEl) {
        displayAs = optionEl.dataset ? optionEl.dataset.displayAs : $(optionEl).data("display-as");
        text2 = displayAs && typeof displayAs !== "undefined" ? displayAs : optionEl.textContent;
        optionText = [text2];
      }
      ss.selectEl.value = newValue;
    }
    if (ss.params.setValueText) {
      ss.formatValueTextContent(optionText);
    }
    ss.$selectEl.trigger("change");
    return ss;
  }
  unsetValue() {
    const ss = this;
    if (ss.params.setValueText) {
      ss.formatValueTextContent([]);
    }
    ss.$selectEl.find("option").each((optionEl) => {
      optionEl.selected = false;
      optionEl.checked = false;
    });
    ss.$selectEl[0].value = null;
    if (ss.$containerEl) {
      ss.$containerEl.find(`input[name="${ss.inputName}"][type="checkbox"], input[name="${ss.inputName}"][type="radio"]`).prop("checked", false);
    }
    ss.$selectEl.trigger("change");
  }
  getValue() {
    const ss = this;
    return ss.$selectEl.val();
  }
  get view() {
    const {
      params,
      $el
    } = this;
    let view;
    if (params.view) {
      view = params.view;
    }
    if (!view) {
      view = $el.parents(".view").length && $el.parents(".view")[0].f7View;
    }
    if (!view && params.openIn === "page") {
      throw Error("Smart Select requires initialized View");
    }
    return view;
  }
  checkMaxLength() {
    const ss = this;
    const $containerEl = ss.$containerEl;
    if (ss.selectEl.selectedOptions.length >= ss.maxLength) {
      $containerEl.find('input[type="checkbox"]').each((inputEl) => {
        if (!inputEl.checked) {
          $(inputEl).parents("li").addClass("disabled");
        } else {
          $(inputEl).parents("li").removeClass("disabled");
        }
      });
    } else {
      $containerEl.find(".disabled").removeClass("disabled");
    }
  }
  formatValueTextContent(values) {
    const ss = this;
    const valueFormatted = ss.formatValueText(values);
    if (valueFormatted.includes("<") && valueFormatted.includes(">")) {
      ss.$valueEl.html(valueFormatted);
    } else {
      ss.$valueEl.text(valueFormatted);
    }
  }
  formatValueText(values) {
    const ss = this;
    let textValue;
    if (ss.params.formatValueText) {
      textValue = ss.params.formatValueText.call(ss, values, ss);
    } else {
      textValue = values.join(", ");
    }
    return textValue;
  }
  setValueText(value2) {
    const ss = this;
    let valueArray = [];
    if (typeof value2 !== "undefined") {
      if (Array.isArray(value2)) {
        valueArray = value2;
      } else {
        valueArray = [value2];
      }
    } else {
      ss.$selectEl.find("option").each((optionEl) => {
        const $optionEl = $(optionEl);
        if (optionEl.selected) {
          const displayAs = optionEl.dataset ? optionEl.dataset.displayAs : $optionEl.data("display-value-as");
          if (displayAs && typeof displayAs !== "undefined") {
            valueArray.push(displayAs);
          } else {
            valueArray.push(optionEl.textContent.trim());
          }
        }
      });
    }
    if (ss.params.setValueText) {
      ss.formatValueTextContent(valueArray);
    }
  }
  getItemsData() {
    const ss = this;
    const theme = ss.app.theme;
    const items = [];
    let previousGroupEl;
    ss.$selectEl.find("option").each((optionEl) => {
      const $optionEl = $(optionEl);
      const optionData = $optionEl.dataset();
      const optionImage = optionData.optionImage || ss.params.optionImage;
      const optionIcon = optionData.optionIcon || ss.params.optionIcon;
      const optionIconIos = theme === "ios" && (optionData.optionIconIos || ss.params.optionIconIos);
      const optionIconMd = theme === "md" && (optionData.optionIconMd || ss.params.optionIconMd);
      const optionInputIconPosition = optionData.inputIconPosition || ss.params.inputIconPosition || "";
      const optionHasMedia = optionImage || optionIcon || optionIconIos || optionIconMd;
      const optionColor = optionData.optionColor;
      let optionClassName = optionData.optionClass || "";
      if ($optionEl[0].disabled) optionClassName += " disabled";
      const optionGroupEl = $optionEl.parent("optgroup")[0];
      const optionGroupLabel = optionGroupEl && optionGroupEl.label;
      let optionIsLabel = false;
      if (optionGroupEl && optionGroupEl !== previousGroupEl) {
        optionIsLabel = true;
        previousGroupEl = optionGroupEl;
        items.push({
          groupLabel: optionGroupLabel,
          isLabel: optionIsLabel
        });
      }
      items.push({
        value: $optionEl[0].value,
        text: $optionEl[0].textContent.trim(),
        selected: $optionEl[0].selected,
        groupEl: optionGroupEl,
        groupLabel: optionGroupLabel,
        image: optionImage,
        icon: optionIcon,
        iconIos: optionIconIos,
        iconMd: optionIconMd,
        inputIconPosition: optionInputIconPosition,
        color: optionColor,
        className: optionClassName,
        disabled: $optionEl[0].disabled,
        id: ss.id,
        hasMedia: optionHasMedia,
        checkbox: ss.inputType === "checkbox",
        radio: ss.inputType === "radio",
        inputName: ss.inputName,
        inputType: ss.inputType
      });
    });
    ss.items = items;
    return items;
  }
  renderSearchbar() {
    const ss = this;
    if (ss.params.renderSearchbar) return ss.params.renderSearchbar.call(ss);
    return $jsx$1("form", {
      class: "searchbar"
    }, $jsx$1("div", {
      class: "searchbar-inner"
    }, $jsx$1("div", {
      class: "searchbar-input-wrap"
    }, $jsx$1("input", {
      type: "search",
      spellcheck: ss.params.searchbarSpellcheck || "false",
      placeholder: ss.params.searchbarPlaceholder
    }), $jsx$1("i", {
      class: "searchbar-icon"
    }), $jsx$1("span", {
      class: "input-clear-button"
    })), ss.params.searchbarDisableButton && $jsx$1("span", {
      class: "searchbar-disable-button"
    }, ss.params.searchbarDisableText)));
  }
  renderItem(item, index2) {
    const ss = this;
    if (ss.params.renderItem) return ss.params.renderItem.call(ss, item, index2);
    function getIconContent(iconValue) {
      if (iconValue === void 0) {
        iconValue = "";
      }
      if (iconValue.indexOf(":") >= 0) {
        return iconValue.split(":")[1];
      }
      return "";
    }
    function getIconClass(iconValue) {
      if (iconValue === void 0) {
        iconValue = "";
      }
      if (iconValue.indexOf(":") >= 0) {
        let className = iconValue.split(":")[0];
        if (className === "f7") className = "f7-icons";
        if (className === "material") className = "material-icons";
        return className;
      }
      return iconValue;
    }
    let itemHtml;
    if (item.isLabel) {
      itemHtml = `<li class="list-group-title">${item.groupLabel}</li>`;
    } else {
      let selected = item.selected;
      let disabled;
      if (ss.params.virtualList) {
        const ssValue = ss.getValue();
        selected = ss.multiple ? ssValue.indexOf(item.value) >= 0 : ssValue === item.value;
        if (ss.multiple) {
          disabled = ss.multiple && !selected && ssValue.length === parseInt(ss.maxLength, 10);
        }
      }
      const {
        icon,
        iconIos,
        iconMd
      } = item;
      const hasIcon = icon || iconIos || iconMd;
      const iconContent = getIconContent(icon || iconIos || iconMd || "");
      const iconClass = getIconClass(icon || iconIos || iconMd || "");
      itemHtml = $jsx$1("li", {
        class: `${item.className || ""}${disabled ? " disabled" : ""}`
      }, $jsx$1("label", {
        class: `item-${item.inputType} ${item.inputIconPosition ? `item-${item.inputType}-icon-${item.inputIconPosition}` : ""} item-content`
      }, $jsx$1("input", {
        type: item.inputType,
        name: item.inputName,
        value: item.value,
        _checked: selected
      }), $jsx$1("i", {
        class: `icon icon-${item.inputType}`
      }), item.hasMedia && $jsx$1("div", {
        class: "item-media"
      }, hasIcon && $jsx$1("i", {
        class: `icon ${iconClass}`
      }, iconContent), item.image && $jsx$1("img", {
        src: item.image
      })), $jsx$1("div", {
        class: "item-inner"
      }, $jsx$1("div", {
        class: `item-title${item.color ? ` text-color-${item.color}` : ""}`
      }, item.text))));
    }
    return itemHtml;
  }
  renderItems() {
    const ss = this;
    if (ss.params.renderItems) return ss.params.renderItems.call(ss, ss.items);
    const itemsHtml = `
      ${ss.items.map((item, index2) => `${ss.renderItem(item, index2)}`).join("")}
    `;
    return itemsHtml;
  }
  renderPage() {
    const ss = this;
    if (ss.params.renderPage) return ss.params.renderPage.call(ss, ss.items);
    let pageTitle = ss.params.pageTitle;
    if (typeof pageTitle === "undefined") {
      const $itemTitleEl = ss.$el.find(".item-title");
      pageTitle = $itemTitleEl.length ? $itemTitleEl.text().trim() : "";
    }
    const cssClass = ss.params.cssClass;
    return $jsx$1("div", {
      class: `page smart-select-page ${cssClass}`,
      "data-name": "smart-select-page",
      "data-select-name": ss.selectName
    }, $jsx$1("div", {
      class: `navbar ${ss.params.navbarColorTheme ? `color-${ss.params.navbarColorTheme}` : ""}`
    }, $jsx$1("div", {
      class: "navbar-bg"
    }), $jsx$1("div", {
      class: `navbar-inner sliding ${ss.params.navbarColorTheme ? `color-${ss.params.navbarColorTheme}` : ""}`
    }, $jsx$1("div", {
      class: "left"
    }, $jsx$1("a", {
      class: "link back"
    }, $jsx$1("i", {
      class: "icon icon-back"
    }), $jsx$1("span", {
      class: "if-not-md"
    }, ss.params.pageBackLinkText))), pageTitle && $jsx$1("div", {
      class: "title"
    }, pageTitle), ss.params.searchbar && $jsx$1("div", {
      class: "subnavbar"
    }, ss.renderSearchbar()))), ss.params.searchbar && $jsx$1("div", {
      class: "searchbar-backdrop"
    }), $jsx$1("div", {
      class: "page-content"
    }, $jsx$1("div", {
      class: `list list-outline-ios list-strong-ios list-dividers-ios smart-select-list-${ss.id} ${ss.params.virtualList ? " virtual-list" : ""} ${ss.params.formColorTheme ? `color-${ss.params.formColorTheme}` : ""}`
    }, $jsx$1("ul", null, !ss.params.virtualList && ss.renderItems(ss.items)))));
  }
  renderPopup() {
    const ss = this;
    if (ss.params.renderPopup) return ss.params.renderPopup.call(ss, ss.items);
    let pageTitle = ss.params.pageTitle;
    if (typeof pageTitle === "undefined") {
      const $itemTitleEl = ss.$el.find(".item-title");
      pageTitle = $itemTitleEl.length ? $itemTitleEl.text().trim() : "";
    }
    const cssClass = ss.params.cssClass || "";
    return $jsx$1("div", {
      class: `popup smart-select-popup ${cssClass} ${ss.params.popupTabletFullscreen ? "popup-tablet-fullscreen" : ""}`,
      "data-select-name": ss.selectName
    }, $jsx$1("div", {
      class: "view"
    }, $jsx$1("div", {
      class: `page smart-select-page ${ss.params.searchbar ? "page-with-subnavbar" : ""}`,
      "data-name": "smart-select-page"
    }, $jsx$1("div", {
      class: `navbar ${ss.params.navbarColorTheme ? `color-${ss.params.navbarColorTheme}` : ""}`
    }, $jsx$1("div", {
      class: "navbar-bg"
    }), $jsx$1("div", {
      class: "navbar-inner sliding"
    }, pageTitle && $jsx$1("div", {
      class: "title"
    }, pageTitle), $jsx$1("div", {
      class: "right"
    }, $jsx$1("a", {
      class: "link popup-close",
      "data-popup": `.smart-select-popup[data-select-name='${ss.selectName}']`
    }, ss.params.popupCloseLinkText)), ss.params.searchbar && $jsx$1("div", {
      class: "subnavbar"
    }, ss.renderSearchbar()))), ss.params.searchbar && $jsx$1("div", {
      class: "searchbar-backdrop"
    }), $jsx$1("div", {
      class: "page-content"
    }, $jsx$1("div", {
      class: `list list-outline-ios list-strong-ios list-dividers-ios smart-select-list-${ss.id} ${ss.params.virtualList ? " virtual-list" : ""} ${ss.params.formColorTheme ? `color-${ss.params.formColorTheme}` : ""}`
    }, $jsx$1("ul", null, !ss.params.virtualList && ss.renderItems(ss.items)))))));
  }
  renderSheet() {
    const ss = this;
    if (ss.params.renderSheet) return ss.params.renderSheet.call(ss, ss.items);
    const cssClass = ss.params.cssClass;
    return $jsx$1("div", {
      class: `sheet-modal smart-select-sheet ${cssClass}`,
      "data-select-name": ss.selectName
    }, $jsx$1("div", {
      class: `toolbar toolbar-top ${ss.params.toolbarColorTheme ? `color-${ss.params.toolbarColorTheme}` : ""}`
    }, $jsx$1("div", {
      class: "toolbar-inner"
    }, $jsx$1("div", {
      class: "left"
    }), $jsx$1("div", {
      class: "right"
    }, $jsx$1("a", {
      class: "link sheet-close"
    }, ss.params.sheetCloseLinkText)))), $jsx$1("div", {
      class: "sheet-modal-inner"
    }, $jsx$1("div", {
      class: "page-content"
    }, $jsx$1("div", {
      class: `list list-strong-ios list-dividers-ios smart-select-list-${ss.id} ${ss.params.virtualList ? " virtual-list" : ""} ${ss.params.formColorTheme ? `color-${ss.params.formColorTheme}` : ""}`
    }, $jsx$1("ul", null, !ss.params.virtualList && ss.renderItems(ss.items))))));
  }
  renderPopover() {
    const ss = this;
    if (ss.params.renderPopover) return ss.params.renderPopover.call(ss, ss.items);
    const cssClass = ss.params.cssClass;
    return $jsx$1("div", {
      class: `popover smart-select-popover ${cssClass}`,
      "data-select-name": ss.selectName
    }, $jsx$1("div", {
      class: "popover-inner"
    }, $jsx$1("div", {
      class: `list list-strong-ios list-dividers-ios smart-select-list-${ss.id} ${ss.params.virtualList ? " virtual-list" : ""} ${ss.params.formColorTheme ? `color-${ss.params.formColorTheme}` : ""}`
    }, $jsx$1("ul", null, !ss.params.virtualList && ss.renderItems(ss.items)))));
  }
  scrollToSelectedItem() {
    const ss = this;
    const {
      params,
      $containerEl
    } = ss;
    if (!ss.opened) return ss;
    if (params.virtualList) {
      let selectedIndex;
      ss.vl.items.forEach((item, index2) => {
        if (typeof selectedIndex === "undefined" && item.selected) {
          selectedIndex = index2;
        }
      });
      if (typeof selectedIndex !== "undefined") {
        ss.vl.scrollToItem(selectedIndex);
      }
    } else {
      const $selectedItemEl = $containerEl.find("input:checked").parents("li");
      if (!$selectedItemEl.length) return ss;
      const $scrollableEl = $containerEl.find(".page-content, .popover-inner");
      if (!$scrollableEl.length) return ss;
      $scrollableEl.scrollTop($selectedItemEl.offset().top - $scrollableEl.offset().top - parseInt($scrollableEl.css("padding-top"), 10));
    }
    return ss;
  }
  onOpen(type, containerEl) {
    const ss = this;
    const app2 = ss.app;
    const $containerEl = $(containerEl);
    ss.$containerEl = $containerEl;
    ss.openedIn = type;
    ss.opened = true;
    if (ss.params.virtualList) {
      ss.vl = app2.virtualList.create({
        el: $containerEl.find(".virtual-list"),
        items: ss.items,
        renderItem: ss.renderItem.bind(ss),
        height: ss.params.virtualListHeight,
        searchByItem(query, item) {
          if (item.text && removeDiacritics(item.text).toLowerCase().indexOf(query.trim().toLowerCase()) >= 0) return true;
          return false;
        }
      });
    }
    if (ss.params.scrollToSelectedItem) {
      ss.scrollToSelectedItem();
    }
    if (ss.params.searchbar) {
      let $searchbarEl = $containerEl.find(".searchbar");
      if (type === "page" && app2.theme === "ios") {
        $searchbarEl = $(app2.navbar.getElByPage($containerEl)).find(".searchbar");
      }
      if (ss.params.appendSearchbarNotFound && (type === "page" || type === "popup")) {
        let $notFoundEl = null;
        if (typeof ss.params.appendSearchbarNotFound === "string") {
          $notFoundEl = $(`<div class="block searchbar-not-found">${ss.params.appendSearchbarNotFound}</div>`);
        } else if (typeof ss.params.appendSearchbarNotFound === "boolean") {
          $notFoundEl = $('<div class="block searchbar-not-found">Nothing found</div>');
        } else {
          $notFoundEl = ss.params.appendSearchbarNotFound;
        }
        if ($notFoundEl) {
          $containerEl.find(".page-content").append($notFoundEl[0]);
        }
      }
      const searchbarParams = extend$1({
        el: $searchbarEl,
        backdropEl: $containerEl.find(".searchbar-backdrop"),
        searchContainer: `.smart-select-list-${ss.id}`,
        searchIn: ".item-title"
      }, typeof ss.params.searchbar === "object" ? ss.params.searchbar : {});
      ss.searchbar = app2.searchbar.create(searchbarParams);
    }
    if (ss.maxLength) {
      ss.checkMaxLength();
    }
    if (ss.params.closeOnSelect) {
      ss.$containerEl.find(`input[type="radio"][name="${ss.inputName}"]:checked`).parents("label").once("click", () => {
        ss.close();
      });
    }
    ss.attachInputsEvents();
    ss.$el.trigger("smartselect:open");
    ss.emit("local::open smartSelectOpen", ss);
  }
  onOpened() {
    const ss = this;
    ss.$el.trigger("smartselect:opened");
    ss.emit("local::opened smartSelectOpened", ss);
  }
  onClose() {
    const ss = this;
    if (ss.destroyed) return;
    if (ss.vl && ss.vl.destroy) {
      ss.vl.destroy();
      ss.vl = null;
      delete ss.vl;
    }
    if (ss.searchbar && ss.searchbar.destroy) {
      ss.searchbar.destroy();
      ss.searchbar = null;
      delete ss.searchbar;
    }
    ss.detachInputsEvents();
    ss.$el.trigger("smartselect:close");
    ss.emit("local::close smartSelectClose", ss);
  }
  onClosed() {
    const ss = this;
    if (ss.destroyed) return;
    ss.opened = false;
    ss.$containerEl = null;
    delete ss.$containerEl;
    ss.$el.trigger("smartselect:closed");
    ss.emit("local::closed smartSelectClosed", ss);
  }
  openPage() {
    const ss = this;
    if (ss.opened) return ss;
    ss.getItemsData();
    const pageHtml = ss.renderPage(ss.items);
    ss.view.router.navigate({
      url: ss.url,
      route: {
        content: pageHtml,
        path: ss.url,
        on: {
          pageBeforeIn(e, page) {
            ss.onOpen("page", page.el);
          },
          pageAfterIn(e, page) {
            ss.onOpened("page", page.el);
          },
          pageBeforeOut(e, page) {
            ss.onClose("page", page.el);
          },
          pageAfterOut(e, page) {
            ss.onClosed("page", page.el);
          }
        }
      }
    });
    return ss;
  }
  openPopup() {
    const ss = this;
    if (ss.opened) return ss;
    ss.getItemsData();
    const popupHtml = ss.renderPopup(ss.items);
    const popupParams = {
      content: popupHtml,
      push: ss.params.popupPush,
      swipeToClose: ss.params.popupSwipeToClose,
      closeByBackdropClick: ss.params.closeByBackdropClick,
      on: {
        popupOpen(popup) {
          ss.onOpen("popup", popup.el);
        },
        popupOpened(popup) {
          ss.onOpened("popup", popup.el);
        },
        popupClose(popup) {
          ss.onClose("popup", popup.el);
        },
        popupClosed(popup) {
          ss.onClosed("popup", popup.el);
        }
      }
    };
    if (ss.params.routableModals && ss.view) {
      ss.view.router.navigate({
        url: ss.url,
        route: {
          path: ss.url,
          popup: popupParams
        }
      });
    } else {
      ss.modal = ss.app.popup.create(popupParams).open();
    }
    return ss;
  }
  openSheet() {
    const ss = this;
    if (ss.opened) return ss;
    ss.getItemsData();
    const sheetHtml = ss.renderSheet(ss.items);
    const sheetParams = {
      content: sheetHtml,
      backdrop: ss.params.sheetBackdrop,
      scrollToEl: ss.$el,
      closeByOutsideClick: true,
      push: ss.params.sheetPush,
      swipeToClose: ss.params.sheetSwipeToClose,
      closeByBackdropClick: ss.params.closeByBackdropClick,
      on: {
        sheetOpen(sheet) {
          ss.onOpen("sheet", sheet.el);
        },
        sheetOpened(sheet) {
          ss.onOpened("sheet", sheet.el);
        },
        sheetClose(sheet) {
          ss.onClose("sheet", sheet.el);
        },
        sheetClosed(sheet) {
          ss.onClosed("sheet", sheet.el);
        }
      }
    };
    if (ss.params.routableModals && ss.view) {
      ss.view.router.navigate({
        url: ss.url,
        route: {
          path: ss.url,
          sheet: sheetParams
        }
      });
    } else {
      ss.modal = ss.app.sheet.create(sheetParams).open();
    }
    return ss;
  }
  openPopover() {
    const ss = this;
    if (ss.opened) return ss;
    ss.getItemsData();
    const popoverHtml = ss.renderPopover(ss.items);
    const popoverParams = {
      content: popoverHtml,
      targetEl: ss.$el,
      closeByBackdropClick: ss.params.closeByBackdropClick,
      on: {
        popoverOpen(popover) {
          ss.onOpen("popover", popover.el);
        },
        popoverOpened(popover) {
          ss.onOpened("popover", popover.el);
        },
        popoverClose(popover) {
          ss.onClose("popover", popover.el);
        },
        popoverClosed(popover) {
          ss.onClosed("popover", popover.el);
        }
      }
    };
    if (ss.params.routableModals && ss.view) {
      ss.view.router.navigate({
        url: ss.url,
        route: {
          path: ss.url,
          popover: popoverParams
        }
      });
    } else {
      ss.modal = ss.app.popover.create(popoverParams).open();
    }
    return ss;
  }
  open(type) {
    const ss = this;
    if (ss.opened) return ss;
    let prevented = false;
    function prevent() {
      prevented = true;
    }
    if (ss.$el) {
      ss.$el.trigger("smartselect:beforeopen", {
        prevent
      });
    }
    ss.emit("local::beforeOpen smartSelectBeforeOpen", ss, prevent);
    if (prevented) return ss;
    const openIn = type || ss.params.openIn;
    ss[`open${openIn.split("").map((el, index2) => {
      if (index2 === 0) return el.toUpperCase();
      return el;
    }).join("")}`]();
    return ss;
  }
  close() {
    const ss = this;
    if (!ss.opened) return ss;
    if (ss.params.routableModals && ss.view || ss.openedIn === "page") {
      ss.view.router.back();
    } else {
      ss.modal.once("modalClosed", () => {
        nextTick(() => {
          if (ss.destroyed) return;
          ss.modal.destroy();
          delete ss.modal;
        });
      });
      ss.modal.close();
    }
    return ss;
  }
  init() {
    const ss = this;
    ss.attachEvents();
    ss.setValueText();
  }
  destroy() {
    const ss = this;
    ss.emit("local::beforeDestroy smartSelectBeforeDestroy", ss);
    ss.$el.trigger("smartselect:beforedestroy");
    ss.detachEvents();
    delete ss.$el[0].f7SmartSelect;
    deleteProps(ss);
    ss.destroyed = true;
  }
}
const SmartSelectComponent = {
  name: "smartSelect",
  params: {
    smartSelect: {
      el: void 0,
      valueEl: void 0,
      setValueText: true,
      formatValueText: null,
      openIn: "page",
      // or 'popup' or 'sheet' or 'popover'
      popupPush: false,
      popupSwipeToClose: void 0,
      // defaults to app
      sheetPush: false,
      sheetSwipeToClose: void 0,
      // defaults to app
      sheetBackdrop: false,
      pageTitle: void 0,
      pageBackLinkText: "Back",
      popupCloseLinkText: "Close",
      popupTabletFullscreen: false,
      closeByBackdropClick: true,
      sheetCloseLinkText: "Done",
      searchbar: false,
      searchbarPlaceholder: "Search",
      searchbarDisableText: "Cancel",
      searchbarDisableButton: true,
      searchbarSpellcheck: false,
      closeOnSelect: false,
      virtualList: false,
      virtualListHeight: void 0,
      scrollToSelectedItem: false,
      formColorTheme: void 0,
      navbarColorTheme: void 0,
      routableModals: false,
      url: "select/",
      inputIconPosition: "start",
      cssClass: "",
      /*
        Custom render functions
      */
      renderPage: void 0,
      renderPopup: void 0,
      renderSheet: void 0,
      renderPopover: void 0,
      renderItems: void 0,
      renderItem: void 0,
      renderSearchbar: void 0
    }
  },
  static: {
    SmartSelect
  },
  create() {
    const app2 = this;
    app2.smartSelect = extend$1(ConstructorMethods({
      defaultSelector: ".smart-select",
      constructor: SmartSelect,
      app: app2,
      domProp: "f7SmartSelect"
    }), {
      open(smartSelectEl) {
        const ss = app2.smartSelect.get(smartSelectEl);
        if (ss && ss.open) return ss.open();
        return void 0;
      },
      close(smartSelectEl) {
        const ss = app2.smartSelect.get(smartSelectEl);
        if (ss && ss.close) return ss.close();
        return void 0;
      }
    });
  },
  on: {
    tabMounted(tabEl) {
      const app2 = this;
      $(tabEl).find(".smart-select-init").each((smartSelectEl) => {
        app2.smartSelect.create(extend$1({
          el: smartSelectEl
        }, $(smartSelectEl).dataset()));
      });
    },
    tabBeforeRemove(tabEl) {
      $(tabEl).find(".smart-select-init").each((smartSelectEl) => {
        if (smartSelectEl.f7SmartSelect && smartSelectEl.f7SmartSelect.destroy) {
          smartSelectEl.f7SmartSelect.destroy();
        }
      });
    },
    pageInit(page) {
      const app2 = this;
      page.$el.find(".smart-select-init").each((smartSelectEl) => {
        app2.smartSelect.create(extend$1({
          el: smartSelectEl
        }, $(smartSelectEl).dataset()));
      });
    },
    pageBeforeRemove(page) {
      page.$el.find(".smart-select-init").each((smartSelectEl) => {
        if (smartSelectEl.f7SmartSelect && smartSelectEl.f7SmartSelect.destroy) {
          smartSelectEl.f7SmartSelect.destroy();
        }
      });
    }
  },
  clicks: {
    ".smart-select": function open2($clickedEl, data2) {
      const app2 = this;
      if (!$clickedEl[0].f7SmartSelect) {
        const ss = app2.smartSelect.create(extend$1({
          el: $clickedEl
        }, data2));
        ss.open();
      }
    }
  },
  vnode: {
    "smart-select-init": {
      insert(vnode2) {
        const app2 = this;
        const smartSelectEl = vnode2.elm;
        app2.smartSelect.create(extend$1({
          el: smartSelectEl
        }, $(smartSelectEl).dataset()));
      },
      destroy(vnode2) {
        const smartSelectEl = vnode2.elm;
        if (smartSelectEl.f7SmartSelect && smartSelectEl.f7SmartSelect.destroy) {
          smartSelectEl.f7SmartSelect.destroy();
        }
      }
    }
  }
};
function noUndefinedProps(obj) {
  const o = {};
  Object.keys(obj).forEach((key) => {
    if (typeof obj[key] !== "undefined") o[key] = obj[key];
  });
  return o;
}
function isStringProp(val2) {
  return typeof val2 === "string" && val2 !== "";
}
function isObject(o) {
  return typeof o === "object" && o !== null && o.constructor && o.constructor === Object;
}
function now() {
  return Date.now();
}
function extend() {
  let deep = true;
  let to;
  let from;
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  if (typeof args[0] === "boolean") {
    [deep, to] = args;
    args.splice(0, 2);
    from = args;
  } else {
    [to] = args;
    args.splice(0, 1);
    from = args;
  }
  for (let i = 0; i < from.length; i += 1) {
    const nextSource = args[i];
    if (nextSource !== void 0 && nextSource !== null) {
      const keysArray = Object.keys(Object(nextSource));
      for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
        const nextKey = keysArray[nextIndex];
        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
        if (desc !== void 0 && desc.enumerable) {
          if (!deep) {
            to[nextKey] = nextSource[nextKey];
          } else if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
            extend(to[nextKey], nextSource[nextKey]);
          } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
            to[nextKey] = {};
            extend(to[nextKey], nextSource[nextKey]);
          } else {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
  }
  return to;
}
function classNames() {
  const classes = [];
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }
  args.forEach((arg) => {
    if (typeof arg === "object" && arg.constructor === Object) {
      Object.keys(arg).forEach((key) => {
        if (arg[key]) classes.push(key);
      });
    } else if (arg) classes.push(arg);
  });
  const uniqueClasses = [];
  classes.forEach((c) => {
    if (uniqueClasses.indexOf(c) < 0) uniqueClasses.push(c);
  });
  return uniqueClasses.join(" ");
}
function createEmitter(createEventDispatcher2, props) {
  const dispatch = createEventDispatcher2();
  const emit = (events, argsArray) => {
    if (!events || !events.trim().length || typeof events !== "string") return;
    events.trim().split(" ").forEach((event) => {
      const eventName = (event || "").trim();
      if (!eventName) return;
      const propName = `on${eventName.charAt(0).toUpperCase() + eventName.slice(1)}`;
      dispatch(eventName, argsArray);
      if (typeof props[propName] === "function") {
        if (!Array.isArray(argsArray)) props[propName](...[argsArray]);
        else props[propName](...argsArray || []);
      }
    });
  };
  return emit;
}
let routerIdCounter = 0;
let routerComponentIdCounter = 0;
function unsetRouterIds() {
  routerIdCounter = 0;
  routerComponentIdCounter = 0;
}
function getRouterId() {
  routerIdCounter += 1;
  return `${now()}_${routerIdCounter}`;
}
function getComponentId() {
  routerComponentIdCounter += 1;
  return `${now()}_${routerComponentIdCounter}`;
}
function plainText(text2) {
  if (typeof text2 === "undefined" || text2 === null) return "";
  return text2;
}
let f7;
const app = typeof window !== "undefined" && window.Framework7ComponentsApp ? window.Framework7ComponentsApp : {
  Framework7: void 0,
  f7: void 0,
  f7events: void 0,
  theme: {},
  f7routers: {
    views: [],
    tabs: [],
    modals: null
  }
};
if (typeof window !== "undefined") {
  window.Framework7ComponentsApp = app;
}
app.setInstance = (instance2) => {
  f7 = instance2;
};
const setTheme = () => {
  if (!app.f7) return;
  app.theme.ios = app.f7.theme === "ios";
  app.f7.theme === "ios";
  app.theme.md = app.f7.theme === "md";
  app.f7.theme === "md";
};
const cleanup = () => {
  unsetRouterIds();
  delete app.theme.ios;
  delete app.theme.md;
  app.f7routers.views = [];
  app.f7routers.tabs = [];
  app.f7routers.modals = null;
};
const f7initEvents = () => {
  app.f7events = new app.Framework7.Events();
};
const f7init = function(rootEl, params, init2) {
  if (params === void 0) {
    params = {};
  }
  if (init2 === void 0) {
    init2 = true;
  }
  const f7Params = extend({}, params, {
    el: rootEl,
    init: init2
  });
  if (typeof params.store !== "undefined") f7Params.store = params.store;
  if (!f7Params.routes) f7Params.routes = [];
  if (f7Params.userAgent && (f7Params.theme === "auto" || !f7Params.theme)) {
    const device = app.Framework7.getDevice({
      userAgent: f7Params.userAgent
    }, true);
    app.theme.ios = !!device.ios;
    app.theme.md = !app.theme.ios;
  }
  if (app.f7 && typeof window !== "undefined") return;
  if (typeof window === "undefined") cleanup();
  const instance2 = new app.Framework7(f7Params);
  app.f7 = instance2;
  f7 = instance2;
  app.setInstance(instance2);
  setTheme();
  if (instance2.initialized) {
    app.f7 = instance2;
    f7 = instance2;
    app.setInstance(instance2);
    app.f7events.emit("ready", app.f7);
  } else {
    instance2.on("init", () => {
      app.f7 = instance2;
      f7 = instance2;
      app.setInstance(instance2);
      app.f7events.emit("ready", app.f7);
    });
  }
};
const f7ready = (callback) => {
  if (!callback) return;
  if (app.f7 && app.f7.initialized) callback(app.f7);
  else {
    app.f7events.once("ready", callback);
  }
};
function noop$1() {
}
function assign(tar, src) {
  for (const k in src) tar[k] = src[k];
  return (
    /** @type {T & S} */
    tar
  );
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
let src_url_equal_anchor;
function src_url_equal(element_src, url) {
  if (element_src === url) return true;
  if (!src_url_equal_anchor) {
    src_url_equal_anchor = document.createElement("a");
  }
  src_url_equal_anchor.href = url;
  return element_src === src_url_equal_anchor.href;
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    for (const callback of callbacks) {
      callback(void 0);
    }
    return noop$1;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
function exclude_internal_props(props) {
  const result = {};
  for (const k in props) if (k[0] !== "$") result[k] = props[k];
  return result;
}
function compute_rest_props(props, keys) {
  const rest = {};
  keys = new Set(keys);
  for (const k in props) if (!keys.has(k) && k[0] !== "$") rest[k] = props[k];
  return rest;
}
function compute_slots(slots) {
  const result = {};
  for (const key in slots) {
    result[key] = true;
  }
  return result;
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop$1;
}
const contenteditable_truthy_values = ["", true, 1, "true", "contenteditable"];
function append(target, node) {
  target.appendChild(node);
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i]) iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text(data2) {
  return document.createTextNode(data2);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value2) {
  if (value2 == null) node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value2) node.setAttribute(attribute, value2);
}
const always_set_through_set_attribute = ["width", "height"];
function set_attributes(node, attributes) {
  const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
  for (const key in attributes) {
    if (attributes[key] == null) {
      node.removeAttribute(key);
    } else if (key === "style") {
      node.style.cssText = attributes[key];
    } else if (key === "__value") {
      node.value = node[key] = attributes[key];
    } else if (descriptors[key] && descriptors[key].set && always_set_through_set_attribute.indexOf(key) === -1) {
      node[key] = attributes[key];
    } else {
      attr(node, key, attributes[key]);
    }
  }
}
function set_svg_attributes(node, attributes) {
  for (const key in attributes) {
    attr(node, key, attributes[key]);
  }
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data2) {
  data2 = "" + data2;
  if (text2.data === data2) return;
  text2.data = /** @type {string} */
  data2;
}
function set_data_contenteditable(text2, data2) {
  data2 = "" + data2;
  if (text2.wholeText === data2) return;
  text2.data = /** @type {string} */
  data2;
}
function set_data_maybe_contenteditable(text2, data2, attr_value) {
  if (~contenteditable_truthy_values.indexOf(attr_value)) {
    set_data_contenteditable(text2, data2);
  } else {
    set_data(text2, data2);
  }
}
function set_input_value(input, value2) {
  input.value = value2 == null ? "" : value2;
}
function select_option(select, value2, mounting) {
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];
    if (option.__value === value2) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value2 !== void 0) {
    select.selectedIndex = -1;
  }
}
function select_value(select) {
  const selected_option = select.querySelector(":checked");
  return selected_option && selected_option.__value;
}
function toggle_class(element2, name, toggle) {
  element2.classList.toggle(name, !!toggle);
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  return new CustomEvent(type, { detail, bubbles, cancelable });
}
function construct_svelte_component(component, props) {
  return new component(props);
}
let current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component) throw new Error("Function called outside component initialization");
  return current_component;
}
function beforeUpdate(fn) {
  get_current_component().$$.before_update.push(fn);
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function afterUpdate(fn) {
  get_current_component().$$.after_update.push(fn);
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(
        /** @type {string} */
        type,
        detail,
        { cancelable }
      );
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}
function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
  return context;
}
function getContext(key) {
  return get_current_component().$$.context.get(key);
}
const dirty_components = [];
const binding_callbacks = [];
let render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = /* @__PURE__ */ Promise.resolve();
let update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function tick() {
  schedule_update();
  return resolved_promise;
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
const seen_callbacks = /* @__PURE__ */ new Set();
let flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length) binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}
const outroing = /* @__PURE__ */ new Set();
let outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block)) return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2) block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
function ensure_array_like(array_like_or_iterator) {
  return (array_like_or_iterator == null ? void 0 : array_like_or_iterator.length) !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}
function outro_and_destroy_block(block, lookup) {
  transition_out(block, 1, 1, () => {
    lookup.delete(block.key);
  });
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block2, next2, get_context) {
  let o = old_blocks.length;
  let n2 = list.length;
  let i = o;
  const old_indexes = {};
  while (i--) old_indexes[old_blocks[i].key] = i;
  const new_blocks = [];
  const new_lookup = /* @__PURE__ */ new Map();
  const deltas = /* @__PURE__ */ new Map();
  const updates = [];
  i = n2;
  while (i--) {
    const child_ctx = get_context(ctx, list, i);
    const key = get_key(child_ctx);
    let block = lookup.get(key);
    if (!block) {
      block = create_each_block2(key, child_ctx);
      block.c();
    } else {
      updates.push(() => block.p(child_ctx, dirty));
    }
    new_lookup.set(key, new_blocks[i] = block);
    if (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));
  }
  const will_move = /* @__PURE__ */ new Set();
  const did_move = /* @__PURE__ */ new Set();
  function insert2(block) {
    transition_in(block, 1);
    block.m(node, next2);
    lookup.set(block.key, block);
    next2 = block.first;
    n2--;
  }
  while (o && n2) {
    const new_block = new_blocks[n2 - 1];
    const old_block = old_blocks[o - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;
    if (new_block === old_block) {
      next2 = new_block.first;
      o--;
      n2--;
    } else if (!new_lookup.has(old_key)) {
      destroy(old_block, lookup);
      o--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert2(new_block);
    } else if (did_move.has(old_key)) {
      o--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert2(new_block);
    } else {
      will_move.add(old_key);
      o--;
    }
  }
  while (o--) {
    const old_block = old_blocks[o];
    if (!new_lookup.has(old_block.key)) destroy(old_block, lookup);
  }
  while (n2) insert2(new_blocks[n2 - 1]);
  run_all(updates);
  return new_blocks;
}
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i = levels.length;
  while (i--) {
    const o = levels[i];
    const n2 = updates[i];
    if (n2) {
      for (const key in o) {
        if (!(key in n2)) to_null_out[key] = 1;
      }
      for (const key in n2) {
        if (!accounted_for[key]) {
          update2[key] = n2[key];
          accounted_for[key] = 1;
        }
      }
      levels[i] = n2;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2)) update2[key] = void 0;
  }
  return update2;
}
function get_spread_object(spread_props) {
  return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance2, create_fragment2, not_equal, props, append_styles = null, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop$1,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles && append_styles($$.root);
  let ready = false;
  $$.ctx = instance2 ? instance2(component, options.props || {}, (i, ret, ...rest) => {
    const value2 = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value2)) {
      if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value2);
      if (ready) make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment2 ? create_fragment2($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro) transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    flush();
  }
  set_current_component(parent_component);
}
class SvelteComponent {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop$1;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop$1;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index2 = callbacks.indexOf(callback);
      if (index2 !== -1) callbacks.splice(index2, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
}
const PUBLIC_VERSION = "4";
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);
function colorClasses(props) {
  const {
    color,
    textColor,
    bgColor,
    borderColor,
    rippleColor,
    dark
  } = props;
  return {
    dark,
    [`color-${color}`]: color,
    [`text-color-${textColor}`]: textColor,
    [`bg-color-${bgColor}`]: bgColor,
    [`border-color-${borderColor}`]: borderColor,
    [`ripple-color-${rippleColor}`]: rippleColor
  };
}
function routerAttrs(props) {
  const {
    force,
    reloadCurrent,
    reloadPrevious,
    reloadAll,
    reloadDetail,
    animate: animate2,
    ignoreCache,
    routeTabId,
    view,
    transition: transition2,
    openIn
  } = props;
  let dataAnimate;
  if ("animate" in props && typeof animate2 !== "undefined") {
    dataAnimate = animate2.toString();
  }
  let dataReloadDetail;
  if ("reloadDetail" in props && typeof reloadDetail !== "undefined") {
    dataReloadDetail = reloadDetail.toString();
  }
  return {
    "data-force": force || void 0,
    "data-reload-current": reloadCurrent || void 0,
    "data-reload-all": reloadAll || void 0,
    "data-reload-previous": reloadPrevious || void 0,
    "data-reload-detail": dataReloadDetail,
    "data-animate": dataAnimate,
    "data-ignore-cache": ignoreCache || void 0,
    "data-route-tab-id": routeTabId || void 0,
    "data-view": isStringProp(view) ? view : void 0,
    "data-transition": isStringProp(transition2) ? transition2 : void 0,
    "data-open-in": isStringProp(openIn) ? openIn : void 0
  };
}
function routerClasses(props) {
  const {
    back: back2,
    linkBack,
    external,
    preventRouter
  } = props;
  return {
    back: back2 || linkBack,
    external,
    "prevent-router": preventRouter
  };
}
function actionsAttrs(props) {
  const {
    searchbarEnable,
    searchbarDisable,
    searchbarClear,
    searchbarToggle,
    panelOpen,
    panelClose,
    panelToggle,
    popupOpen,
    popupClose,
    actionsOpen,
    actionsClose,
    popoverOpen,
    popoverClose,
    loginScreenOpen,
    loginScreenClose,
    sheetOpen,
    sheetClose,
    sortableEnable,
    sortableDisable,
    sortableToggle,
    cardOpen,
    cardClose
  } = props;
  return {
    "data-searchbar": isStringProp(searchbarEnable) && searchbarEnable || isStringProp(searchbarDisable) && searchbarDisable || isStringProp(searchbarClear) && searchbarClear || isStringProp(searchbarToggle) && searchbarToggle || void 0,
    "data-panel": isStringProp(panelOpen) && panelOpen || isStringProp(panelClose) && panelClose || isStringProp(panelToggle) && panelToggle || void 0,
    "data-popup": isStringProp(popupOpen) && popupOpen || isStringProp(popupClose) && popupClose || void 0,
    "data-actions": isStringProp(actionsOpen) && actionsOpen || isStringProp(actionsClose) && actionsClose || void 0,
    "data-popover": isStringProp(popoverOpen) && popoverOpen || isStringProp(popoverClose) && popoverClose || void 0,
    "data-sheet": isStringProp(sheetOpen) && sheetOpen || isStringProp(sheetClose) && sheetClose || void 0,
    "data-login-screen": isStringProp(loginScreenOpen) && loginScreenOpen || isStringProp(loginScreenClose) && loginScreenClose || void 0,
    "data-sortable": isStringProp(sortableEnable) && sortableEnable || isStringProp(sortableDisable) && sortableDisable || isStringProp(sortableToggle) && sortableToggle || void 0,
    "data-card": isStringProp(cardOpen) && cardOpen || isStringProp(cardClose) && cardClose || void 0
  };
}
function actionsClasses(props) {
  const {
    searchbarEnable,
    searchbarDisable,
    searchbarClear,
    searchbarToggle,
    panelOpen,
    panelClose,
    panelToggle,
    popupOpen,
    popupClose,
    actionsClose,
    actionsOpen,
    popoverOpen,
    popoverClose,
    loginScreenOpen,
    loginScreenClose,
    sheetOpen,
    sheetClose,
    sortableEnable,
    sortableDisable,
    sortableToggle,
    cardOpen,
    cardPreventOpen,
    cardClose
  } = props;
  return {
    "searchbar-enable": searchbarEnable || searchbarEnable === "",
    "searchbar-disable": searchbarDisable || searchbarDisable === "",
    "searchbar-clear": searchbarClear || searchbarClear === "",
    "searchbar-toggle": searchbarToggle || searchbarToggle === "",
    "panel-close": panelClose || panelClose === "",
    "panel-open": panelOpen || panelOpen === "",
    "panel-toggle": panelToggle || panelToggle === "",
    "popup-close": popupClose || popupClose === "",
    "popup-open": popupOpen || popupOpen === "",
    "actions-close": actionsClose || actionsClose === "",
    "actions-open": actionsOpen || actionsOpen === "",
    "popover-close": popoverClose || popoverClose === "",
    "popover-open": popoverOpen || popoverOpen === "",
    "sheet-close": sheetClose || sheetClose === "",
    "sheet-open": sheetOpen || sheetOpen === "",
    "login-screen-close": loginScreenClose || loginScreenClose === "",
    "login-screen-open": loginScreenOpen || loginScreenOpen === "",
    "sortable-enable": sortableEnable || sortableEnable === "",
    "sortable-disable": sortableDisable || sortableDisable === "",
    "sortable-toggle": sortableToggle || sortableToggle === "",
    "card-close": cardClose || cardClose === "",
    "card-open": cardOpen || cardOpen === "",
    "card-prevent-open": cardPreventOpen || cardPreventOpen === ""
  };
}
const ignoreProps = ["color", "colorTheme", "textColor", "bgColor", "borderColor", "rippleColor", "dark", "force", "reloadCurrent", "reloadPrevious", "reloadAll", "reloadDetail", "animate", "ignoreCache", "routeTabId", "view", "transition", "openIn", "back", "linkBack", "external", "preventRouter", "searchbarEnable", "searchbarDisable", "searchbarClear", "searchbarToggle", "panelOpen", "panelClose", "panelToggle", "popupOpen", "popupClose", "actionsOpen", "actionsClose", "popoverOpen", "popoverClose", "loginScreenOpen", "loginScreenClose", "sheetOpen", "sheetClose", "sortableEnable", "sortableDisable", "sortableToggle", "cardOpen", "cardClose"];
function restProps(rest) {
  if (rest === void 0) {
    rest = {};
  }
  const props = {};
  Object.keys(rest).filter((prop2) => !ignoreProps.includes(prop2)).forEach((key) => {
    if (key.indexOf("on") !== 0) {
      props[key] = rest[key];
    }
  });
  return props;
}
const modalStateClasses = function(_temp) {
  let {
    isOpened,
    isClosing
  } = _temp === void 0 ? {} : _temp;
  return {
    "modal-in": isOpened && !isClosing,
    "modal-out": isClosing
  };
};
const get_default_slot_changes$5 = (dirty) => ({ popup: dirty[0] & /*f7Popup*/
4 });
const get_default_slot_context$5 = (ctx) => ({ popup: (
  /*f7Popup*/
  ctx[2]
) });
function create_fragment$y(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[19].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    get_default_slot_context$5
  );
  let div_levels = [
    { class: (
      /*classes*/
      ctx[3]
    ) },
    { style: (
      /*style*/
      ctx[0]
    ) },
    restProps(
      /*$$restProps*/
      ctx[4]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  return {
    c() {
      div = element("div");
      if (default_slot) default_slot.c();
      set_attributes(div, div_data);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[20](div);
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope, f7Popup*/
        262148)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              get_default_slot_changes$5
            ),
            get_default_slot_context$5
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty[0] & /*classes*/
        8) && { class: (
          /*classes*/
          ctx2[3]
        ) },
        (!current || dirty[0] & /*style*/
        1) && { style: (
          /*style*/
          ctx2[0]
        ) },
        dirty[0] & /*$$restProps*/
        16 && restProps(
          /*$$restProps*/
          ctx2[4]
        )
      ]));
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (default_slot) default_slot.d(detaching);
      ctx[20](null);
    }
  };
}
function instance_1$5($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = [
    "class",
    "style",
    "tabletFullscreen",
    "opened",
    "animate",
    "backdrop",
    "backdropEl",
    "closeByBackdropClick",
    "closeOnEscape",
    "swipeToClose",
    "swipeHandler",
    "push",
    "containerEl",
    "instance"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { style = "" } = $$props;
  let { tabletFullscreen = void 0 } = $$props;
  let { opened = void 0 } = $$props;
  let { animate: animate2 = void 0 } = $$props;
  let { backdrop = void 0 } = $$props;
  let { backdropEl = void 0 } = $$props;
  let { closeByBackdropClick = void 0 } = $$props;
  let { closeOnEscape = void 0 } = $$props;
  let { swipeToClose = false } = $$props;
  let { swipeHandler = void 0 } = $$props;
  let { push = void 0 } = $$props;
  let { containerEl = void 0 } = $$props;
  let el;
  let f7Popup;
  const state = { isOpened: opened, isClosing: false };
  function instance2() {
    return f7Popup;
  }
  function onSwipeStart(instance3) {
    emit("popupSwipeStart", [instance3]);
  }
  function onSwipeMove(instance3) {
    emit("popupSwipeMove", [instance3]);
  }
  function onSwipeEnd(instance3) {
    emit("popupSwipeEnd", [instance3]);
  }
  function onSwipeClose(instance3) {
    emit("popupSwipeClose", [instance3]);
  }
  function onOpen2(instance3) {
    Object.assign(state, { isOpened: true, isClosing: false });
    emit("popupOpen", [instance3]);
    $$invalidate(5, opened = true);
  }
  function onOpened(instance3) {
    emit("popupOpened", [instance3]);
  }
  function onClose2(instance3) {
    Object.assign(state, { isOpened: false, isClosing: true });
    emit("popupClose", [instance3]);
  }
  function onClosed(instance3) {
    Object.assign(state, { isClosing: false });
    emit("popupClosed", [instance3]);
    $$invalidate(5, opened = false);
  }
  let initialWatched = false;
  function watchOpened(openedPassed) {
    if (!initialWatched) {
      initialWatched = true;
      return;
    }
    if (!f7Popup) return;
    if (openedPassed) f7Popup.open();
    else f7Popup.close();
  }
  onMount(() => {
    const popupParams = {
      el,
      on: {
        swipeStart: onSwipeStart,
        swipeMove: onSwipeMove,
        swipeEnd: onSwipeEnd,
        swipeClose: onSwipeClose,
        open: onOpen2,
        opened: onOpened,
        close: onClose2,
        closed: onClosed
      }
    };
    if (typeof closeByBackdropClick !== "undefined") popupParams.closeByBackdropClick = closeByBackdropClick;
    if (typeof closeOnEscape !== "undefined") popupParams.closeOnEscape = closeOnEscape;
    if (typeof animate2 !== "undefined") popupParams.animate = animate2;
    if (typeof backdrop !== "undefined") popupParams.backdrop = backdrop;
    if (typeof backdropEl !== "undefined") popupParams.backdropEl = backdropEl;
    if (typeof swipeToClose !== "undefined") popupParams.swipeToClose = swipeToClose;
    if (typeof swipeHandler !== "undefined") popupParams.swipeHandler = swipeHandler;
    if (typeof containerEl !== "undefined") popupParams.containerEl = containerEl;
    f7ready(() => {
      $$invalidate(2, f7Popup = app.f7.popup.create(popupParams));
      if (opened) {
        f7Popup.open(false, true);
      }
    });
  });
  onDestroy(() => {
    if (f7Popup) f7Popup.destroy();
    $$invalidate(2, f7Popup = null);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(1, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(33, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props) $$invalidate(6, className = $$new_props.class);
    if ("style" in $$new_props) $$invalidate(0, style = $$new_props.style);
    if ("tabletFullscreen" in $$new_props) $$invalidate(7, tabletFullscreen = $$new_props.tabletFullscreen);
    if ("opened" in $$new_props) $$invalidate(5, opened = $$new_props.opened);
    if ("animate" in $$new_props) $$invalidate(8, animate2 = $$new_props.animate);
    if ("backdrop" in $$new_props) $$invalidate(9, backdrop = $$new_props.backdrop);
    if ("backdropEl" in $$new_props) $$invalidate(10, backdropEl = $$new_props.backdropEl);
    if ("closeByBackdropClick" in $$new_props) $$invalidate(11, closeByBackdropClick = $$new_props.closeByBackdropClick);
    if ("closeOnEscape" in $$new_props) $$invalidate(12, closeOnEscape = $$new_props.closeOnEscape);
    if ("swipeToClose" in $$new_props) $$invalidate(13, swipeToClose = $$new_props.swipeToClose);
    if ("swipeHandler" in $$new_props) $$invalidate(14, swipeHandler = $$new_props.swipeHandler);
    if ("push" in $$new_props) $$invalidate(15, push = $$new_props.push);
    if ("containerEl" in $$new_props) $$invalidate(16, containerEl = $$new_props.containerEl);
    if ("$$scope" in $$new_props) $$invalidate(18, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(3, classes = classNames(
      className,
      "popup",
      {
        "popup-tablet-fullscreen": tabletFullscreen,
        "popup-push": push
      },
      modalStateClasses(state),
      colorClasses($$props)
    ));
    if ($$self.$$.dirty[0] & /*opened*/
    32) {
      watchOpened(opened);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    style,
    el,
    f7Popup,
    classes,
    $$restProps,
    opened,
    className,
    tabletFullscreen,
    animate2,
    backdrop,
    backdropEl,
    closeByBackdropClick,
    closeOnEscape,
    swipeToClose,
    swipeHandler,
    push,
    containerEl,
    instance2,
    $$scope,
    slots,
    div_binding
  ];
}
class Popup2 extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance_1$5,
      create_fragment$y,
      safe_not_equal,
      {
        class: 6,
        style: 0,
        tabletFullscreen: 7,
        opened: 5,
        animate: 8,
        backdrop: 9,
        backdropEl: 10,
        closeByBackdropClick: 11,
        closeOnEscape: 12,
        swipeToClose: 13,
        swipeHandler: 14,
        push: 15,
        containerEl: 16,
        instance: 17
      },
      null,
      [-1, -1]
    );
  }
  get instance() {
    return this.$$.ctx[17];
  }
}
const getRouterInitialComponent = (router, initialComponent) => {
  let initialComponentData;
  const {
    initialUrl
  } = router.getInitialUrl();
  const initialRoute = router.findMatchingRoute(initialUrl);
  let routeProps = {};
  if (initialRoute && initialRoute.route && initialRoute.route.options) {
    routeProps = initialRoute.route.options.props;
  }
  const isMasterRoute = (route) => {
    if (route.master === true) return true;
    if (typeof route.master === "function") return route.master(router.app);
    return false;
  };
  if (initialRoute && initialRoute.route && (initialRoute.route.component || initialRoute.route.asyncComponent) && !isMasterRoute(initialRoute.route)) {
    initialComponentData = {
      component: initialRoute.route.component || initialRoute.route.asyncComponent,
      initialComponent,
      id: getComponentId(),
      isAsync: !!initialRoute.route.asyncComponent,
      props: {
        f7route: initialRoute,
        f7router: router,
        ...initialRoute.params,
        ...routeProps
      }
    };
  }
  return {
    initialPage: initialComponentData,
    initialRoute
  };
};
const useTab = (getEl, emit) => {
  const onTabShow = (el) => {
    if (getEl() !== el) return;
    emit("tabShow", [el]);
  };
  const onTabHide = (el) => {
    if (getEl() !== el) return;
    emit("tabHide", [el]);
  };
  const attachEvents = () => {
    if (!getEl()) return;
    f7ready(() => {
      f7.on("tabShow", onTabShow);
      f7.on("tabHide", onTabHide);
    });
  };
  const detachEvents = () => {
    if (!f7) return;
    f7.off("tabShow", onTabShow);
    f7.off("tabHide", onTabHide);
  };
  onMount(() => {
    attachEvents();
  });
  onDestroy(() => {
    detachEvents();
  });
};
function create_fragment$x(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  return {
    c() {
      if (default_slot) default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function instance$t($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { route = void 0 } = $$props;
  let { router = void 0 } = $$props;
  setContext("RouterContext", { route, router });
  $$self.$$set = ($$props2) => {
    if ("route" in $$props2) $$invalidate(0, route = $$props2.route);
    if ("router" in $$props2) $$invalidate(1, router = $$props2.router);
    if ("$$scope" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [route, router, $$scope, slots];
}
class Router_context_provider extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$t, create_fragment$x, safe_not_equal, { route: 0, router: 1 });
  }
}
function get_each_context$4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[31] = list[i];
  return child_ctx;
}
const get_default_slot_changes$4 = (dirty) => ({ view: dirty[0] & /*f7View*/
8 });
const get_default_slot_context$4 = (ctx) => ({ view: (
  /*f7View*/
  ctx[3]
) });
function create_default_slot$c(ctx) {
  let switch_instance;
  let t2;
  let current;
  const switch_instance_spread_levels = [
    /*page*/
    ctx[31].props
  ];
  var switch_value = (
    /*page*/
    ctx[31].component
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    if (dirty !== void 0 && dirty[0] & /*pages*/
    16) {
      switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*page*/
        ctx2[31].props
      )]));
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      t2 = space();
    },
    m(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert(target, t2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*pages*/
      16 && switch_value !== (switch_value = /*page*/
      ctx2[31].component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, t2.parentNode, t2);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty[0] & /*pages*/
        16 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*page*/
          ctx2[31].props
        )]) : {};
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
}
function create_each_block$4(key_1, ctx) {
  let first;
  let routercontextprovider;
  let current;
  routercontextprovider = new Router_context_provider({
    props: {
      route: (
        /*page*/
        ctx[31].props.f7route
      ),
      router: (
        /*page*/
        ctx[31].props.f7router
      ),
      $$slots: { default: [create_default_slot$c] },
      $$scope: { ctx }
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(routercontextprovider.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(routercontextprovider, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const routercontextprovider_changes = {};
      if (dirty[0] & /*pages*/
      16) routercontextprovider_changes.route = /*page*/
      ctx[31].props.f7route;
      if (dirty[0] & /*pages*/
      16) routercontextprovider_changes.router = /*page*/
      ctx[31].props.f7router;
      if (dirty[0] & /*$$scope, pages*/
      4112) {
        routercontextprovider_changes.$$scope = { dirty, ctx };
      }
      routercontextprovider.$set(routercontextprovider_changes);
    },
    i(local) {
      if (current) return;
      transition_in(routercontextprovider.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(routercontextprovider.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(routercontextprovider, detaching);
    }
  };
}
function create_fragment$w(ctx) {
  let div;
  let t2;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    get_default_slot_context$4
  );
  let each_value = ensure_array_like(
    /*pages*/
    ctx[4]
  );
  const get_key = (ctx2) => (
    /*page*/
    ctx2[31].id
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$4(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$4(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      if (default_slot) default_slot.c();
      t2 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(
        div,
        "class",
        /*classes*/
        ctx[5]
      );
      attr(
        div,
        "style",
        /*style*/
        ctx[1]
      );
      attr(
        div,
        "id",
        /*id*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append(div, t2);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      ctx[11](div);
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope, f7View*/
        4104)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              get_default_slot_changes$4
            ),
            get_default_slot_context$4
          );
        }
      }
      if (dirty[0] & /*pages*/
      16) {
        each_value = ensure_array_like(
          /*pages*/
          ctx2[4]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$4, null, get_each_context$4);
        check_outros();
      }
      if (!current || dirty[0] & /*classes*/
      32) {
        attr(
          div,
          "class",
          /*classes*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*style*/
      2) {
        attr(
          div,
          "style",
          /*style*/
          ctx2[1]
        );
      }
      if (!current || dirty[0] & /*id*/
      1) {
        attr(
          div,
          "id",
          /*id*/
          ctx2[0]
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (default_slot) default_slot.d(detaching);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      ctx[11](null);
    }
  };
}
function instance_1$4($$self, $$props, $$invalidate) {
  let classes;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { id: id2 = void 0 } = $$props;
  let { style = void 0 } = $$props;
  let { init: init2 = true } = $$props;
  let { url = void 0 } = $$props;
  let { class: className = void 0 } = $$props;
  const emit = createEmitter(createEventDispatcher, $$props);
  const { main, tab, tabActive, browserHistoryInitialMatch = true, initRouterOnTabShow } = $$props;
  const shouldInitRouter = !(initRouterOnTabShow && tab && !tabActive);
  let initialPage;
  let initialRoute;
  let el;
  let routerData;
  let f7View;
  function instance2() {
    return f7View;
  }
  function onViewInit(view) {
    emit("viewInit", [view]);
    if (!init2) {
      $$invalidate(3, f7View = view);
      routerData.instance = view;
    }
  }
  if (app.f7 && !f7View && init2) {
    const routerId = getRouterId();
    f7View = app.f7.views.create(el, {
      routerId,
      init: false,
      ...noUndefinedProps($$props),
      browserHistoryInitialMatch,
      on: { init: onViewInit }
    });
    routerData = { routerId, instance: f7View };
    app.f7routers.views.push(routerData);
    if (shouldInitRouter && f7View && f7View.router && (url || main)) {
      const initialData = getRouterInitialComponent(f7View.router);
      initialPage = initialData.initialPage;
      initialRoute = initialData.initialRoute;
      if (initialRoute && initialRoute.route && initialRoute.route.masterRoute) {
        initialPage = void 0;
        initialRoute = void 0;
      }
    }
  }
  let pages = initialPage ? [initialPage] : [];
  function onResize(view, width2) {
    emit("viewResize", [width2]);
  }
  function onSwipeBackMove(data2) {
    emit("swipeBackMove", [data2]);
  }
  function onSwipeBackBeforeChange(data2) {
    emit("swipeBackBeforeChange", [data2]);
  }
  function onSwipeBackAfterChange(data2) {
    emit("swipeBackAfterChange", [data2]);
  }
  function onSwipeBackBeforeReset(data2) {
    emit("swipeBackBeforeReset", [data2]);
  }
  function onSwipeBackAfterReset(data2) {
    emit("swipeBackAfterReset", [data2]);
  }
  useTab(() => el, emit);
  onMount(() => {
    f7ready(() => {
      if (f7View) {
        routerData.el = el;
        routerData.pages = pages;
        routerData.setPages = (newPages) => {
          tick().then(() => {
            $$invalidate(4, pages = newPages);
          });
        };
        if (initialPage && initialPage.isAsync && !initialPage.initialComponent) {
          initialPage.component().then(() => {
            setTimeout(
              () => {
                f7View.init(el);
                if (initialPage) {
                  initialPage.el = f7View.router.currentPageEl;
                  if (initialRoute && initialRoute.route && initialRoute.route.keepAlive) {
                    initialRoute.route.keepAliveData = { pageEl: initialPage.el };
                  }
                }
              },
              100
            );
          });
        } else {
          f7View.init(el);
          if (initialPage) {
            initialPage.el = f7View.router.currentPageEl;
            if (initialRoute && initialRoute.route && initialRoute.route.keepAlive) {
              initialRoute.route.keepAliveData = { pageEl: initialPage.el };
            }
          }
        }
      } else {
        const routerId = getRouterId();
        routerData = {
          el,
          routerId,
          pages,
          instance: f7View,
          setPages(newPages) {
            tick().then(() => {
              $$invalidate(4, pages = newPages);
            });
          }
        };
        app.f7routers.views.push(routerData);
        routerData.instance = app.f7.views.create(el, {
          routerId,
          ...noUndefinedProps($$props),
          browserHistoryInitialMatch,
          on: { init: onViewInit }
        });
        $$invalidate(3, f7View = routerData.instance);
      }
      if (!init2) return;
      f7View.on("resize", onResize);
      f7View.on("swipebackMove", onSwipeBackMove);
      f7View.on("swipebackBeforeChange", onSwipeBackBeforeChange);
      f7View.on("swipebackAfterChange", onSwipeBackAfterChange);
      f7View.on("swipebackBeforeReset", onSwipeBackBeforeReset);
      f7View.on("swipebackAfterReset", onSwipeBackAfterReset);
    });
  });
  afterUpdate(() => {
    if (!routerData) return;
    app.f7events.emit("viewRouterDidUpdate", routerData);
  });
  onDestroy(() => {
    if (f7View) {
      f7View.off("resize", onResize);
      f7View.off("swipebackMove", onSwipeBackMove);
      f7View.off("swipebackBeforeChange", onSwipeBackBeforeChange);
      f7View.off("swipebackAfterChange", onSwipeBackAfterChange);
      f7View.off("swipebackBeforeReset", onSwipeBackBeforeReset);
      f7View.off("swipebackAfterReset", onSwipeBackAfterReset);
      if (f7View.destroy) f7View.destroy();
      $$invalidate(3, f7View = null);
    }
    app.f7routers.views.splice(app.f7routers.views.indexOf(routerData), 1);
    routerData = null;
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(2, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(30, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("id" in $$new_props) $$invalidate(0, id2 = $$new_props.id);
    if ("style" in $$new_props) $$invalidate(1, style = $$new_props.style);
    if ("init" in $$new_props) $$invalidate(6, init2 = $$new_props.init);
    if ("url" in $$new_props) $$invalidate(7, url = $$new_props.url);
    if ("class" in $$new_props) $$invalidate(8, className = $$new_props.class);
    if ("$$scope" in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(5, classes = classNames(
      className,
      "view",
      {
        "view-main": main,
        "tab-active": tabActive,
        tab
      },
      colorClasses($$props)
    ));
  };
  $$props = exclude_internal_props($$props);
  return [
    id2,
    style,
    el,
    f7View,
    pages,
    classes,
    init2,
    url,
    className,
    instance2,
    slots,
    div_binding,
    $$scope
  ];
}
class View2 extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance_1$4,
      create_fragment$w,
      safe_not_equal,
      {
        id: 0,
        style: 1,
        init: 6,
        url: 7,
        class: 8,
        instance: 9
      },
      null,
      [-1, -1]
    );
  }
  get instance() {
    return this.$$.ctx[9];
  }
}
const get_default_slot_changes$3 = (dirty) => ({ loginScreen: dirty & /*f7LoginScreen*/
4 });
const get_default_slot_context$3 = (ctx) => ({ loginScreen: (
  /*f7LoginScreen*/
  ctx[2]
) });
function create_fragment$v(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_default_slot_context$3
  );
  let div_levels = [
    { class: (
      /*classes*/
      ctx[3]
    ) },
    { style: (
      /*style*/
      ctx[0]
    ) },
    restProps(
      /*$$restProps*/
      ctx[4]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  return {
    c() {
      div = element("div");
      if (default_slot) default_slot.c();
      set_attributes(div, div_data);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[12](div);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, f7LoginScreen*/
        1028)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_default_slot_changes$3
            ),
            get_default_slot_context$3
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        8) && { class: (
          /*classes*/
          ctx2[3]
        ) },
        (!current || dirty & /*style*/
        1) && { style: (
          /*style*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        16 && restProps(
          /*$$restProps*/
          ctx2[4]
        )
      ]));
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (default_slot) default_slot.d(detaching);
      ctx[12](null);
    }
  };
}
function instance_1$3($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "style", "opened", "animate", "containerEl", "instance"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { style = "" } = $$props;
  let { opened = void 0 } = $$props;
  let { animate: animate2 = void 0 } = $$props;
  let { containerEl = void 0 } = $$props;
  let el;
  let f7LoginScreen;
  const state = { isOpened: opened, isClosing: false };
  function instance2() {
    return f7LoginScreen;
  }
  function onOpen2(instance3) {
    Object.assign(state, { isOpened: true, isClosing: false });
    emit("loginscreenOpen loginScreenOpen", [instance3]);
    $$invalidate(5, opened = true);
  }
  function onOpened(instance3) {
    emit("loginscreenOpened loginScreenOpened", [instance3]);
  }
  function onClose2(instance3) {
    Object.assign(state, { isOpened: false, isClosing: true });
    emit("loginscreenClose loginScreenClose", [instance3]);
  }
  function onClosed(instance3) {
    Object.assign(state, { isClosing: false });
    emit("loginscreenClosed loginScreenClosed", [instance3]);
    $$invalidate(5, opened = false);
  }
  let initialWatched = false;
  function watchOpened(openedPassed) {
    if (!initialWatched) {
      initialWatched = true;
      return;
    }
    if (!f7LoginScreen) return;
    if (openedPassed) f7LoginScreen.open();
    else f7LoginScreen.close();
  }
  onMount(() => {
    const params = {
      el,
      on: {
        open: onOpen2,
        opened: onOpened,
        close: onClose2,
        closed: onClosed
      }
    };
    if (typeof animate2 !== "undefined") params.animate = animate2;
    if (typeof containerEl !== "undefined") params.containerEl = animate2;
    f7ready(() => {
      $$invalidate(2, f7LoginScreen = app.f7.loginScreen.create(params));
      if (opened) {
        f7LoginScreen.open(false);
      }
    });
  });
  onDestroy(() => {
    if (f7LoginScreen) f7LoginScreen.destroy();
    $$invalidate(2, f7LoginScreen = null);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(1, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(21, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props) $$invalidate(6, className = $$new_props.class);
    if ("style" in $$new_props) $$invalidate(0, style = $$new_props.style);
    if ("opened" in $$new_props) $$invalidate(5, opened = $$new_props.opened);
    if ("animate" in $$new_props) $$invalidate(7, animate2 = $$new_props.animate);
    if ("containerEl" in $$new_props) $$invalidate(8, containerEl = $$new_props.containerEl);
    if ("$$scope" in $$new_props) $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(3, classes = classNames(className, "login-screen", modalStateClasses(state), colorClasses($$props)));
    if ($$self.$$.dirty & /*opened*/
    32) {
      watchOpened(opened);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    style,
    el,
    f7LoginScreen,
    classes,
    $$restProps,
    opened,
    className,
    animate2,
    containerEl,
    instance2,
    $$scope,
    slots,
    div_binding
  ];
}
class Login_screen extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance_1$3, create_fragment$v, safe_not_equal, {
      class: 6,
      style: 0,
      opened: 5,
      animate: 7,
      containerEl: 8,
      instance: 9
    });
  }
  get instance() {
    return this.$$.ctx[9];
  }
}
const get_static_slot_changes$1 = (dirty) => ({ sheet: dirty[0] & /*f7Sheet*/
8 });
const get_static_slot_context$1 = (ctx) => ({ sheet: (
  /*f7Sheet*/
  ctx[3]
) });
const get_default_slot_changes$2 = (dirty) => ({ sheet: dirty[0] & /*f7Sheet*/
8 });
const get_default_slot_context$2 = (ctx) => ({ sheet: (
  /*f7Sheet*/
  ctx[3]
) });
const get_fixed_slot_changes$1 = (dirty) => ({ sheet: dirty[0] & /*f7Sheet*/
8 });
const get_fixed_slot_context$1 = (ctx) => ({ sheet: (
  /*f7Sheet*/
  ctx[3]
) });
function create_fragment$u(ctx) {
  let div1;
  let t0;
  let div0;
  let t1;
  let current;
  const fixed_slot_template = (
    /*#slots*/
    ctx[29].fixed
  );
  const fixed_slot = create_slot(
    fixed_slot_template,
    ctx,
    /*$$scope*/
    ctx[28],
    get_fixed_slot_context$1
  );
  const default_slot_template = (
    /*#slots*/
    ctx[29].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[28],
    get_default_slot_context$2
  );
  const static_slot_template = (
    /*#slots*/
    ctx[29].static
  );
  const static_slot = create_slot(
    static_slot_template,
    ctx,
    /*$$scope*/
    ctx[28],
    get_static_slot_context$1
  );
  let div1_levels = [
    { class: (
      /*classes*/
      ctx[4]
    ) },
    { style: (
      /*style*/
      ctx[0]
    ) },
    restProps(
      /*$$restProps*/
      ctx[5]
    )
  ];
  let div_data_1 = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div_data_1 = assign(div_data_1, div1_levels[i]);
  }
  return {
    c() {
      div1 = element("div");
      if (fixed_slot) fixed_slot.c();
      t0 = space();
      div0 = element("div");
      if (default_slot) default_slot.c();
      t1 = space();
      if (static_slot) static_slot.c();
      attr(div0, "class", "sheet-modal-inner");
      set_attributes(div1, div_data_1);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      if (fixed_slot) {
        fixed_slot.m(div1, null);
      }
      append(div1, t0);
      append(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      append(div0, t1);
      if (static_slot) {
        static_slot.m(div0, null);
      }
      ctx[30](div0);
      ctx[31](div1);
      current = true;
    },
    p(ctx2, dirty) {
      if (fixed_slot) {
        if (fixed_slot.p && (!current || dirty[0] & /*$$scope, f7Sheet*/
        268435464)) {
          update_slot_base(
            fixed_slot,
            fixed_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[28]
            ) : get_slot_changes(
              fixed_slot_template,
              /*$$scope*/
              ctx2[28],
              dirty,
              get_fixed_slot_changes$1
            ),
            get_fixed_slot_context$1
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope, f7Sheet*/
        268435464)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[28]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[28],
              dirty,
              get_default_slot_changes$2
            ),
            get_default_slot_context$2
          );
        }
      }
      if (static_slot) {
        if (static_slot.p && (!current || dirty[0] & /*$$scope, f7Sheet*/
        268435464)) {
          update_slot_base(
            static_slot,
            static_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[28]
            ) : get_slot_changes(
              static_slot_template,
              /*$$scope*/
              ctx2[28],
              dirty,
              get_static_slot_changes$1
            ),
            get_static_slot_context$1
          );
        }
      }
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [
        (!current || dirty[0] & /*classes*/
        16) && { class: (
          /*classes*/
          ctx2[4]
        ) },
        (!current || dirty[0] & /*style*/
        1) && { style: (
          /*style*/
          ctx2[0]
        ) },
        dirty[0] & /*$$restProps*/
        32 && restProps(
          /*$$restProps*/
          ctx2[5]
        )
      ]));
    },
    i(local) {
      if (current) return;
      transition_in(fixed_slot, local);
      transition_in(default_slot, local);
      transition_in(static_slot, local);
      current = true;
    },
    o(local) {
      transition_out(fixed_slot, local);
      transition_out(default_slot, local);
      transition_out(static_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (fixed_slot) fixed_slot.d(detaching);
      if (default_slot) default_slot.d(detaching);
      if (static_slot) static_slot.d(detaching);
      ctx[30](null);
      ctx[31](null);
    }
  };
}
function instance_1$2($$self, $$props, $$invalidate) {
  let positionComputed;
  let classes;
  const omit_props_names = [
    "class",
    "style",
    "opened",
    "animate",
    "top",
    "bottom",
    "position",
    "backdrop",
    "backdropEl",
    "closeByBackdropClick",
    "closeByOutsideClick",
    "closeOnEscape",
    "push",
    "swipeToClose",
    "swipeToStep",
    "swipeHandler",
    "containerEl",
    "breakpoints",
    "backdropBreakpoint",
    "pushBreakpoint",
    "instance"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { style = "" } = $$props;
  let { opened = void 0 } = $$props;
  let { animate: animate2 = void 0 } = $$props;
  let { top = void 0 } = $$props;
  let { bottom = void 0 } = $$props;
  let { position = void 0 } = $$props;
  let { backdrop = void 0 } = $$props;
  let { backdropEl = void 0 } = $$props;
  let { closeByBackdropClick = void 0 } = $$props;
  let { closeByOutsideClick = void 0 } = $$props;
  let { closeOnEscape = void 0 } = $$props;
  let { push = void 0 } = $$props;
  let { swipeToClose = void 0 } = $$props;
  let { swipeToStep = void 0 } = $$props;
  let { swipeHandler = void 0 } = $$props;
  let { containerEl = void 0 } = $$props;
  let { breakpoints = void 0 } = $$props;
  let { backdropBreakpoint = void 0 } = $$props;
  let { pushBreakpoint = void 0 } = $$props;
  let el;
  let innerEl;
  let f7Sheet;
  const state = {
    isOpened: opened,
    isClosing: false,
    swipeStep: false,
    breakpoint: false
  };
  function instance2() {
    return f7Sheet;
  }
  function onOpen2(instance3) {
    Object.assign(state, { isOpened: true, isClosing: false });
    emit("sheetOpen", [instance3]);
    $$invalidate(6, opened = true);
  }
  function onOpened(instance3) {
    emit("sheetOpened", [instance3]);
  }
  function onClose2(instance3) {
    Object.assign(state, { isOpened: false, isClosing: true });
    emit("sheetClose", [instance3]);
  }
  function onClosed(instance3) {
    Object.assign(state, { isClosing: false });
    emit("sheetClosed", [instance3]);
    $$invalidate(6, opened = false);
  }
  function onBreakpoint(instance3, breakpoint) {
    emit("sheetBreakpoint", [instance3, breakpoint]);
  }
  function onStepProgress(instance3, progress) {
    emit("sheetStepProgress", [instance3, progress]);
  }
  function onStepOpen(instance3) {
    emit("sheetStepOpen", [instance3]);
  }
  function onStepClose(instance3) {
    emit("sheetStepClose", [instance3]);
  }
  let initialWatched = false;
  function watchOpened(openedPassed) {
    if (!initialWatched) {
      initialWatched = true;
      return;
    }
    if (!f7Sheet) return;
    if (openedPassed) f7Sheet.open();
    else f7Sheet.close();
  }
  onMount(() => {
    const params = {
      el,
      on: {
        open: onOpen2,
        opened: onOpened,
        close: onClose2,
        closed: onClosed,
        stepOpen: onStepOpen,
        stepClose: onStepClose,
        stepProgress: onStepProgress,
        breakpoint: (s, value2) => {
          if (value2 > 0 && value2 < 1) {
            $$invalidate(26, state.breakpoint = true, state);
          } else {
            $$invalidate(26, state.breakpoint = false, state);
          }
          onBreakpoint(s, value2);
        },
        // eslint-disable-next-line
        _swipeStep(isSwipeStep) {
          $$invalidate(26, state.swipeStep = isSwipeStep, state);
        }
      }
    };
    if (typeof backdrop !== "undefined") params.backdrop = backdrop;
    if (typeof animate2 !== "undefined") params.animate = animate2;
    if (typeof backdropEl !== "undefined") params.backdropEl = backdropEl;
    if (typeof closeByBackdropClick !== "undefined") params.closeByBackdropClick = closeByBackdropClick;
    if (typeof closeByOutsideClick !== "undefined") params.closeByOutsideClick = closeByOutsideClick;
    if (typeof closeOnEscape !== "undefined") params.closeOnEscape = closeOnEscape;
    if (typeof swipeToClose !== "undefined") params.swipeToClose = swipeToClose;
    if (typeof swipeToStep !== "undefined") params.swipeToStep = swipeToStep;
    if (typeof swipeHandler !== "undefined") params.swipeHandler = swipeHandler;
    if (typeof containerEl !== "undefined") params.containerEl = containerEl;
    if (typeof breakpoints !== "undefined") params.breakpoints = breakpoints;
    if (typeof backdropBreakpoint !== "undefined") params.backdropBreakpoint = backdropBreakpoint;
    if (typeof pushBreakpoint !== "undefined") params.pushBreakpoint = pushBreakpoint;
    f7ready(() => {
      if (el && innerEl) {
        const dom7 = app.f7.$;
        const fixedEls = dom7(innerEl).children(".navbar, .toolbar, .tabbar, .searchbar");
        if (fixedEls.length) {
          dom7(el).prepend(fixedEls);
        }
      }
      $$invalidate(3, f7Sheet = app.f7.sheet.create(params));
      if (opened) {
        f7Sheet.open(false);
      }
    });
  });
  onDestroy(() => {
    if (f7Sheet) f7Sheet.destroy();
    $$invalidate(3, f7Sheet = null);
  });
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      innerEl = $$value;
      $$invalidate(2, innerEl);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(1, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(43, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props) $$invalidate(7, className = $$new_props.class);
    if ("style" in $$new_props) $$invalidate(0, style = $$new_props.style);
    if ("opened" in $$new_props) $$invalidate(6, opened = $$new_props.opened);
    if ("animate" in $$new_props) $$invalidate(8, animate2 = $$new_props.animate);
    if ("top" in $$new_props) $$invalidate(9, top = $$new_props.top);
    if ("bottom" in $$new_props) $$invalidate(10, bottom = $$new_props.bottom);
    if ("position" in $$new_props) $$invalidate(11, position = $$new_props.position);
    if ("backdrop" in $$new_props) $$invalidate(12, backdrop = $$new_props.backdrop);
    if ("backdropEl" in $$new_props) $$invalidate(13, backdropEl = $$new_props.backdropEl);
    if ("closeByBackdropClick" in $$new_props) $$invalidate(14, closeByBackdropClick = $$new_props.closeByBackdropClick);
    if ("closeByOutsideClick" in $$new_props) $$invalidate(15, closeByOutsideClick = $$new_props.closeByOutsideClick);
    if ("closeOnEscape" in $$new_props) $$invalidate(16, closeOnEscape = $$new_props.closeOnEscape);
    if ("push" in $$new_props) $$invalidate(17, push = $$new_props.push);
    if ("swipeToClose" in $$new_props) $$invalidate(18, swipeToClose = $$new_props.swipeToClose);
    if ("swipeToStep" in $$new_props) $$invalidate(19, swipeToStep = $$new_props.swipeToStep);
    if ("swipeHandler" in $$new_props) $$invalidate(20, swipeHandler = $$new_props.swipeHandler);
    if ("containerEl" in $$new_props) $$invalidate(21, containerEl = $$new_props.containerEl);
    if ("breakpoints" in $$new_props) $$invalidate(22, breakpoints = $$new_props.breakpoints);
    if ("backdropBreakpoint" in $$new_props) $$invalidate(23, backdropBreakpoint = $$new_props.backdropBreakpoint);
    if ("pushBreakpoint" in $$new_props) $$invalidate(24, pushBreakpoint = $$new_props.pushBreakpoint);
    if ("$$scope" in $$new_props) $$invalidate(28, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*position, top, bottom*/
    3584) {
      $$invalidate(27, positionComputed = (() => {
        if (position) return position;
        if (top) return "top";
        if (bottom) return "bottom";
        return "bottom";
      })());
    }
    $$invalidate(4, classes = classNames(
      className,
      "sheet-modal",
      `sheet-modal-${positionComputed}`,
      {
        "sheet-modal-push": push,
        "modal-in-swipe-step": state.swipeStep,
        "modal-in-breakpoint": state.breakpoint
      },
      modalStateClasses(state),
      colorClasses($$props)
    ));
    if ($$self.$$.dirty[0] & /*opened*/
    64) {
      watchOpened(opened);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    style,
    el,
    innerEl,
    f7Sheet,
    classes,
    $$restProps,
    opened,
    className,
    animate2,
    top,
    bottom,
    position,
    backdrop,
    backdropEl,
    closeByBackdropClick,
    closeByOutsideClick,
    closeOnEscape,
    push,
    swipeToClose,
    swipeToStep,
    swipeHandler,
    containerEl,
    breakpoints,
    backdropBreakpoint,
    pushBreakpoint,
    instance2,
    state,
    positionComputed,
    $$scope,
    slots,
    div0_binding,
    div1_binding
  ];
}
class Sheet extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance_1$2,
      create_fragment$u,
      safe_not_equal,
      {
        class: 7,
        style: 0,
        opened: 6,
        animate: 8,
        top: 9,
        bottom: 10,
        position: 11,
        backdrop: 12,
        backdropEl: 13,
        closeByBackdropClick: 14,
        closeByOutsideClick: 15,
        closeOnEscape: 16,
        push: 17,
        swipeToClose: 18,
        swipeToStep: 19,
        swipeHandler: 20,
        containerEl: 21,
        breakpoints: 22,
        backdropBreakpoint: 23,
        pushBreakpoint: 24,
        instance: 25
      },
      null,
      [-1, -1]
    );
  }
  get instance() {
    return this.$$.ctx[25];
  }
}
const get_default_slot_changes$1 = (dirty) => ({ popover: dirty & /*f7Popover*/
8 });
const get_default_slot_context$1 = (ctx) => ({ popover: (
  /*f7Popover*/
  ctx[3]
) });
function create_if_block$f(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "popover-arrow");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment$t(ctx) {
  let div1;
  let t2;
  let div0;
  let current;
  let if_block = (
    /*arrow*/
    ctx[1] !== false && create_if_block$f()
  );
  const default_slot_template = (
    /*#slots*/
    ctx[19].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    get_default_slot_context$1
  );
  let div1_levels = [
    { class: (
      /*classes*/
      ctx[4]
    ) },
    { style: (
      /*style*/
      ctx[0]
    ) },
    restProps(
      /*$$restProps*/
      ctx[5]
    )
  ];
  let div_data_1 = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div_data_1 = assign(div_data_1, div1_levels[i]);
  }
  return {
    c() {
      div1 = element("div");
      if (if_block) if_block.c();
      t2 = space();
      div0 = element("div");
      if (default_slot) default_slot.c();
      attr(div0, "class", "popover-inner");
      set_attributes(div1, div_data_1);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      if (if_block) if_block.m(div1, null);
      append(div1, t2);
      append(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[20](div1);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*arrow*/
        ctx2[1] !== false
      ) {
        if (if_block) ;
        else {
          if_block = create_if_block$f();
          if_block.c();
          if_block.m(div1, t2);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, f7Popover*/
        262152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              get_default_slot_changes$1
            ),
            get_default_slot_context$1
          );
        }
      }
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [
        (!current || dirty & /*classes*/
        16) && { class: (
          /*classes*/
          ctx2[4]
        ) },
        (!current || dirty & /*style*/
        1) && { style: (
          /*style*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        32 && restProps(
          /*$$restProps*/
          ctx2[5]
        )
      ]));
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (if_block) if_block.d();
      if (default_slot) default_slot.d(detaching);
      ctx[20](null);
    }
  };
}
function instance_1$1($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = [
    "class",
    "style",
    "opened",
    "animate",
    "targetEl",
    "arrow",
    "backdrop",
    "backdropEl",
    "closeByBackdropClick",
    "closeByOutsideClick",
    "closeOnEscape",
    "containerEl",
    "verticalPosition",
    "instance"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { style = "" } = $$props;
  let { opened = void 0 } = $$props;
  let { animate: animate2 = void 0 } = $$props;
  let { targetEl = void 0 } = $$props;
  let { arrow = void 0 } = $$props;
  let { backdrop = void 0 } = $$props;
  let { backdropEl = void 0 } = $$props;
  let { closeByBackdropClick = void 0 } = $$props;
  let { closeByOutsideClick = void 0 } = $$props;
  let { closeOnEscape = void 0 } = $$props;
  let { containerEl = void 0 } = $$props;
  let { verticalPosition = void 0 } = $$props;
  let el;
  let f7Popover;
  const state = { isOpened: opened, isClosing: false };
  function instance2() {
    return f7Popover;
  }
  function onOpen2(instance3) {
    Object.assign(state, { isOpened: true, isClosing: false });
    emit("popoverOpen", [instance3]);
    $$invalidate(6, opened = true);
  }
  function onOpened(instance3) {
    emit("popoverOpened", [instance3]);
  }
  function onClose2(instance3) {
    Object.assign(state, { isOpened: false, isClosing: true });
    emit("popoverClose", [instance3]);
  }
  function onClosed(instance3) {
    Object.assign(state, { isClosing: false });
    emit("popoverClosed", [instance3]);
    $$invalidate(6, opened = false);
  }
  let initialWatched = false;
  function watchOpened(openedPassed) {
    if (!initialWatched) {
      initialWatched = true;
      return;
    }
    if (!f7Popover) return;
    if (openedPassed) f7Popover.open();
    else f7Popover.close();
  }
  onMount(() => {
    const params = {
      el,
      on: {
        open: onOpen2,
        opened: onOpened,
        close: onClose2,
        closed: onClosed
      }
    };
    if (targetEl) params.targetEl = targetEl;
    if (typeof animate2 !== "undefined") params.animate = animate2;
    if (typeof closeByBackdropClick !== "undefined") params.closeByBackdropClick = closeByBackdropClick;
    if (typeof closeByOutsideClick !== "undefined") params.closeByOutsideClick = closeByOutsideClick;
    if (typeof closeOnEscape !== "undefined") params.closeOnEscape = closeOnEscape;
    if (typeof arrow !== "undefined") params.arrow = arrow;
    if (typeof backdrop !== "undefined") params.backdrop = backdrop;
    if (typeof backdropEl !== "undefined") params.backdropEl = backdropEl;
    if (typeof containerEl !== "undefined") params.containerEl = containerEl;
    if (typeof verticalPosition !== "undefined") params.verticalPosition = verticalPosition;
    f7ready(() => {
      $$invalidate(3, f7Popover = app.f7.popover.create(params));
      if (opened) {
        f7Popover.open(targetEl, false);
      }
    });
  });
  onDestroy(() => {
    if (f7Popover) f7Popover.destroy();
    $$invalidate(3, f7Popover = null);
  });
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(2, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(29, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props) $$invalidate(7, className = $$new_props.class);
    if ("style" in $$new_props) $$invalidate(0, style = $$new_props.style);
    if ("opened" in $$new_props) $$invalidate(6, opened = $$new_props.opened);
    if ("animate" in $$new_props) $$invalidate(8, animate2 = $$new_props.animate);
    if ("targetEl" in $$new_props) $$invalidate(9, targetEl = $$new_props.targetEl);
    if ("arrow" in $$new_props) $$invalidate(1, arrow = $$new_props.arrow);
    if ("backdrop" in $$new_props) $$invalidate(10, backdrop = $$new_props.backdrop);
    if ("backdropEl" in $$new_props) $$invalidate(11, backdropEl = $$new_props.backdropEl);
    if ("closeByBackdropClick" in $$new_props) $$invalidate(12, closeByBackdropClick = $$new_props.closeByBackdropClick);
    if ("closeByOutsideClick" in $$new_props) $$invalidate(13, closeByOutsideClick = $$new_props.closeByOutsideClick);
    if ("closeOnEscape" in $$new_props) $$invalidate(14, closeOnEscape = $$new_props.closeOnEscape);
    if ("containerEl" in $$new_props) $$invalidate(15, containerEl = $$new_props.containerEl);
    if ("verticalPosition" in $$new_props) $$invalidate(16, verticalPosition = $$new_props.verticalPosition);
    if ("$$scope" in $$new_props) $$invalidate(18, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(4, classes = classNames(className, "popover", modalStateClasses(state), colorClasses($$props)));
    if ($$self.$$.dirty & /*opened*/
    64) {
      watchOpened(opened);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    style,
    arrow,
    el,
    f7Popover,
    classes,
    $$restProps,
    opened,
    className,
    animate2,
    targetEl,
    backdrop,
    backdropEl,
    closeByBackdropClick,
    closeByOutsideClick,
    closeOnEscape,
    containerEl,
    verticalPosition,
    instance2,
    $$scope,
    slots,
    div1_binding
  ];
}
class Popover2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance_1$1, create_fragment$t, safe_not_equal, {
      class: 7,
      style: 0,
      opened: 6,
      animate: 8,
      targetEl: 9,
      arrow: 1,
      backdrop: 10,
      backdropEl: 11,
      closeByBackdropClick: 12,
      closeByOutsideClick: 13,
      closeOnEscape: 14,
      containerEl: 15,
      verticalPosition: 16,
      instance: 17
    });
  }
  get instance() {
    return this.$$.ctx[17];
  }
}
const get_default_slot_changes = (dirty) => ({ panel: dirty[0] & /*f7Panel*/
8 });
const get_default_slot_context = (ctx) => ({ panel: (
  /*f7Panel*/
  ctx[3]
) });
function create_if_block$e(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "panel-resize-handler");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment$s(ctx) {
  let div;
  let t2;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[31].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[30],
    get_default_slot_context
  );
  let if_block = (
    /*resizable*/
    ctx[0] && create_if_block$e()
  );
  let div_levels = [
    { class: (
      /*classes*/
      ctx[4]
    ) },
    { "data-f7-slot": (
      /*f7Slot*/
      ctx[1]
    ) },
    restProps(
      /*$$restProps*/
      ctx[5]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  return {
    c() {
      div = element("div");
      if (default_slot) default_slot.c();
      t2 = space();
      if (if_block) if_block.c();
      set_attributes(div, div_data);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append(div, t2);
      if (if_block) if_block.m(div, null);
      ctx[32](div);
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope, f7Panel*/
        1073741832)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[30],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[30]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[30],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
      if (
        /*resizable*/
        ctx2[0]
      ) {
        if (if_block) ;
        else {
          if_block = create_if_block$e();
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty[0] & /*classes*/
        16) && { class: (
          /*classes*/
          ctx2[4]
        ) },
        (!current || dirty[0] & /*f7Slot*/
        2) && { "data-f7-slot": (
          /*f7Slot*/
          ctx2[1]
        ) },
        dirty[0] & /*$$restProps*/
        32 && restProps(
          /*$$restProps*/
          ctx2[5]
        )
      ]));
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (if_block) if_block.d();
      ctx[32](null);
    }
  };
}
function instance_1($$self, $$props, $$invalidate) {
  let sideComputed;
  let effectComputed;
  let classes;
  const omit_props_names = [
    "class",
    "side",
    "effect",
    "cover",
    "reveal",
    "push",
    "floating",
    "left",
    "right",
    "opened",
    "resizable",
    "backdrop",
    "backdropEl",
    "containerEl",
    "closeByBackdropClick",
    "visibleBreakpoint",
    "collapsedBreakpoint",
    "swipe",
    "swipeNoFollow",
    "swipeOnlyClose",
    "swipeActiveArea",
    "swipeThreshold",
    "f7Slot",
    "instance"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { side = void 0 } = $$props;
  let { effect = void 0 } = $$props;
  let { cover = false } = $$props;
  let { reveal = false } = $$props;
  let { push = false } = $$props;
  let { floating = false } = $$props;
  let { left = false } = $$props;
  let { right = false } = $$props;
  let { opened = false } = $$props;
  let { resizable = false } = $$props;
  let { backdrop = true } = $$props;
  let { backdropEl = void 0 } = $$props;
  let { containerEl = void 0 } = $$props;
  let { closeByBackdropClick = void 0 } = $$props;
  let { visibleBreakpoint = void 0 } = $$props;
  let { collapsedBreakpoint = void 0 } = $$props;
  let { swipe = false } = $$props;
  let { swipeNoFollow = false } = $$props;
  let { swipeOnlyClose = false } = $$props;
  let { swipeActiveArea = 0 } = $$props;
  let { swipeThreshold = 0 } = $$props;
  let { f7Slot = "fixed" } = $$props;
  let el;
  let f7Panel;
  const state = {
    isOpened: false,
    isClosing: false,
    isCollapsed: false,
    isBreakpoint: false
  };
  function instance2() {
    return f7Panel;
  }
  let resizableOld = resizable;
  let initialWatchedResizable = false;
  function watchResizable(r) {
    if (!initialWatchedResizable) {
      initialWatchedResizable = true;
      return;
    }
    if (f7Panel && r && !resizableOld) {
      f7Panel.enableResizable();
    } else if (f7Panel && !r && resizableOld) {
      f7Panel.disableResizable();
    }
    resizableOld = r;
  }
  let openedOld = opened;
  let initialWatchedOpened = false;
  function watchOpened(o) {
    if (!initialWatchedOpened) {
      initialWatchedOpened = true;
      return;
    }
    if (f7Panel && o && !openedOld) {
      f7Panel.open();
    } else if (f7Panel && !o && openedOld) {
      f7Panel.close();
    }
    openedOld = o;
  }
  function onOpen2(...args) {
    Object.assign(state, { isOpened: true, isClosing: false });
    emit("panelOpen", args);
    $$invalidate(6, opened = true);
  }
  function onOpened(...args) {
    emit("panelOpened", args);
  }
  function onClose2(...args) {
    Object.assign(state, { isOpened: false, isClosing: true });
    emit("panelClose", args);
  }
  function onClosed(...args) {
    Object.assign(state, { isClosing: false });
    emit("panelClosed", args);
    $$invalidate(6, opened = false);
  }
  function onBackdropClick(...args) {
    emit("panelBackdropClick", args);
  }
  function onSwipe(...args) {
    emit("panelSwipe", args);
  }
  function onSwipeOpen(...args) {
    emit("panelSwipeOpen", args);
  }
  function onBreakpoint(...args) {
    Object.assign(state, { isBreakpoint: true, isCollapsed: false });
    emit("panelBreakpoint", args);
  }
  function onCollapsedBreakpoint(...args) {
    Object.assign(state, { isBreakpoint: false, isCollapsed: true });
    emit("panelCollapsedBreakpoint", args);
  }
  function onResize(...args) {
    emit("panelResize", args);
  }
  onMount(() => {
    f7ready(() => {
      const dom7 = app.f7.$;
      if (dom7(".panel-backdrop").length === 0) {
        dom7('<div class="panel-backdrop"></div>').insertBefore(el);
      }
      const params = noUndefinedProps({
        el,
        resizable,
        backdrop,
        backdropEl,
        containerEl,
        closeByBackdropClick,
        visibleBreakpoint,
        collapsedBreakpoint,
        swipe,
        swipeNoFollow,
        swipeOnlyClose,
        swipeActiveArea,
        swipeThreshold,
        on: {
          open: onOpen2,
          opened: onOpened,
          close: onClose2,
          closed: onClosed,
          backdropClick: onBackdropClick,
          swipe: onSwipe,
          swipeOpen: onSwipeOpen,
          collapsedBreakpoint: onCollapsedBreakpoint,
          breakpoint: onBreakpoint,
          resize: onResize
        }
      });
      $$invalidate(3, f7Panel = app.f7.panel.create(params));
      if (opened) {
        f7Panel.open(false);
      }
    });
  });
  onDestroy(() => {
    if (f7Panel && f7Panel.destroy) {
      f7Panel.destroy();
    }
    $$invalidate(3, f7Panel = null);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(2, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(51, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props) $$invalidate(7, className = $$new_props.class);
    if ("side" in $$new_props) $$invalidate(8, side = $$new_props.side);
    if ("effect" in $$new_props) $$invalidate(9, effect = $$new_props.effect);
    if ("cover" in $$new_props) $$invalidate(10, cover = $$new_props.cover);
    if ("reveal" in $$new_props) $$invalidate(11, reveal = $$new_props.reveal);
    if ("push" in $$new_props) $$invalidate(12, push = $$new_props.push);
    if ("floating" in $$new_props) $$invalidate(13, floating = $$new_props.floating);
    if ("left" in $$new_props) $$invalidate(14, left = $$new_props.left);
    if ("right" in $$new_props) $$invalidate(15, right = $$new_props.right);
    if ("opened" in $$new_props) $$invalidate(6, opened = $$new_props.opened);
    if ("resizable" in $$new_props) $$invalidate(0, resizable = $$new_props.resizable);
    if ("backdrop" in $$new_props) $$invalidate(16, backdrop = $$new_props.backdrop);
    if ("backdropEl" in $$new_props) $$invalidate(17, backdropEl = $$new_props.backdropEl);
    if ("containerEl" in $$new_props) $$invalidate(18, containerEl = $$new_props.containerEl);
    if ("closeByBackdropClick" in $$new_props) $$invalidate(19, closeByBackdropClick = $$new_props.closeByBackdropClick);
    if ("visibleBreakpoint" in $$new_props) $$invalidate(20, visibleBreakpoint = $$new_props.visibleBreakpoint);
    if ("collapsedBreakpoint" in $$new_props) $$invalidate(21, collapsedBreakpoint = $$new_props.collapsedBreakpoint);
    if ("swipe" in $$new_props) $$invalidate(22, swipe = $$new_props.swipe);
    if ("swipeNoFollow" in $$new_props) $$invalidate(23, swipeNoFollow = $$new_props.swipeNoFollow);
    if ("swipeOnlyClose" in $$new_props) $$invalidate(24, swipeOnlyClose = $$new_props.swipeOnlyClose);
    if ("swipeActiveArea" in $$new_props) $$invalidate(25, swipeActiveArea = $$new_props.swipeActiveArea);
    if ("swipeThreshold" in $$new_props) $$invalidate(26, swipeThreshold = $$new_props.swipeThreshold);
    if ("f7Slot" in $$new_props) $$invalidate(1, f7Slot = $$new_props.f7Slot);
    if ("$$scope" in $$new_props) $$invalidate(30, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*side, left, right*/
    49408) {
      $$invalidate(29, sideComputed = side || (left ? "left" : right ? "right" : "left"));
    }
    if ($$self.$$.dirty[0] & /*effect, reveal, push, floating*/
    14848) {
      $$invalidate(28, effectComputed = effect || (reveal ? "reveal" : push ? "push" : floating ? "floating" : "cover"));
    }
    $$invalidate(4, classes = classNames(
      className,
      "panel",
      {
        "panel-in": state.isOpened && !state.isClosing && !state.isBreakpoint,
        "panel-in-breakpoint": state.isBreakpoint,
        "panel-in-collapsed": state.isCollapsed,
        "panel-resizable": resizable,
        [`panel-${sideComputed}`]: sideComputed,
        [`panel-${effectComputed}`]: effectComputed
      },
      colorClasses($$props)
    ));
    if ($$self.$$.dirty[0] & /*resizable*/
    1) {
      watchResizable(resizable);
    }
    if ($$self.$$.dirty[0] & /*opened*/
    64) {
      watchOpened(opened);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    resizable,
    f7Slot,
    el,
    f7Panel,
    classes,
    $$restProps,
    opened,
    className,
    side,
    effect,
    cover,
    reveal,
    push,
    floating,
    left,
    right,
    backdrop,
    backdropEl,
    containerEl,
    closeByBackdropClick,
    visibleBreakpoint,
    collapsedBreakpoint,
    swipe,
    swipeNoFollow,
    swipeOnlyClose,
    swipeActiveArea,
    swipeThreshold,
    instance2,
    effectComputed,
    sideComputed,
    $$scope,
    slots,
    div_binding
  ];
}
class Panel2 extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance_1,
      create_fragment$s,
      safe_not_equal,
      {
        class: 7,
        side: 8,
        effect: 9,
        cover: 10,
        reveal: 11,
        push: 12,
        floating: 13,
        left: 14,
        right: 15,
        opened: 6,
        resizable: 0,
        backdrop: 16,
        backdropEl: 17,
        containerEl: 18,
        closeByBackdropClick: 19,
        visibleBreakpoint: 20,
        collapsedBreakpoint: 21,
        swipe: 22,
        swipeNoFollow: 23,
        swipeOnlyClose: 24,
        swipeActiveArea: 25,
        swipeThreshold: 26,
        f7Slot: 1,
        instance: 27
      },
      null,
      [-1, -1]
    );
  }
  get instance() {
    return this.$$.ctx[27];
  }
}
function create_if_block_4$2(ctx) {
  let popup;
  let current;
  popup = new Popup2({
    props: {
      className: "popup-router-open-in",
      "data-url": (
        /*url*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot_4$5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(popup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(popup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const popup_changes = {};
      if (dirty & /*url*/
      2) popup_changes["data-url"] = /*url*/
      ctx2[1];
      if (dirty & /*$$scope, viewSelector, url*/
      70) {
        popup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      popup.$set(popup_changes);
    },
    i(local) {
      if (current) return;
      transition_in(popup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(popup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(popup, detaching);
    }
  };
}
function create_default_slot_4$5(ctx) {
  let view;
  let current;
  view = new View2({
    props: {
      linksView: (
        /*viewSelector*/
        ctx[2]
      ),
      url: (
        /*url*/
        ctx[1]
      ),
      ignoreOpenIn: true
    }
  });
  return {
    c() {
      create_component(view.$$.fragment);
    },
    m(target, anchor) {
      mount_component(view, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const view_changes = {};
      if (dirty & /*viewSelector*/
      4) view_changes.linksView = /*viewSelector*/
      ctx2[2];
      if (dirty & /*url*/
      2) view_changes.url = /*url*/
      ctx2[1];
      view.$set(view_changes);
    },
    i(local) {
      if (current) return;
      transition_in(view.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(view.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(view, detaching);
    }
  };
}
function create_if_block_3$4(ctx) {
  let loginscreen;
  let current;
  loginscreen = new Login_screen({
    props: {
      className: "login-screen-router-open-in",
      "data-url": (
        /*url*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot_3$5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(loginscreen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loginscreen, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const loginscreen_changes = {};
      if (dirty & /*url*/
      2) loginscreen_changes["data-url"] = /*url*/
      ctx2[1];
      if (dirty & /*$$scope, viewSelector, url*/
      70) {
        loginscreen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      loginscreen.$set(loginscreen_changes);
    },
    i(local) {
      if (current) return;
      transition_in(loginscreen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loginscreen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loginscreen, detaching);
    }
  };
}
function create_default_slot_3$5(ctx) {
  let view;
  let current;
  view = new View2({
    props: {
      linksView: (
        /*viewSelector*/
        ctx[2]
      ),
      url: (
        /*url*/
        ctx[1]
      ),
      ignoreOpenIn: true
    }
  });
  return {
    c() {
      create_component(view.$$.fragment);
    },
    m(target, anchor) {
      mount_component(view, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const view_changes = {};
      if (dirty & /*viewSelector*/
      4) view_changes.linksView = /*viewSelector*/
      ctx2[2];
      if (dirty & /*url*/
      2) view_changes.url = /*url*/
      ctx2[1];
      view.$set(view_changes);
    },
    i(local) {
      if (current) return;
      transition_in(view.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(view.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(view, detaching);
    }
  };
}
function create_if_block_2$6(ctx) {
  let sheet;
  let current;
  sheet = new Sheet({
    props: {
      className: "sheet-modal-router-open-in",
      "data-url": (
        /*url*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot_2$6] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(sheet.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sheet, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sheet_changes = {};
      if (dirty & /*url*/
      2) sheet_changes["data-url"] = /*url*/
      ctx2[1];
      if (dirty & /*$$scope, viewSelector, url*/
      70) {
        sheet_changes.$$scope = { dirty, ctx: ctx2 };
      }
      sheet.$set(sheet_changes);
    },
    i(local) {
      if (current) return;
      transition_in(sheet.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sheet.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sheet, detaching);
    }
  };
}
function create_default_slot_2$6(ctx) {
  let view;
  let current;
  view = new View2({
    props: {
      linksView: (
        /*viewSelector*/
        ctx[2]
      ),
      url: (
        /*url*/
        ctx[1]
      ),
      ignoreOpenIn: true
    }
  });
  return {
    c() {
      create_component(view.$$.fragment);
    },
    m(target, anchor) {
      mount_component(view, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const view_changes = {};
      if (dirty & /*viewSelector*/
      4) view_changes.linksView = /*viewSelector*/
      ctx2[2];
      if (dirty & /*url*/
      2) view_changes.url = /*url*/
      ctx2[1];
      view.$set(view_changes);
    },
    i(local) {
      if (current) return;
      transition_in(view.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(view.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(view, detaching);
    }
  };
}
function create_if_block_1$8(ctx) {
  let popover;
  let current;
  popover = new Popover2({
    props: {
      className: "popover-router-open-in",
      targetEl: (
        /*targetEl*/
        ctx[3]
      ),
      "data-url": (
        /*url*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot_1$8] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(popover.$$.fragment);
    },
    m(target, anchor) {
      mount_component(popover, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const popover_changes = {};
      if (dirty & /*targetEl*/
      8) popover_changes.targetEl = /*targetEl*/
      ctx2[3];
      if (dirty & /*url*/
      2) popover_changes["data-url"] = /*url*/
      ctx2[1];
      if (dirty & /*$$scope, viewSelector, url*/
      70) {
        popover_changes.$$scope = { dirty, ctx: ctx2 };
      }
      popover.$set(popover_changes);
    },
    i(local) {
      if (current) return;
      transition_in(popover.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(popover.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(popover, detaching);
    }
  };
}
function create_default_slot_1$8(ctx) {
  let view;
  let current;
  view = new View2({
    props: {
      linksView: (
        /*viewSelector*/
        ctx[2]
      ),
      url: (
        /*url*/
        ctx[1]
      ),
      ignoreOpenIn: true
    }
  });
  return {
    c() {
      create_component(view.$$.fragment);
    },
    m(target, anchor) {
      mount_component(view, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const view_changes = {};
      if (dirty & /*viewSelector*/
      4) view_changes.linksView = /*viewSelector*/
      ctx2[2];
      if (dirty & /*url*/
      2) view_changes.url = /*url*/
      ctx2[1];
      view.$set(view_changes);
    },
    i(local) {
      if (current) return;
      transition_in(view.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(view.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(view, detaching);
    }
  };
}
function create_if_block$d(ctx) {
  let panel;
  let current;
  panel = new Panel2({
    props: {
      side: (
        /*side*/
        ctx[4]
      ),
      effect: (
        /*effect*/
        ctx[5]
      ),
      className: "panel-router-open-in",
      "data-url": (
        /*url*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot$b] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(panel.$$.fragment);
    },
    m(target, anchor) {
      mount_component(panel, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const panel_changes = {};
      if (dirty & /*side*/
      16) panel_changes.side = /*side*/
      ctx2[4];
      if (dirty & /*effect*/
      32) panel_changes.effect = /*effect*/
      ctx2[5];
      if (dirty & /*url*/
      2) panel_changes["data-url"] = /*url*/
      ctx2[1];
      if (dirty & /*$$scope, viewSelector, url*/
      70) {
        panel_changes.$$scope = { dirty, ctx: ctx2 };
      }
      panel.$set(panel_changes);
    },
    i(local) {
      if (current) return;
      transition_in(panel.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(panel.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(panel, detaching);
    }
  };
}
function create_default_slot$b(ctx) {
  let view;
  let current;
  view = new View2({
    props: {
      linksView: (
        /*viewSelector*/
        ctx[2]
      ),
      url: (
        /*url*/
        ctx[1]
      ),
      ignoreOpenIn: true
    }
  });
  return {
    c() {
      create_component(view.$$.fragment);
    },
    m(target, anchor) {
      mount_component(view, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const view_changes = {};
      if (dirty & /*viewSelector*/
      4) view_changes.linksView = /*viewSelector*/
      ctx2[2];
      if (dirty & /*url*/
      2) view_changes.url = /*url*/
      ctx2[1];
      view.$set(view_changes);
    },
    i(local) {
      if (current) return;
      transition_in(view.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(view.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(view, detaching);
    }
  };
}
function create_fragment$r(ctx) {
  let t0;
  let t1;
  let t2;
  let t3;
  let show_if = (
    /*openIn*/
    ctx[0].indexOf("panel") === 0
  );
  let if_block4_anchor;
  let current;
  let if_block0 = (
    /*openIn*/
    ctx[0] === "popup" && create_if_block_4$2(ctx)
  );
  let if_block1 = (
    /*openIn*/
    ctx[0] === "loginScreen" && create_if_block_3$4(ctx)
  );
  let if_block2 = (
    /*openIn*/
    ctx[0] === "sheet" && create_if_block_2$6(ctx)
  );
  let if_block3 = (
    /*openIn*/
    ctx[0] === "popover" && create_if_block_1$8(ctx)
  );
  let if_block4 = show_if && create_if_block$d(ctx);
  return {
    c() {
      if (if_block0) if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      if (if_block2) if_block2.c();
      t2 = space();
      if (if_block3) if_block3.c();
      t3 = space();
      if (if_block4) if_block4.c();
      if_block4_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t0, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert(target, t2, anchor);
      if (if_block3) if_block3.m(target, anchor);
      insert(target, t3, anchor);
      if (if_block4) if_block4.m(target, anchor);
      insert(target, if_block4_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*openIn*/
        ctx2[0] === "popup"
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*openIn*/
          1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_4$2(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*openIn*/
        ctx2[0] === "loginScreen"
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*openIn*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_3$4(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*openIn*/
        ctx2[0] === "sheet"
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*openIn*/
          1) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_2$6(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(t2.parentNode, t2);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*openIn*/
        ctx2[0] === "popover"
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & /*openIn*/
          1) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_1$8(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(t3.parentNode, t3);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (dirty & /*openIn*/
      1) show_if = /*openIn*/
      ctx2[0].indexOf("panel") === 0;
      if (show_if) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty & /*openIn*/
          1) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block$d(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(if_block4_anchor.parentNode, if_block4_anchor);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(if_block4_anchor);
      }
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d(detaching);
      if (if_block2) if_block2.d(detaching);
      if (if_block3) if_block3.d(detaching);
      if (if_block4) if_block4.d(detaching);
    }
  };
}
function instance$s($$self, $$props, $$invalidate) {
  let { openIn } = $$props;
  let { url } = $$props;
  let { viewSelector } = $$props;
  let { targetEl } = $$props;
  let { side } = $$props;
  let { effect } = $$props;
  $$self.$$set = ($$props2) => {
    if ("openIn" in $$props2) $$invalidate(0, openIn = $$props2.openIn);
    if ("url" in $$props2) $$invalidate(1, url = $$props2.url);
    if ("viewSelector" in $$props2) $$invalidate(2, viewSelector = $$props2.viewSelector);
    if ("targetEl" in $$props2) $$invalidate(3, targetEl = $$props2.targetEl);
    if ("side" in $$props2) $$invalidate(4, side = $$props2.side);
    if ("effect" in $$props2) $$invalidate(5, effect = $$props2.effect);
  };
  return [openIn, url, viewSelector, targetEl, side, effect];
}
class Router_open_in_component extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$s, create_fragment$r, safe_not_equal, {
      openIn: 0,
      url: 1,
      viewSelector: 2,
      targetEl: 3,
      side: 4,
      effect: 5
    });
  }
}
const routerOpenIn = (router, url, options) => {
  const navigateOptions = {
    url,
    route: {
      path: url,
      options: {
        ...options,
        openIn: void 0,
        props: {
          ...options.props || {},
          url,
          openIn: options.openIn,
          viewSelector: router.view.selector
        }
      }
    }
  };
  const params = {
    ...options
  };
  params.component = Router_open_in_component;
  if (options.openIn === "popup") {
    navigateOptions.route.popup = params;
  }
  if (options.openIn === "loginScreen") {
    navigateOptions.route.loginScreen = params;
  }
  if (options.openIn === "sheet") {
    navigateOptions.route.sheet = params;
  }
  if (options.openIn === "popover") {
    params.targetEl = options.clickedEl || options.targetEl;
    navigateOptions.route.popover = params;
    navigateOptions.route.options.props.targetEl = params.targetEl;
  }
  if (options.openIn.indexOf("panel") >= 0) {
    const parts = options.openIn.split(":");
    navigateOptions.route.options.props.side = parts[1] || "left";
    navigateOptions.route.options.props.effect = parts[2] || "cover";
    navigateOptions.route.panel = params;
  }
  return router.navigate(navigateOptions);
};
const getChildrenArray = (el) => {
  const arr = [];
  for (let i = 0; i < el.children.length; i += 1) {
    arr.push(el.children[i]);
  }
  return arr;
};
const hasSameChildren = (childrenBefore, childrenAfter) => {
  if (childrenBefore.length !== childrenAfter.length) return false;
  const set = /* @__PURE__ */ new Set([...childrenBefore, ...childrenAfter]);
  if (set.size === childrenBefore.length) return true;
  return false;
};
const componentsRouter = {
  proto: {
    openIn(router, navigateUrl, options) {
      return routerOpenIn(router, navigateUrl, options);
    },
    pageComponentLoader(_ref) {
      let {
        routerEl,
        component,
        options,
        resolve,
        reject
      } = _ref;
      const router = this;
      const routerId = router.id;
      const el = routerEl;
      let viewRouter;
      app.f7routers.views.forEach((data2) => {
        if (data2.el && data2.el === routerEl || data2.routerId && data2.routerId === routerId) {
          viewRouter = data2;
        }
      });
      if (!viewRouter) {
        reject();
        return;
      }
      const pageData = {
        component,
        id: getComponentId(),
        props: extend({
          f7route: options.route,
          f7router: router
        }, options.route.params, options.props || {})
      };
      let resolved;
      const childrenBefore = getChildrenArray(el);
      function onDidUpdate(componentRouterData) {
        if (componentRouterData !== viewRouter || resolved) return;
        const childrenAfter = getChildrenArray(el);
        if (hasSameChildren(childrenBefore, childrenAfter)) return;
        app.f7events.off("viewRouterDidUpdate", onDidUpdate);
        const pageEl = el.children[el.children.length - 1];
        pageData.el = pageEl;
        resolve(pageEl);
        resolved = true;
      }
      app.f7events.on("viewRouterDidUpdate", onDidUpdate);
      viewRouter.pages.push(pageData);
      viewRouter.setPages(viewRouter.pages);
    },
    removePage($pageEl) {
      if (!$pageEl) return;
      const router = this;
      let f7Page;
      if ("length" in $pageEl && $pageEl[0]) f7Page = $pageEl[0].f7Page;
      else f7Page = $pageEl.f7Page;
      if (f7Page && f7Page.route && f7Page.route.route && f7Page.route.route.keepAlive) {
        router.app.$($pageEl).remove();
        return;
      }
      let viewRouter;
      app.f7routers.views.forEach((data2) => {
        if (data2.el && data2.el === router.el) {
          viewRouter = data2;
        }
      });
      let pageEl;
      if ("length" in $pageEl) {
        if ($pageEl.length === 0) return;
        pageEl = $pageEl[0];
      } else {
        pageEl = $pageEl;
      }
      if (!pageEl) return;
      let pageComponentFound;
      viewRouter.pages.forEach((page, index2) => {
        if (page.el === pageEl) {
          pageComponentFound = true;
          viewRouter.pages.splice(index2, 1);
          viewRouter.setPages(viewRouter.pages);
        }
      });
      if (!pageComponentFound) {
        pageEl.parentNode.removeChild(pageEl);
      }
    },
    tabComponentLoader(_temp) {
      let {
        tabEl,
        component,
        options,
        resolve,
        reject
      } = _temp === void 0 ? {} : _temp;
      const router = this;
      if (!tabEl) reject();
      let tabRouter;
      app.f7routers.tabs.forEach((tabData) => {
        if (tabData.el && tabData.el === tabEl) {
          tabRouter = tabData;
        }
      });
      if (!tabRouter) {
        reject();
        return;
      }
      const id2 = getComponentId();
      const tabContent = {
        id: id2,
        component,
        props: extend({
          f7route: options.route,
          f7router: router
        }, options.route.route && options.route.route.tab && options.route.route.tab.options && options.route.route.tab.options.props || {}, options.route.params, options.props || {})
      };
      let resolved;
      function onDidUpdate(componentRouterData) {
        if (componentRouterData !== tabRouter || resolved) return;
        app.f7events.off("tabRouterDidUpdate", onDidUpdate);
        const tabContentEl = tabEl.children[0];
        resolve(tabContentEl);
        resolved = true;
      }
      app.f7events.on("tabRouterDidUpdate", onDidUpdate);
      tabRouter.setTabContent(tabContent);
    },
    removeTabContent(tabEl) {
      if (!tabEl) return;
      let tabRouter;
      app.f7routers.tabs.forEach((tabData) => {
        if (tabData.el && tabData.el === tabEl) {
          tabRouter = tabData;
        }
      });
      if (!tabRouter) {
        tabEl.innerHTML = "";
        return;
      }
      tabRouter.setTabContent(null);
    },
    modalComponentLoader(_temp2) {
      let {
        component,
        options,
        resolve,
        reject
      } = _temp2 === void 0 ? {} : _temp2;
      const router = this;
      const modalsRouter = app.f7routers.modals;
      if (!modalsRouter) {
        reject();
        return;
      }
      const modalData = {
        component,
        id: getComponentId(),
        props: extend({
          f7route: options.route,
          f7router: router
        }, options.route.params, options.props || {})
      };
      let resolved;
      function onDidUpdate() {
        if (resolved) return;
        app.f7events.off("modalsRouterDidUpdate", onDidUpdate);
        const modalEl = modalsRouter.el.children[modalsRouter.el.children.length - 1];
        modalData.el = modalEl;
        resolve(modalEl);
        resolved = true;
      }
      app.f7events.on("modalsRouterDidUpdate", onDidUpdate);
      modalsRouter.modals.push(modalData);
      modalsRouter.setModals(modalsRouter.modals);
    },
    removeModal(modalEl) {
      const modalsRouter = app.f7routers.modals;
      if (!modalsRouter) return;
      let modalDataToRemove;
      modalsRouter.modals.forEach((modalData) => {
        if (modalData.el === modalEl) modalDataToRemove = modalData;
      });
      modalsRouter.modals.splice(modalsRouter.modals.indexOf(modalDataToRemove), 1);
      modalsRouter.setModals(modalsRouter.modals);
    }
  }
};
const Framework7Svelte = {
  name: "sveltePlugin",
  installed: false,
  install(params) {
    if (params === void 0) {
      params = {};
    }
    const Framework72 = this;
    app.Framework7 = Framework72;
    if (Framework7Svelte.installed) return;
    Framework7Svelte.installed = true;
    f7initEvents();
    const {
      theme: paramsTheme,
      userAgent
    } = params;
    if (paramsTheme === "md") {
      app.theme.md = true;
    }
    if (paramsTheme === "ios") {
      app.theme.md = true;
    }
    const needThemeCalc = typeof window === "undefined" ? !!userAgent : true;
    if (needThemeCalc && (!paramsTheme || paramsTheme === "auto")) {
      const device = Framework72.getDevice({
        userAgent
      }, true);
      app.theme.ios = !!device.ios;
      app.theme.ios;
      app.theme.md = !app.theme.ios;
      app.theme.md;
    }
    f7ready(() => {
      setTheme();
    });
    Framework72.Router.use(componentsRouter);
  }
};
function get_each_context$3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i];
  return child_ctx;
}
function create_each_block$3(key_1, ctx) {
  let first;
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*modal*/
    ctx[5].props
  ];
  var switch_value = (
    /*modal*/
    ctx[5].component
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    if (dirty !== void 0 && dirty & /*modals*/
    1) {
      switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*modal*/
        ctx2[5].props
      )]));
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*modals*/
      1 && switch_value !== (switch_value = /*modal*/
      ctx[5].component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*modals*/
        1 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*modal*/
          ctx[5].props
        )]) : {};
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
        detach(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
}
function create_fragment$q(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value = ensure_array_like(
    /*modals*/
    ctx[0]
  );
  const get_key = (ctx2) => (
    /*modal*/
    ctx2[5].id
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$3(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$3(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "framework7-modals");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      ctx[2](div);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*modals*/
      1) {
        each_value = ensure_array_like(
          /*modals*/
          ctx2[0]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$3, null, get_each_context$3);
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      ctx[2](null);
    }
  };
}
function instance$r($$self, $$props, $$invalidate) {
  let modals = [];
  let el;
  let routerData;
  onMount(() => {
    routerData = {
      el,
      modals,
      setModals(m) {
        tick().then(() => {
          $$invalidate(0, modals = m);
        });
      }
    };
    app.f7routers.modals = routerData;
  });
  afterUpdate(() => {
    if (!routerData) return;
    app.f7events.emit("modalsRouterDidUpdate", routerData);
  });
  onDestroy(() => {
    if (!routerData) return;
    app.f7routers.modals = null;
    routerData = null;
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(1, el);
    });
  }
  return [modals, el, div_binding];
}
class Routable_modals extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$r, create_fragment$q, safe_not_equal, {});
  }
}
function create_fragment$p(ctx) {
  let div;
  let t2;
  let routablemodals;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  routablemodals = new Routable_modals({});
  return {
    c() {
      div = element("div");
      if (default_slot) default_slot.c();
      t2 = space();
      create_component(routablemodals.$$.fragment);
      attr(
        div,
        "class",
        /*classes*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append(div, t2);
      mount_component(routablemodals, div, null);
      ctx[5](div);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classes*/
      2) {
        attr(
          div,
          "class",
          /*classes*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      transition_in(routablemodals.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      transition_out(routablemodals.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (default_slot) default_slot.d(detaching);
      destroy_component(routablemodals);
      ctx[5](null);
    }
  };
}
function instance$q($$self, $$props, $$invalidate) {
  let classes;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { class: className = void 0 } = $$props;
  let el;
  if (!app.f7 || typeof window === "undefined") {
    f7init(el, noUndefinedProps($$props), false);
  }
  onMount(() => {
    const parentEl = el.parentNode;
    if (parentEl && parentEl !== document.body && parentEl.parentNode === document.body) {
      parentEl.style.height = "100%";
    }
    if (app.f7) {
      app.f7.init(el);
      return;
    }
    f7init(el, noUndefinedProps($$props), true);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, classes = classNames(className, "framework7-root", colorClasses($$props)));
  };
  $$props = exclude_internal_props($$props);
  return [el, classes, className, $$scope, slots, div_binding];
}
class App extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$q, create_fragment$p, safe_not_equal, { class: 2 });
  }
}
const useTooltip = (el, props) => {
  let f7Tooltip = null;
  const {
    tooltip,
    tooltipTrigger
  } = props;
  if (el && tooltip) {
    f7ready(() => {
      f7Tooltip = app.f7.tooltip.create({
        targetEl: el,
        text: tooltip,
        trigger: tooltipTrigger
      });
    });
  }
  return {
    update(_temp) {
      let {
        tooltip: value2
      } = _temp === void 0 ? {} : _temp;
      if (!value2 && f7Tooltip) {
        f7Tooltip.destroy();
        f7Tooltip = null;
        return;
      }
      if (value2 && !f7Tooltip && app.f7) {
        f7Tooltip = app.f7.tooltip.create({
          targetEl: el,
          text: value2,
          trigger: tooltipTrigger
        });
        return;
      }
      if (!value2 || !f7Tooltip) return;
      f7Tooltip.setText(value2);
    },
    destroy() {
      if (f7Tooltip && f7Tooltip.destroy) {
        f7Tooltip.destroy();
        f7Tooltip = null;
      }
    }
  };
};
function create_fragment$o(ctx) {
  let span;
  let useTooltip_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let span_levels = [{ class: (
    /*classes*/
    ctx[2]
  ) }, restProps(
    /*$$restProps*/
    ctx[3]
  )];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  return {
    c() {
      span = element("span");
      if (default_slot) default_slot.c();
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(useTooltip_action = useTooltip.call(null, span, {
          tooltip: (
            /*tooltip*/
            ctx[0]
          ),
          tooltipTrigger: (
            /*tooltipTrigger*/
            ctx[1]
          )
        }));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*classes*/
        4) && { class: (
          /*classes*/
          ctx2[2]
        ) },
        dirty & /*$$restProps*/
        8 && restProps(
          /*$$restProps*/
          ctx2[3]
        )
      ]));
      if (useTooltip_action && is_function(useTooltip_action.update) && dirty & /*tooltip, tooltipTrigger*/
      3) useTooltip_action.update.call(null, {
        tooltip: (
          /*tooltip*/
          ctx2[0]
        ),
        tooltipTrigger: (
          /*tooltipTrigger*/
          ctx2[1]
        )
      });
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$p($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "tooltip", "tooltipTrigger"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { class: className = void 0 } = $$props;
  let { tooltip = void 0 } = $$props;
  let { tooltipTrigger = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props) $$invalidate(4, className = $$new_props.class);
    if ("tooltip" in $$new_props) $$invalidate(0, tooltip = $$new_props.tooltip);
    if ("tooltipTrigger" in $$new_props) $$invalidate(1, tooltipTrigger = $$new_props.tooltipTrigger);
    if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(2, classes = classNames(className, "badge", colorClasses($$props)));
  };
  $$props = exclude_internal_props($$props);
  return [tooltip, tooltipTrigger, classes, $$restProps, className, $$scope, slots];
}
class Badge extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$p, create_fragment$o, safe_not_equal, { class: 4, tooltip: 0, tooltipTrigger: 1 });
  }
}
function create_fragment$n(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[0]
  ) }, restProps(
    /*$$restProps*/
    ctx[1]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  return {
    c() {
      div = element("div");
      if (default_slot) default_slot.c();
      set_attributes(div, div_data);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        2 && restProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function instance$o($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["large", "medium", "class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { large = false } = $$props;
  let { medium = false } = $$props;
  let { class: className = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("large" in $$new_props) $$invalidate(2, large = $$new_props.large);
    if ("medium" in $$new_props) $$invalidate(3, medium = $$new_props.medium);
    if ("class" in $$new_props) $$invalidate(4, className = $$new_props.class);
    if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(0, classes = classNames(
      className,
      "block-title",
      {
        "block-title-large": large,
        "block-title-medium": medium
      },
      colorClasses($$props)
    ));
  };
  $$props = exclude_internal_props($$props);
  return [classes, $$restProps, large, medium, className, $$scope, slots];
}
class Block_title extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$o, create_fragment$n, safe_not_equal, { large: 2, medium: 3, class: 4 });
  }
}
function create_fragment$m(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[34].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[33],
    null
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[1]
  ) }, restProps(
    /*$$restProps*/
    ctx[2]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  return {
    c() {
      div = element("div");
      if (default_slot) default_slot.c();
      set_attributes(div, div_data);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[35](div);
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[33],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[33]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[33],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty[0] & /*classes*/
        2) && { class: (
          /*classes*/
          ctx2[1]
        ) },
        dirty[0] & /*$$restProps*/
        4 && restProps(
          /*$$restProps*/
          ctx2[2]
        )
      ]));
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (default_slot) default_slot.d(detaching);
      ctx[35](null);
    }
  };
}
function instance$n($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = [
    "inset",
    "insetIos",
    "insetMd",
    "xsmallInset",
    "xsmallInsetIos",
    "xsmallInsetMd",
    "smallInset",
    "smallInsetIos",
    "smallInsetMd",
    "mediumInset",
    "mediumInsetIos",
    "mediumInsetMd",
    "largeInset",
    "largeInsetIos",
    "largeInsetMd",
    "xlargeInset",
    "xlargeInsetIos",
    "xlargeInsetMd",
    "strong",
    "strongIos",
    "strongMd",
    "tabs",
    "tab",
    "tabActive",
    "accordionList",
    "accordionOpposite",
    "outline",
    "outlineMd",
    "outlineIos",
    "class"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  const emit = createEmitter(createEventDispatcher, $$props);
  let { inset = false } = $$props;
  let { insetIos = false } = $$props;
  let { insetMd = false } = $$props;
  let { xsmallInset = false } = $$props;
  let { xsmallInsetIos = false } = $$props;
  let { xsmallInsetMd = false } = $$props;
  let { smallInset = false } = $$props;
  let { smallInsetIos = false } = $$props;
  let { smallInsetMd = false } = $$props;
  let { mediumInset = false } = $$props;
  let { mediumInsetIos = false } = $$props;
  let { mediumInsetMd = false } = $$props;
  let { largeInset = false } = $$props;
  let { largeInsetIos = false } = $$props;
  let { largeInsetMd = false } = $$props;
  let { xlargeInset = false } = $$props;
  let { xlargeInsetIos = false } = $$props;
  let { xlargeInsetMd = false } = $$props;
  let { strong = false } = $$props;
  let { strongIos = false } = $$props;
  let { strongMd = false } = $$props;
  let { tabs = false } = $$props;
  let { tab = false } = $$props;
  let { tabActive = false } = $$props;
  let { accordionList = false } = $$props;
  let { accordionOpposite = false } = $$props;
  let { outline = false } = $$props;
  let { outlineMd = false } = $$props;
  let { outlineIos = false } = $$props;
  let { class: className = void 0 } = $$props;
  let el;
  useTab(() => el, emit);
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(37, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("inset" in $$new_props) $$invalidate(3, inset = $$new_props.inset);
    if ("insetIos" in $$new_props) $$invalidate(4, insetIos = $$new_props.insetIos);
    if ("insetMd" in $$new_props) $$invalidate(5, insetMd = $$new_props.insetMd);
    if ("xsmallInset" in $$new_props) $$invalidate(6, xsmallInset = $$new_props.xsmallInset);
    if ("xsmallInsetIos" in $$new_props) $$invalidate(7, xsmallInsetIos = $$new_props.xsmallInsetIos);
    if ("xsmallInsetMd" in $$new_props) $$invalidate(8, xsmallInsetMd = $$new_props.xsmallInsetMd);
    if ("smallInset" in $$new_props) $$invalidate(9, smallInset = $$new_props.smallInset);
    if ("smallInsetIos" in $$new_props) $$invalidate(10, smallInsetIos = $$new_props.smallInsetIos);
    if ("smallInsetMd" in $$new_props) $$invalidate(11, smallInsetMd = $$new_props.smallInsetMd);
    if ("mediumInset" in $$new_props) $$invalidate(12, mediumInset = $$new_props.mediumInset);
    if ("mediumInsetIos" in $$new_props) $$invalidate(13, mediumInsetIos = $$new_props.mediumInsetIos);
    if ("mediumInsetMd" in $$new_props) $$invalidate(14, mediumInsetMd = $$new_props.mediumInsetMd);
    if ("largeInset" in $$new_props) $$invalidate(15, largeInset = $$new_props.largeInset);
    if ("largeInsetIos" in $$new_props) $$invalidate(16, largeInsetIos = $$new_props.largeInsetIos);
    if ("largeInsetMd" in $$new_props) $$invalidate(17, largeInsetMd = $$new_props.largeInsetMd);
    if ("xlargeInset" in $$new_props) $$invalidate(18, xlargeInset = $$new_props.xlargeInset);
    if ("xlargeInsetIos" in $$new_props) $$invalidate(19, xlargeInsetIos = $$new_props.xlargeInsetIos);
    if ("xlargeInsetMd" in $$new_props) $$invalidate(20, xlargeInsetMd = $$new_props.xlargeInsetMd);
    if ("strong" in $$new_props) $$invalidate(21, strong = $$new_props.strong);
    if ("strongIos" in $$new_props) $$invalidate(22, strongIos = $$new_props.strongIos);
    if ("strongMd" in $$new_props) $$invalidate(23, strongMd = $$new_props.strongMd);
    if ("tabs" in $$new_props) $$invalidate(24, tabs = $$new_props.tabs);
    if ("tab" in $$new_props) $$invalidate(25, tab = $$new_props.tab);
    if ("tabActive" in $$new_props) $$invalidate(26, tabActive = $$new_props.tabActive);
    if ("accordionList" in $$new_props) $$invalidate(27, accordionList = $$new_props.accordionList);
    if ("accordionOpposite" in $$new_props) $$invalidate(28, accordionOpposite = $$new_props.accordionOpposite);
    if ("outline" in $$new_props) $$invalidate(29, outline = $$new_props.outline);
    if ("outlineMd" in $$new_props) $$invalidate(30, outlineMd = $$new_props.outlineMd);
    if ("outlineIos" in $$new_props) $$invalidate(31, outlineIos = $$new_props.outlineIos);
    if ("class" in $$new_props) $$invalidate(32, className = $$new_props.class);
    if ("$$scope" in $$new_props) $$invalidate(33, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, classes = classNames(
      className,
      "block",
      {
        inset,
        "inset-ios": insetIos,
        "inset-md": insetMd,
        "xsmall-inset": xsmallInset,
        "xsmall-inset-ios": xsmallInsetIos,
        "xsmall-inset-md": xsmallInsetMd,
        "small-inset": smallInset,
        "small-inset-ios": smallInsetIos,
        "small-inset-md": smallInsetMd,
        "medium-inset": mediumInset,
        "medium-inset-ios": mediumInsetIos,
        "medium-inset-md": mediumInsetMd,
        "large-inset": largeInset,
        "large-inset-ios": largeInsetIos,
        "large-inset-md": largeInsetMd,
        "xlarge-inset": xlargeInset,
        "xlarge-inset-ios": xlargeInsetIos,
        "xlarge-inset-md": xlargeInsetMd,
        "block-strong": strong,
        "block-strong-ios": strongIos,
        "block-strong-md": strongMd,
        "accordion-list": accordionList,
        "accordion-opposite": accordionOpposite,
        tabs,
        tab,
        "tab-active": tabActive,
        "block-outline": outline,
        "block-outline-md": outlineMd,
        "block-outline-ios": outlineIos
      },
      colorClasses($$props)
    ));
  };
  $$props = exclude_internal_props($$props);
  return [
    el,
    classes,
    $$restProps,
    inset,
    insetIos,
    insetMd,
    xsmallInset,
    xsmallInsetIos,
    xsmallInsetMd,
    smallInset,
    smallInsetIos,
    smallInsetMd,
    mediumInset,
    mediumInsetIos,
    mediumInsetMd,
    largeInset,
    largeInsetIos,
    largeInsetMd,
    xlargeInset,
    xlargeInsetIos,
    xlargeInsetMd,
    strong,
    strongIos,
    strongMd,
    tabs,
    tab,
    tabActive,
    accordionList,
    accordionOpposite,
    outline,
    outlineMd,
    outlineIos,
    className,
    $$scope,
    slots,
    div_binding
  ];
}
class Block extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$n,
      create_fragment$m,
      safe_not_equal,
      {
        inset: 3,
        insetIos: 4,
        insetMd: 5,
        xsmallInset: 6,
        xsmallInsetIos: 7,
        xsmallInsetMd: 8,
        smallInset: 9,
        smallInsetIos: 10,
        smallInsetMd: 11,
        mediumInset: 12,
        mediumInsetIos: 13,
        mediumInsetMd: 14,
        largeInset: 15,
        largeInsetIos: 16,
        largeInsetMd: 17,
        xlargeInset: 18,
        xlargeInsetIos: 19,
        xlargeInsetMd: 20,
        strong: 21,
        strongIos: 22,
        strongMd: 23,
        tabs: 24,
        tab: 25,
        tabActive: 26,
        accordionList: 27,
        accordionOpposite: 28,
        outline: 29,
        outlineMd: 30,
        outlineIos: 31,
        class: 32
      },
      null,
      [-1, -1]
    );
  }
}
const useRouteProps = (el, routeProps) => {
  if (el && routeProps) {
    el.f7RouteProps = routeProps;
  }
  return {
    update(newValue) {
      if (el && el.f7RouteProps && !newValue) delete el.f7RouteProps;
      else if (el && newValue) el.f7RouteProps = newValue;
    },
    destroy() {
      if (el && routeProps) {
        delete el.f7RouteProps;
      }
    }
  };
};
const useIcon = function(props) {
  if (props === void 0) {
    props = {};
  }
  const {
    icon,
    iconMaterial,
    iconF7,
    iconMd,
    iconIos,
    iconColor,
    iconSize,
    iconBadge,
    badgeColor,
    iconBadgeColor
  } = props;
  if (icon || iconMaterial || iconF7 || iconMd || iconIos) {
    return {
      props: {
        material: iconMaterial,
        f7: iconF7,
        icon,
        md: iconMd,
        ios: iconIos,
        color: iconColor,
        size: iconSize
      },
      badge: iconBadge || iconBadge === 0 ? {
        props: {
          color: badgeColor || iconBadgeColor
        },
        content: iconBadge
      } : null
    };
  }
  return null;
};
const useTheme = (set) => {
  const t2 = app.f7 ? app.theme : null;
  if (!app.f7) {
    f7ready(() => {
      set(app.theme);
    });
  }
  return t2;
};
function create_fragment$l(ctx) {
  let i;
  let t0_value = (
    /*iconText*/
    (ctx[4] || "") + ""
  );
  let t0;
  let t1;
  let useTooltip_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[20].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    null
  );
  let i_levels = [
    { style: (
      /*iconStyle*/
      ctx[3]
    ) },
    { class: (
      /*iconClasses*/
      ctx[5]
    ) },
    restProps(
      /*$$restProps*/
      ctx[6]
    )
  ];
  let i_data = {};
  for (let i2 = 0; i2 < i_levels.length; i2 += 1) {
    i_data = assign(i_data, i_levels[i2]);
  }
  return {
    c() {
      i = element("i");
      t0 = text(t0_value);
      t1 = space();
      if (default_slot) default_slot.c();
      set_attributes(i, i_data);
    },
    m(target, anchor) {
      insert(target, i, anchor);
      append(i, t0);
      append(i, t1);
      if (default_slot) {
        default_slot.m(i, null);
      }
      ctx[21](i);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(useTooltip_action = useTooltip.call(null, i, {
          tooltip: (
            /*tooltip*/
            ctx[0]
          ),
          tooltipTrigger: (
            /*tooltipTrigger*/
            ctx[1]
          )
        }));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & /*iconText*/
      16) && t0_value !== (t0_value = /*iconText*/
      (ctx2[4] || "") + "")) set_data_maybe_contenteditable(t0, t0_value, i_data["contenteditable"]);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(i, i_data = get_spread_update(i_levels, [
        (!current || dirty & /*iconStyle*/
        8) && { style: (
          /*iconStyle*/
          ctx2[3]
        ) },
        (!current || dirty & /*iconClasses*/
        32) && { class: (
          /*iconClasses*/
          ctx2[5]
        ) },
        dirty & /*$$restProps*/
        64 && restProps(
          /*$$restProps*/
          ctx2[6]
        )
      ]));
      if (useTooltip_action && is_function(useTooltip_action.update) && dirty & /*tooltip, tooltipTrigger*/
      3) useTooltip_action.update.call(null, {
        tooltip: (
          /*tooltip*/
          ctx2[0]
        ),
        tooltipTrigger: (
          /*tooltipTrigger*/
          ctx2[1]
        )
      });
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(i);
      }
      if (default_slot) default_slot.d(detaching);
      ctx[21](null);
      mounted = false;
      dispose();
    }
  };
}
function instance$m($$self, $$props, $$invalidate) {
  let iconClasses;
  let iconText;
  let iconSize;
  let iconStyle;
  const omit_props_names = [
    "style",
    "class",
    "material",
    "f7",
    "icon",
    "ios",
    "md",
    "tooltip",
    "tooltipTrigger",
    "size"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { style = void 0 } = $$props;
  let { class: className = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { f7: f72 = void 0 } = $$props;
  let { icon = void 0 } = $$props;
  let { ios = void 0 } = $$props;
  let { md = void 0 } = $$props;
  let { tooltip = void 0 } = $$props;
  let { tooltipTrigger = void 0 } = $$props;
  let { size = void 0 } = $$props;
  let el;
  let theme = useTheme((t2) => {
    $$invalidate(15, theme = t2);
  });
  let classes = { icon: true };
  let themeIcon;
  function iconTextComputed(t2) {
    let textComputed = material || f72;
    if (md && t2 && t2.md && (md.indexOf("material:") >= 0 || md.indexOf("f7:") >= 0)) {
      textComputed = md.split(":")[1];
    } else if (ios && t2 && t2.ios && (ios.indexOf("material:") >= 0 || ios.indexOf("f7:") >= 0)) {
      textComputed = ios.split(":")[1];
    }
    return textComputed;
  }
  function i_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(2, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(23, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("style" in $$new_props) $$invalidate(7, style = $$new_props.style);
    if ("class" in $$new_props) $$invalidate(8, className = $$new_props.class);
    if ("material" in $$new_props) $$invalidate(9, material = $$new_props.material);
    if ("f7" in $$new_props) $$invalidate(10, f72 = $$new_props.f7);
    if ("icon" in $$new_props) $$invalidate(11, icon = $$new_props.icon);
    if ("ios" in $$new_props) $$invalidate(12, ios = $$new_props.ios);
    if ("md" in $$new_props) $$invalidate(13, md = $$new_props.md);
    if ("tooltip" in $$new_props) $$invalidate(0, tooltip = $$new_props.tooltip);
    if ("tooltipTrigger" in $$new_props) $$invalidate(1, tooltipTrigger = $$new_props.tooltipTrigger);
    if ("size" in $$new_props) $$invalidate(14, size = $$new_props.size);
    if ("$$scope" in $$new_props) $$invalidate(19, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*theme, ios, md*/
    45056) {
      if (theme) {
        if (theme.ios) $$invalidate(17, themeIcon = ios);
        if (theme.md) $$invalidate(17, themeIcon = md);
      }
    }
    if ($$self.$$.dirty & /*themeIcon, icon, material, f7*/
    134656) {
      if (themeIcon) {
        $$invalidate(16, classes = { icon: true });
        const parts = themeIcon.split(":");
        const prop2 = parts[0];
        const value2 = parts[1];
        if (prop2 === "material" || prop2 === "f7") {
          $$invalidate(16, classes["material-icons"] = prop2 === "material", classes);
          $$invalidate(16, classes["f7-icons"] = prop2 === "f7", classes);
          if (prop2 === "icon") {
            $$invalidate(16, classes[value2] = true, classes);
          }
        } else {
          if (themeIcon.includes(":")) {
            $$invalidate(17, themeIcon = themeIcon.split(" ").map((el2) => el2.replace("icon:", "")).join(" "));
          }
          $$invalidate(16, classes[themeIcon] = true, classes);
        }
        if (icon) $$invalidate(16, classes[icon] = true, classes);
      } else {
        $$invalidate(16, classes = {
          icon: true,
          "material-icons": material,
          "f7-icons": f72
        });
        if (icon) $$invalidate(16, classes[icon] = true, classes);
      }
    }
    $$invalidate(5, iconClasses = classNames(className, classes, colorClasses($$props)));
    if ($$self.$$.dirty & /*theme*/
    32768) {
      $$invalidate(4, iconText = iconTextComputed(theme));
    }
    if ($$self.$$.dirty & /*size*/
    16384) {
      $$invalidate(18, iconSize = typeof size === "number" || parseFloat(size) === size * 1 ? `${size}px` : size);
    }
    if ($$self.$$.dirty & /*style, iconSize*/
    262272) {
      $$invalidate(3, iconStyle = (style || "") + (iconSize ? `;font-size: ${iconSize}; width: ${iconSize}; height: ${iconSize}`.replace(";;", "") : ""));
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    tooltip,
    tooltipTrigger,
    el,
    iconStyle,
    iconText,
    iconClasses,
    $$restProps,
    style,
    className,
    material,
    f72,
    icon,
    ios,
    md,
    size,
    theme,
    classes,
    themeIcon,
    iconSize,
    $$scope,
    slots,
    i_binding
  ];
}
class Icon extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$m, create_fragment$l, safe_not_equal, {
      style: 7,
      class: 8,
      material: 9,
      f7: 10,
      icon: 11,
      ios: 12,
      md: 13,
      tooltip: 0,
      tooltipTrigger: 1,
      size: 14
    });
  }
}
function create_if_block$c(ctx) {
  let badge;
  let current;
  const badge_spread_levels = [
    /*icon*/
    ctx[0].badge.props
  ];
  let badge_props = {
    $$slots: { default: [create_default_slot_1$7] },
    $$scope: { ctx }
  };
  for (let i = 0; i < badge_spread_levels.length; i += 1) {
    badge_props = assign(badge_props, badge_spread_levels[i]);
  }
  badge = new Badge({ props: badge_props });
  return {
    c() {
      create_component(badge.$$.fragment);
    },
    m(target, anchor) {
      mount_component(badge, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const badge_changes = dirty & /*icon*/
      1 ? get_spread_update(badge_spread_levels, [get_spread_object(
        /*icon*/
        ctx2[0].badge.props
      )]) : {};
      if (dirty & /*$$scope, icon*/
      3) {
        badge_changes.$$scope = { dirty, ctx: ctx2 };
      }
      badge.$set(badge_changes);
    },
    i(local) {
      if (current) return;
      transition_in(badge.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(badge.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(badge, detaching);
    }
  };
}
function create_default_slot_1$7(ctx) {
  let t_value = (
    /*icon*/
    ctx[0].badge.content + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*icon*/
      1 && t_value !== (t_value = /*icon*/
      ctx2[0].badge.content + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot$a(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*icon*/
    ctx[0].badge && create_if_block$c(ctx)
  );
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*icon*/
        ctx2[0].badge
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*icon*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$c(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_fragment$k(ctx) {
  let icon_1;
  let current;
  const icon_1_spread_levels = [
    /*icon*/
    ctx[0].props
  ];
  let icon_1_props = {
    $$slots: { default: [create_default_slot$a] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_1_spread_levels.length; i += 1) {
    icon_1_props = assign(icon_1_props, icon_1_spread_levels[i]);
  }
  icon_1 = new Icon({ props: icon_1_props });
  return {
    c() {
      create_component(icon_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon_1, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_1_changes = dirty & /*icon*/
      1 ? get_spread_update(icon_1_spread_levels, [get_spread_object(
        /*icon*/
        ctx2[0].props
      )]) : {};
      if (dirty & /*$$scope, icon*/
      3) {
        icon_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon_1.$set(icon_1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(icon_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon_1, detaching);
    }
  };
}
function instance$l($$self, $$props, $$invalidate) {
  let { icon = void 0 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("icon" in $$props2) $$invalidate(0, icon = $$props2.icon);
  };
  return [icon];
}
class Use_icon extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$l, create_fragment$k, safe_not_equal, { icon: 0 });
  }
}
function create_else_block$4(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      attr(span, "class", "preloader-inner");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_1$7(ctx) {
  let span8;
  return {
    c() {
      span8 = element("span");
      span8.innerHTML = `<span class="preloader-inner-line"></span> <span class="preloader-inner-line"></span> <span class="preloader-inner-line"></span> <span class="preloader-inner-line"></span> <span class="preloader-inner-line"></span> <span class="preloader-inner-line"></span> <span class="preloader-inner-line"></span> <span class="preloader-inner-line"></span>`;
      attr(span8, "class", "preloader-inner");
    },
    m(target, anchor) {
      insert(target, span8, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(span8);
      }
    }
  };
}
function create_if_block$b(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.innerHTML = `<svg viewBox="0 0 36 36"><circle cx="18" cy="18" r="16"></circle></svg>`;
      attr(span, "class", "preloader-inner");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment$j(ctx) {
  let span;
  function select_block_type(ctx2, dirty) {
    if (
      /*theme*/
      ctx2[0] && /*theme*/
      ctx2[0].md
    ) return create_if_block$b;
    if (
      /*theme*/
      ctx2[0] && /*theme*/
      ctx2[0].ios
    ) return create_if_block_1$7;
    return create_else_block$4;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  let span_levels = [
    { style: (
      /*preloaderStyle*/
      ctx[2]
    ) },
    { class: (
      /*classes*/
      ctx[1]
    ) },
    restProps(
      /*$$restProps*/
      ctx[3]
    )
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  return {
    c() {
      span = element("span");
      if_block.c();
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if_block.m(span, null);
    },
    p(ctx2, [dirty]) {
      if (current_block_type !== (current_block_type = select_block_type(ctx2))) {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(span, null);
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        dirty & /*preloaderStyle*/
        4 && { style: (
          /*preloaderStyle*/
          ctx2[2]
        ) },
        dirty & /*classes*/
        2 && { class: (
          /*classes*/
          ctx2[1]
        ) },
        dirty & /*$$restProps*/
        8 && restProps(
          /*$$restProps*/
          ctx2[3]
        )
      ]));
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if_block.d();
    }
  };
}
function instance$k($$self, $$props, $$invalidate) {
  let sizeComputed;
  let preloaderStyle;
  let classes;
  const omit_props_names = ["style", "class", "size"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { style = void 0 } = $$props;
  let { class: className = void 0 } = $$props;
  let { size = void 0 } = $$props;
  let theme = useTheme((t2) => {
    $$invalidate(0, theme = t2);
  });
  $$self.$$set = ($$new_props) => {
    $$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("style" in $$new_props) $$invalidate(4, style = $$new_props.style);
    if ("class" in $$new_props) $$invalidate(5, className = $$new_props.class);
    if ("size" in $$new_props) $$invalidate(6, size = $$new_props.size);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*size*/
    64) {
      $$invalidate(7, sizeComputed = size && typeof size === "string" && size.indexOf("px") >= 0 ? size.replace("px", "") : size);
    }
    if ($$self.$$.dirty & /*style, sizeComputed*/
    144) {
      $$invalidate(2, preloaderStyle = ((style || "") + (sizeComputed ? `;width: ${sizeComputed}px; height: ${sizeComputed}px; --f7-preloader-size: ${sizeComputed}px` : "")).replace(";;", ";"));
    }
    $$invalidate(1, classes = classNames(className, { preloader: true }, colorClasses($$props)));
  };
  $$props = exclude_internal_props($$props);
  return [
    theme,
    classes,
    preloaderStyle,
    $$restProps,
    style,
    className,
    size,
    sizeComputed
  ];
}
class Preloader extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$k, create_fragment$j, safe_not_equal, { style: 4, class: 5, size: 6 });
  }
}
function create_else_block_1$2(ctx) {
  let a;
  let current_block_type_index;
  let if_block;
  let useRouteProps_action;
  let useTooltip_action;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_6$1, create_else_block_2$2];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*preloader*/
      ctx2[4]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let a_levels = [
    { class: (
      /*classes*/
      ctx[10]
    ) },
    /*attrs*/
    ctx[11]
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  return {
    c() {
      a = element("a");
      if_block.c();
      set_attributes(a, a_data);
    },
    m(target, anchor) {
      insert(target, a, anchor);
      if_blocks[current_block_type_index].m(a, null);
      ctx[47](a);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useRouteProps_action = useRouteProps.call(
            null,
            a,
            /*routeProps*/
            ctx[3]
          )),
          listen(
            a,
            "click",
            /*onClick*/
            ctx[12]
          ),
          action_destroyer(useTooltip_action = useTooltip.call(null, a, {
            tooltip: (
              /*tooltip*/
              ctx[1]
            ),
            tooltipTrigger: (
              /*tooltipTrigger*/
              ctx[2]
            )
          }))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(a, null);
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty[0] & /*classes*/
        1024) && { class: (
          /*classes*/
          ctx2[10]
        ) },
        dirty[0] & /*attrs*/
        2048 && /*attrs*/
        ctx2[11]
      ]));
      if (useRouteProps_action && is_function(useRouteProps_action.update) && dirty[0] & /*routeProps*/
      8) useRouteProps_action.update.call(
        null,
        /*routeProps*/
        ctx2[3]
      );
      if (useTooltip_action && is_function(useTooltip_action.update) && dirty[0] & /*tooltip, tooltipTrigger*/
      6) useTooltip_action.update.call(null, {
        tooltip: (
          /*tooltip*/
          ctx2[1]
        ),
        tooltipTrigger: (
          /*tooltipTrigger*/
          ctx2[2]
        )
      });
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(a);
      }
      if_blocks[current_block_type_index].d();
      ctx[47](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$a(ctx) {
  let button;
  let current_block_type_index;
  let if_block;
  let useRouteProps_action;
  let useTooltip_action;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_1$6, create_else_block$3];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*preloader*/
      ctx2[4]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let button_levels = [
    { class: (
      /*classes*/
      ctx[10]
    ) },
    /*attrs*/
    ctx[11]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  return {
    c() {
      button = element("button");
      if_block.c();
      set_attributes(button, button_data);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if_blocks[current_block_type_index].m(button, null);
      if (button.autofocus) button.focus();
      ctx[46](button);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useRouteProps_action = useRouteProps.call(
            null,
            button,
            /*routeProps*/
            ctx[3]
          )),
          listen(
            button,
            "click",
            /*onClick*/
            ctx[12]
          ),
          action_destroyer(useTooltip_action = useTooltip.call(null, button, {
            tooltip: (
              /*tooltip*/
              ctx[1]
            ),
            tooltipTrigger: (
              /*tooltipTrigger*/
              ctx[2]
            )
          }))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(button, null);
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        (!current || dirty[0] & /*classes*/
        1024) && { class: (
          /*classes*/
          ctx2[10]
        ) },
        dirty[0] & /*attrs*/
        2048 && /*attrs*/
        ctx2[11]
      ]));
      if (useRouteProps_action && is_function(useRouteProps_action.update) && dirty[0] & /*routeProps*/
      8) useRouteProps_action.update.call(
        null,
        /*routeProps*/
        ctx2[3]
      );
      if (useTooltip_action && is_function(useTooltip_action.update) && dirty[0] & /*tooltip, tooltipTrigger*/
      6) useTooltip_action.update.call(null, {
        tooltip: (
          /*tooltip*/
          ctx2[1]
        ),
        tooltipTrigger: (
          /*tooltipTrigger*/
          ctx2[2]
        )
      });
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if_blocks[current_block_type_index].d();
      ctx[46](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_else_block_2$2(ctx) {
  let t0;
  let t1;
  let current;
  let if_block0 = (
    /*icon*/
    ctx[8] && create_if_block_10$1(ctx)
  );
  let if_block1 = typeof /*text*/
  ctx[0] !== "undefined" && create_if_block_9$1(ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[45].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[44],
    null
  );
  return {
    c() {
      if (if_block0) if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      if (default_slot) default_slot.c();
    },
    m(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t0, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, t1, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*icon*/
        ctx2[8]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*icon*/
          256) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_10$1(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (typeof /*text*/
      ctx2[0] !== "undefined") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_9$1(ctx2);
          if_block1.c();
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[44],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[44]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[44],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d(detaching);
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function create_if_block_6$1(ctx) {
  let preloader_1;
  let t0;
  let span;
  let t1;
  let t2;
  let current;
  preloader_1 = new Preloader({
    props: {
      size: (
        /*preloaderSize*/
        ctx[5]
      ),
      color: (
        /*preloaderColor*/
        ctx[6]
      )
    }
  });
  let if_block0 = (
    /*icon*/
    ctx[8] && create_if_block_8$1(ctx)
  );
  let if_block1 = typeof /*text*/
  ctx[0] !== "undefined" && create_if_block_7$1(ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[45].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[44],
    null
  );
  return {
    c() {
      create_component(preloader_1.$$.fragment);
      t0 = space();
      span = element("span");
      if (if_block0) if_block0.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      if (default_slot) default_slot.c();
    },
    m(target, anchor) {
      mount_component(preloader_1, target, anchor);
      insert(target, t0, anchor);
      insert(target, span, anchor);
      if (if_block0) if_block0.m(span, null);
      append(span, t1);
      if (if_block1) if_block1.m(span, null);
      append(span, t2);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      const preloader_1_changes = {};
      if (dirty[0] & /*preloaderSize*/
      32) preloader_1_changes.size = /*preloaderSize*/
      ctx2[5];
      if (dirty[0] & /*preloaderColor*/
      64) preloader_1_changes.color = /*preloaderColor*/
      ctx2[6];
      preloader_1.$set(preloader_1_changes);
      if (
        /*icon*/
        ctx2[8]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*icon*/
          256) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_8$1(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(span, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (typeof /*text*/
      ctx2[0] !== "undefined") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_7$1(ctx2);
          if_block1.c();
          if_block1.m(span, t2);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[44],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[44]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[44],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(preloader_1.$$.fragment, local);
      transition_in(if_block0);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(preloader_1.$$.fragment, local);
      transition_out(if_block0);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(span);
      }
      destroy_component(preloader_1, detaching);
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function create_if_block_10$1(ctx) {
  let useicon;
  let current;
  useicon = new Use_icon({ props: { icon: (
    /*icon*/
    ctx[8]
  ) } });
  return {
    c() {
      create_component(useicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(useicon, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const useicon_changes = {};
      if (dirty[0] & /*icon*/
      256) useicon_changes.icon = /*icon*/
      ctx2[8];
      useicon.$set(useicon_changes);
    },
    i(local) {
      if (current) return;
      transition_in(useicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(useicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(useicon, detaching);
    }
  };
}
function create_if_block_9$1(ctx) {
  let span;
  let t_value = plainText(
    /*text*/
    ctx[0]
  ) + "";
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*text*/
      1 && t_value !== (t_value = plainText(
        /*text*/
        ctx2[0]
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_8$1(ctx) {
  let useicon;
  let current;
  useicon = new Use_icon({ props: { icon: (
    /*icon*/
    ctx[8]
  ) } });
  return {
    c() {
      create_component(useicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(useicon, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const useicon_changes = {};
      if (dirty[0] & /*icon*/
      256) useicon_changes.icon = /*icon*/
      ctx2[8];
      useicon.$set(useicon_changes);
    },
    i(local) {
      if (current) return;
      transition_in(useicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(useicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(useicon, detaching);
    }
  };
}
function create_if_block_7$1(ctx) {
  let span;
  let t_value = plainText(
    /*text*/
    ctx[0]
  ) + "";
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*text*/
      1 && t_value !== (t_value = plainText(
        /*text*/
        ctx2[0]
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_else_block$3(ctx) {
  let t0;
  let t1;
  let current;
  let if_block0 = (
    /*icon*/
    ctx[8] && create_if_block_5$1(ctx)
  );
  let if_block1 = typeof /*text*/
  ctx[0] !== "undefined" && create_if_block_4$1(ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[45].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[44],
    null
  );
  return {
    c() {
      if (if_block0) if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      if (default_slot) default_slot.c();
    },
    m(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t0, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, t1, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*icon*/
        ctx2[8]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*icon*/
          256) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_5$1(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (typeof /*text*/
      ctx2[0] !== "undefined") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_4$1(ctx2);
          if_block1.c();
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[44],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[44]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[44],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d(detaching);
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function create_if_block_1$6(ctx) {
  let preloader_1;
  let t0;
  let span;
  let t1;
  let t2;
  let current;
  preloader_1 = new Preloader({
    props: {
      size: (
        /*preloaderSize*/
        ctx[5]
      ),
      color: (
        /*preloaderColor*/
        ctx[6]
      )
    }
  });
  let if_block0 = (
    /*icon*/
    ctx[8] && create_if_block_3$3(ctx)
  );
  let if_block1 = typeof /*text*/
  ctx[0] !== "undefined" && create_if_block_2$5(ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[45].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[44],
    null
  );
  return {
    c() {
      create_component(preloader_1.$$.fragment);
      t0 = space();
      span = element("span");
      if (if_block0) if_block0.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      if (default_slot) default_slot.c();
    },
    m(target, anchor) {
      mount_component(preloader_1, target, anchor);
      insert(target, t0, anchor);
      insert(target, span, anchor);
      if (if_block0) if_block0.m(span, null);
      append(span, t1);
      if (if_block1) if_block1.m(span, null);
      append(span, t2);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      const preloader_1_changes = {};
      if (dirty[0] & /*preloaderSize*/
      32) preloader_1_changes.size = /*preloaderSize*/
      ctx2[5];
      if (dirty[0] & /*preloaderColor*/
      64) preloader_1_changes.color = /*preloaderColor*/
      ctx2[6];
      preloader_1.$set(preloader_1_changes);
      if (
        /*icon*/
        ctx2[8]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*icon*/
          256) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3$3(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(span, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (typeof /*text*/
      ctx2[0] !== "undefined") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_2$5(ctx2);
          if_block1.c();
          if_block1.m(span, t2);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[44],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[44]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[44],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(preloader_1.$$.fragment, local);
      transition_in(if_block0);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(preloader_1.$$.fragment, local);
      transition_out(if_block0);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(span);
      }
      destroy_component(preloader_1, detaching);
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function create_if_block_5$1(ctx) {
  let useicon;
  let current;
  useicon = new Use_icon({ props: { icon: (
    /*icon*/
    ctx[8]
  ) } });
  return {
    c() {
      create_component(useicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(useicon, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const useicon_changes = {};
      if (dirty[0] & /*icon*/
      256) useicon_changes.icon = /*icon*/
      ctx2[8];
      useicon.$set(useicon_changes);
    },
    i(local) {
      if (current) return;
      transition_in(useicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(useicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(useicon, detaching);
    }
  };
}
function create_if_block_4$1(ctx) {
  let span;
  let t_value = plainText(
    /*text*/
    ctx[0]
  ) + "";
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*text*/
      1 && t_value !== (t_value = plainText(
        /*text*/
        ctx2[0]
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_3$3(ctx) {
  let useicon;
  let current;
  useicon = new Use_icon({ props: { icon: (
    /*icon*/
    ctx[8]
  ) } });
  return {
    c() {
      create_component(useicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(useicon, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const useicon_changes = {};
      if (dirty[0] & /*icon*/
      256) useicon_changes.icon = /*icon*/
      ctx2[8];
      useicon.$set(useicon_changes);
    },
    i(local) {
      if (current) return;
      transition_in(useicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(useicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(useicon, detaching);
    }
  };
}
function create_if_block_2$5(ctx) {
  let span;
  let t_value = plainText(
    /*text*/
    ctx[0]
  ) + "";
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*text*/
      1 && t_value !== (t_value = plainText(
        /*text*/
        ctx2[0]
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment$i(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$a, create_else_block_1$2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*tagName*/
      ctx2[9] === "button"
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance$j($$self, $$props, $$invalidate) {
  let hrefComputed;
  let attrs;
  let classes;
  let tagName2;
  let icon;
  const omit_props_names = [
    "class",
    "text",
    "tabLink",
    "tabLinkActive",
    "type",
    "href",
    "target",
    "round",
    "roundMd",
    "roundIos",
    "fill",
    "fillMd",
    "fillIos",
    "tonal",
    "tonalMd",
    "tonalIos",
    "large",
    "largeMd",
    "largeIos",
    "small",
    "smallMd",
    "smallIos",
    "raised",
    "raisedMd",
    "raisedIos",
    "outline",
    "outlineMd",
    "outlineIos",
    "active",
    "disabled",
    "tooltip",
    "tooltipTrigger",
    "routeProps",
    "preloader",
    "preloaderSize",
    "preloaderColor",
    "loading"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { text: text2 = void 0 } = $$props;
  let { tabLink = void 0 } = $$props;
  let { tabLinkActive = false } = $$props;
  let { type = void 0 } = $$props;
  let { href = "#" } = $$props;
  let { target = void 0 } = $$props;
  let { round = false } = $$props;
  let { roundMd = false } = $$props;
  let { roundIos = false } = $$props;
  let { fill = false } = $$props;
  let { fillMd = false } = $$props;
  let { fillIos = false } = $$props;
  let { tonal = false } = $$props;
  let { tonalMd = false } = $$props;
  let { tonalIos = false } = $$props;
  let { large = false } = $$props;
  let { largeMd = false } = $$props;
  let { largeIos = false } = $$props;
  let { small = false } = $$props;
  let { smallMd = false } = $$props;
  let { smallIos = false } = $$props;
  let { raised = false } = $$props;
  let { raisedMd = false } = $$props;
  let { raisedIos = false } = $$props;
  let { outline = false } = $$props;
  let { outlineMd = false } = $$props;
  let { outlineIos = false } = $$props;
  let { active = false } = $$props;
  let { disabled = false } = $$props;
  let { tooltip = void 0 } = $$props;
  let { tooltipTrigger = void 0 } = $$props;
  let { routeProps = void 0 } = $$props;
  let { preloader = false } = $$props;
  let { preloaderSize = void 0 } = $$props;
  let { preloaderColor = void 0 } = $$props;
  let { loading = false } = $$props;
  let el;
  function onClick() {
    emit("click");
  }
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(7, el);
    });
  }
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(7, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(49, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(50, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props) $$invalidate(13, className = $$new_props.class);
    if ("text" in $$new_props) $$invalidate(0, text2 = $$new_props.text);
    if ("tabLink" in $$new_props) $$invalidate(14, tabLink = $$new_props.tabLink);
    if ("tabLinkActive" in $$new_props) $$invalidate(15, tabLinkActive = $$new_props.tabLinkActive);
    if ("type" in $$new_props) $$invalidate(16, type = $$new_props.type);
    if ("href" in $$new_props) $$invalidate(17, href = $$new_props.href);
    if ("target" in $$new_props) $$invalidate(18, target = $$new_props.target);
    if ("round" in $$new_props) $$invalidate(19, round = $$new_props.round);
    if ("roundMd" in $$new_props) $$invalidate(20, roundMd = $$new_props.roundMd);
    if ("roundIos" in $$new_props) $$invalidate(21, roundIos = $$new_props.roundIos);
    if ("fill" in $$new_props) $$invalidate(22, fill = $$new_props.fill);
    if ("fillMd" in $$new_props) $$invalidate(23, fillMd = $$new_props.fillMd);
    if ("fillIos" in $$new_props) $$invalidate(24, fillIos = $$new_props.fillIos);
    if ("tonal" in $$new_props) $$invalidate(25, tonal = $$new_props.tonal);
    if ("tonalMd" in $$new_props) $$invalidate(26, tonalMd = $$new_props.tonalMd);
    if ("tonalIos" in $$new_props) $$invalidate(27, tonalIos = $$new_props.tonalIos);
    if ("large" in $$new_props) $$invalidate(28, large = $$new_props.large);
    if ("largeMd" in $$new_props) $$invalidate(29, largeMd = $$new_props.largeMd);
    if ("largeIos" in $$new_props) $$invalidate(30, largeIos = $$new_props.largeIos);
    if ("small" in $$new_props) $$invalidate(31, small = $$new_props.small);
    if ("smallMd" in $$new_props) $$invalidate(32, smallMd = $$new_props.smallMd);
    if ("smallIos" in $$new_props) $$invalidate(33, smallIos = $$new_props.smallIos);
    if ("raised" in $$new_props) $$invalidate(34, raised = $$new_props.raised);
    if ("raisedMd" in $$new_props) $$invalidate(35, raisedMd = $$new_props.raisedMd);
    if ("raisedIos" in $$new_props) $$invalidate(36, raisedIos = $$new_props.raisedIos);
    if ("outline" in $$new_props) $$invalidate(37, outline = $$new_props.outline);
    if ("outlineMd" in $$new_props) $$invalidate(38, outlineMd = $$new_props.outlineMd);
    if ("outlineIos" in $$new_props) $$invalidate(39, outlineIos = $$new_props.outlineIos);
    if ("active" in $$new_props) $$invalidate(40, active = $$new_props.active);
    if ("disabled" in $$new_props) $$invalidate(41, disabled = $$new_props.disabled);
    if ("tooltip" in $$new_props) $$invalidate(1, tooltip = $$new_props.tooltip);
    if ("tooltipTrigger" in $$new_props) $$invalidate(2, tooltipTrigger = $$new_props.tooltipTrigger);
    if ("routeProps" in $$new_props) $$invalidate(3, routeProps = $$new_props.routeProps);
    if ("preloader" in $$new_props) $$invalidate(4, preloader = $$new_props.preloader);
    if ("preloaderSize" in $$new_props) $$invalidate(5, preloaderSize = $$new_props.preloaderSize);
    if ("preloaderColor" in $$new_props) $$invalidate(6, preloaderColor = $$new_props.preloaderColor);
    if ("loading" in $$new_props) $$invalidate(42, loading = $$new_props.loading);
    if ("$$scope" in $$new_props) $$invalidate(44, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*href*/
    131072) {
      $$invalidate(43, hrefComputed = href === true ? "#" : href || void 0);
    }
    $$invalidate(11, attrs = extend(
      {
        href: hrefComputed,
        target,
        type,
        "data-tab": isStringProp(tabLink) && tabLink || void 0,
        ...restProps($$restProps)
      },
      routerAttrs($$props),
      actionsAttrs($$props)
    ));
    $$invalidate(10, classes = classNames(
      className,
      "button",
      {
        "tab-link": tabLink || tabLink === "",
        "tab-link-active": tabLinkActive,
        "button-round": round,
        "button-round-ios": roundIos,
        "button-round-md": roundMd,
        "button-fill": fill,
        "button-fill-ios": fillIos,
        "button-fill-md": fillMd,
        "button-tonal": tonal,
        "button-tonal-ios": tonalIos,
        "button-tonal-md": tonalMd,
        "button-large": large,
        "button-large-ios": largeIos,
        "button-large-md": largeMd,
        "button-small": small,
        "button-small-ios": smallIos,
        "button-small-md": smallMd,
        "button-raised": raised,
        "button-raised-ios": raisedIos,
        "button-raised-md": raisedMd,
        "button-active": active,
        "button-outline": outline,
        "button-outline-ios": outlineIos,
        "button-outline-md": outlineMd,
        "button-preloader": preloader,
        "button-loading": loading,
        disabled
      },
      colorClasses($$props),
      routerClasses($$props),
      actionsClasses($$props)
    ));
    if ($$self.$$.dirty[0] & /*type*/
    65536) {
      $$invalidate(9, tagName2 = type === "submit" || type === "reset" || type === "button" ? "button" : "a");
    }
    $$invalidate(8, icon = useIcon($$props));
  };
  $$props = exclude_internal_props($$props);
  return [
    text2,
    tooltip,
    tooltipTrigger,
    routeProps,
    preloader,
    preloaderSize,
    preloaderColor,
    el,
    icon,
    tagName2,
    classes,
    attrs,
    onClick,
    className,
    tabLink,
    tabLinkActive,
    type,
    href,
    target,
    round,
    roundMd,
    roundIos,
    fill,
    fillMd,
    fillIos,
    tonal,
    tonalMd,
    tonalIos,
    large,
    largeMd,
    largeIos,
    small,
    smallMd,
    smallIos,
    raised,
    raisedMd,
    raisedIos,
    outline,
    outlineMd,
    outlineIos,
    active,
    disabled,
    loading,
    hrefComputed,
    $$scope,
    slots,
    button_binding,
    a_binding
  ];
}
class Button extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$j,
      create_fragment$i,
      safe_not_equal,
      {
        class: 13,
        text: 0,
        tabLink: 14,
        tabLinkActive: 15,
        type: 16,
        href: 17,
        target: 18,
        round: 19,
        roundMd: 20,
        roundIos: 21,
        fill: 22,
        fillMd: 23,
        fillIos: 24,
        tonal: 25,
        tonalMd: 26,
        tonalIos: 27,
        large: 28,
        largeMd: 29,
        largeIos: 30,
        small: 31,
        smallMd: 32,
        smallIos: 33,
        raised: 34,
        raisedMd: 35,
        raisedIos: 36,
        outline: 37,
        outlineMd: 38,
        outlineIos: 39,
        active: 40,
        disabled: 41,
        tooltip: 1,
        tooltipTrigger: 2,
        routeProps: 3,
        preloader: 4,
        preloaderSize: 5,
        preloaderColor: 6,
        loading: 42
      },
      null,
      [-1, -1]
    );
  }
}
const useSmartSelect = (props, setInstance, getEl) => {
  let f7SmartSelect;
  onMount(() => {
    f7ready(() => {
      if (props.smartSelect) {
        const ssParams = extend({
          el: getEl()
        }, props.smartSelectParams || {});
        f7SmartSelect = app.f7.smartSelect.create(ssParams);
        setInstance(f7SmartSelect);
      }
    });
  });
  onDestroy(() => {
    if (f7SmartSelect && f7SmartSelect.destroy) {
      f7SmartSelect.destroy();
    }
    f7SmartSelect = null;
    setInstance(f7SmartSelect);
  });
};
const getReactiveContext = (name, setValue) => {
  const ctx = getContext(name);
  if (!ctx) return void 0;
  const {
    value: value2,
    subscribe: subscribe2,
    unsubscribe
  } = ctx;
  subscribe2(setValue);
  onDestroy(() => {
    unsubscribe(setValue);
  });
  return value2;
};
function create_if_block_2$4(ctx) {
  let useicon;
  let current;
  useicon = new Use_icon({ props: { icon: (
    /*icon*/
    ctx[8]
  ) } });
  return {
    c() {
      create_component(useicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(useicon, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const useicon_changes = {};
      if (dirty[0] & /*icon*/
      256) useicon_changes.icon = /*icon*/
      ctx2[8];
      useicon.$set(useicon_changes);
    },
    i(local) {
      if (current) return;
      transition_in(useicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(useicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(useicon, detaching);
    }
  };
}
function create_if_block$9(ctx) {
  let span;
  let t0_value = plainText(
    /*text*/
    ctx[0]
  ) + "";
  let t0;
  let t1;
  let current;
  let if_block = typeof /*badge*/
  ctx[1] !== "undefined" && create_if_block_1$5(ctx);
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      if (if_block) if_block.c();
      toggle_class(
        span,
        "tabbar-label",
        /*isTabbarIcons*/
        ctx[6]
      );
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
      if (if_block) if_block.m(span, null);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*text*/
      1) && t0_value !== (t0_value = plainText(
        /*text*/
        ctx2[0]
      ) + "")) set_data(t0, t0_value);
      if (typeof /*badge*/
      ctx2[1] !== "undefined") {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*badge*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$5(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(span, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*isTabbarIcons*/
      64) {
        toggle_class(
          span,
          "tabbar-label",
          /*isTabbarIcons*/
          ctx2[6]
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (if_block) if_block.d();
    }
  };
}
function create_if_block_1$5(ctx) {
  let badge_1;
  let current;
  badge_1 = new Badge({
    props: {
      color: (
        /*badgeColor*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot$9] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(badge_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(badge_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const badge_1_changes = {};
      if (dirty[0] & /*badgeColor*/
      4) badge_1_changes.color = /*badgeColor*/
      ctx2[2];
      if (dirty[0] & /*$$scope, badge*/
      536870914) {
        badge_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      badge_1.$set(badge_1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(badge_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(badge_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(badge_1, detaching);
    }
  };
}
function create_default_slot$9(ctx) {
  let t_value = plainText(
    /*badge*/
    ctx[1]
  ) + "";
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*badge*/
      2 && t_value !== (t_value = plainText(
        /*badge*/
        ctx2[1]
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_fragment$h(ctx) {
  let a;
  let t0;
  let t1;
  let useTooltip_action;
  let useRouteProps_action;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*icon*/
    ctx[8] && create_if_block_2$4(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[27].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[29],
    null
  );
  let if_block1 = (typeof /*text*/
  ctx[0] !== "undefined" || typeof /*badge*/
  ctx[1] !== "undefined") && create_if_block$9(ctx);
  let a_levels = [
    { class: (
      /*classes*/
      ctx[9]
    ) },
    /*attrs*/
    ctx[10]
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  return {
    c() {
      a = element("a");
      if (if_block0) if_block0.c();
      t0 = space();
      if (default_slot) default_slot.c();
      t1 = space();
      if (if_block1) if_block1.c();
      set_attributes(a, a_data);
    },
    m(target, anchor) {
      insert(target, a, anchor);
      if (if_block0) if_block0.m(a, null);
      append(a, t0);
      if (default_slot) {
        default_slot.m(a, null);
      }
      append(a, t1);
      if (if_block1) if_block1.m(a, null);
      ctx[28](a);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            a,
            "click",
            /*onClick*/
            ctx[11]
          ),
          action_destroyer(useTooltip_action = useTooltip.call(null, a, {
            tooltip: (
              /*tooltip*/
              ctx[3]
            ),
            tooltipTrigger: (
              /*tooltipTrigger*/
              ctx[4]
            )
          })),
          action_destroyer(useRouteProps_action = useRouteProps.call(
            null,
            a,
            /*routeProps*/
            ctx[5]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (
        /*icon*/
        ctx2[8]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*icon*/
          256) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2$4(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(a, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        536870912)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[29],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[29]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[29],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (typeof /*text*/
      ctx2[0] !== "undefined" || typeof /*badge*/
      ctx2[1] !== "undefined") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*text, badge*/
          3) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$9(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(a, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty[0] & /*classes*/
        512) && { class: (
          /*classes*/
          ctx2[9]
        ) },
        dirty[0] & /*attrs*/
        1024 && /*attrs*/
        ctx2[10]
      ]));
      if (useTooltip_action && is_function(useTooltip_action.update) && dirty[0] & /*tooltip, tooltipTrigger*/
      24) useTooltip_action.update.call(null, {
        tooltip: (
          /*tooltip*/
          ctx2[3]
        ),
        tooltipTrigger: (
          /*tooltipTrigger*/
          ctx2[4]
        )
      });
      if (useRouteProps_action && is_function(useRouteProps_action.update) && dirty[0] & /*routeProps*/
      32) useRouteProps_action.update.call(
        null,
        /*routeProps*/
        ctx2[5]
      );
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(default_slot, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(default_slot, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(a);
      }
      if (if_block0) if_block0.d();
      if (default_slot) default_slot.d(detaching);
      if (if_block1) if_block1.d();
      ctx[28](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$i($$self, $$props, $$invalidate) {
  let isTabbarIcons;
  let hrefComputed;
  let attrs;
  let hasDefaultSlots;
  let iconOnlyComputed;
  let classes;
  let icon;
  const omit_props_names = [
    "class",
    "noLinkClass",
    "text",
    "tabLink",
    "tabLinkActive",
    "tabbarLabel",
    "iconOnly",
    "badge",
    "badgeColor",
    "href",
    "target",
    "tooltip",
    "tooltipTrigger",
    "routeProps",
    "smartSelect",
    "smartSelectParams",
    "smartSelectInstance"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { noLinkClass = false } = $$props;
  let { text: text2 = void 0 } = $$props;
  let { tabLink = void 0 } = $$props;
  let { tabLinkActive = false } = $$props;
  let { tabbarLabel = false } = $$props;
  let { iconOnly = false } = $$props;
  let { badge = void 0 } = $$props;
  let { badgeColor = void 0 } = $$props;
  let { href = "#" } = $$props;
  let { target = void 0 } = $$props;
  let { tooltip = void 0 } = $$props;
  let { tooltipTrigger = void 0 } = $$props;
  let { routeProps = void 0 } = $$props;
  let { smartSelect = false } = $$props;
  let { smartSelectParams = void 0 } = $$props;
  let el;
  let f7SmartSelect;
  function smartSelectInstance() {
    return f7SmartSelect;
  }
  let TabbarContext = getReactiveContext("TabbarContext", (newValue) => {
    $$invalidate(23, TabbarContext = newValue);
  }) || {};
  function onClick() {
    emit("click");
  }
  useSmartSelect(
    { smartSelect, smartSelectParams },
    (instance2) => {
      f7SmartSelect = instance2;
    },
    () => el
  );
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(7, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(32, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(34, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props) $$invalidate(12, className = $$new_props.class);
    if ("noLinkClass" in $$new_props) $$invalidate(13, noLinkClass = $$new_props.noLinkClass);
    if ("text" in $$new_props) $$invalidate(0, text2 = $$new_props.text);
    if ("tabLink" in $$new_props) $$invalidate(14, tabLink = $$new_props.tabLink);
    if ("tabLinkActive" in $$new_props) $$invalidate(15, tabLinkActive = $$new_props.tabLinkActive);
    if ("tabbarLabel" in $$new_props) $$invalidate(16, tabbarLabel = $$new_props.tabbarLabel);
    if ("iconOnly" in $$new_props) $$invalidate(17, iconOnly = $$new_props.iconOnly);
    if ("badge" in $$new_props) $$invalidate(1, badge = $$new_props.badge);
    if ("badgeColor" in $$new_props) $$invalidate(2, badgeColor = $$new_props.badgeColor);
    if ("href" in $$new_props) $$invalidate(18, href = $$new_props.href);
    if ("target" in $$new_props) $$invalidate(19, target = $$new_props.target);
    if ("tooltip" in $$new_props) $$invalidate(3, tooltip = $$new_props.tooltip);
    if ("tooltipTrigger" in $$new_props) $$invalidate(4, tooltipTrigger = $$new_props.tooltipTrigger);
    if ("routeProps" in $$new_props) $$invalidate(5, routeProps = $$new_props.routeProps);
    if ("smartSelect" in $$new_props) $$invalidate(20, smartSelect = $$new_props.smartSelect);
    if ("smartSelectParams" in $$new_props) $$invalidate(21, smartSelectParams = $$new_props.smartSelectParams);
    if ("$$scope" in $$new_props) $$invalidate(29, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*tabbarLabel, TabbarContext*/
    8454144) {
      $$invalidate(6, isTabbarIcons = tabbarLabel || TabbarContext.tabbarHasIcons);
    }
    if ($$self.$$.dirty[0] & /*href*/
    262144) {
      $$invalidate(26, hrefComputed = href === true ? "#" : href || void 0);
    }
    $$invalidate(10, attrs = extend(
      {
        href: hrefComputed,
        target,
        "data-tab": isStringProp(tabLink) && tabLink || void 0,
        ...restProps($$restProps)
      },
      routerAttrs($$props),
      actionsAttrs($$props)
    ));
    if ($$self.$$.dirty[0] & /*iconOnly, text, hasDefaultSlots*/
    33685505) {
      $$invalidate(24, iconOnlyComputed = iconOnly || !text2 && !hasDefaultSlots);
    }
    $$invalidate(9, classes = classNames(
      className,
      {
        link: !(noLinkClass || isTabbarIcons),
        "icon-only": iconOnlyComputed,
        "tab-link": tabLink || tabLink === "",
        "tab-link-active": tabLinkActive,
        "smart-select": smartSelect
      },
      colorClasses($$props),
      routerClasses($$props),
      actionsClasses($$props)
    ));
    $$invalidate(8, icon = useIcon($$props));
  };
  $$invalidate(25, hasDefaultSlots = $$slots.default);
  $$props = exclude_internal_props($$props);
  return [
    text2,
    badge,
    badgeColor,
    tooltip,
    tooltipTrigger,
    routeProps,
    isTabbarIcons,
    el,
    icon,
    classes,
    attrs,
    onClick,
    className,
    noLinkClass,
    tabLink,
    tabLinkActive,
    tabbarLabel,
    iconOnly,
    href,
    target,
    smartSelect,
    smartSelectParams,
    smartSelectInstance,
    TabbarContext,
    iconOnlyComputed,
    hasDefaultSlots,
    hrefComputed,
    slots,
    a_binding,
    $$scope
  ];
}
class Link extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$i,
      create_fragment$h,
      safe_not_equal,
      {
        class: 12,
        noLinkClass: 13,
        text: 0,
        tabLink: 14,
        tabLinkActive: 15,
        tabbarLabel: 16,
        iconOnly: 17,
        badge: 1,
        badgeColor: 2,
        href: 18,
        target: 19,
        tooltip: 3,
        tooltipTrigger: 4,
        routeProps: 5,
        smartSelect: 20,
        smartSelectParams: 21,
        smartSelectInstance: 22
      },
      null,
      [-1, -1]
    );
  }
  get smartSelectInstance() {
    return this.$$.ctx[22];
  }
}
const setReactiveContext = (name, getValue) => {
  const contextCallbacks = [];
  const contextSubscribe = (callback) => {
    contextCallbacks.push(callback);
  };
  const contextUnsubscribe = (callback) => {
    if (contextCallbacks.indexOf(callback) >= 0) {
      contextCallbacks.splice(contextCallbacks.indexOf, callback);
    }
  };
  const contextRunCallbacks = () => {
    contextCallbacks.forEach((callback) => {
      callback(getValue());
    });
  };
  setContext(name, {
    value: getValue(),
    subscribe: contextSubscribe,
    unsubscribe: contextUnsubscribe
  });
  beforeUpdate(() => {
    contextRunCallbacks();
  });
};
const get_root_end_slot_changes = (dirty) => ({});
const get_root_end_slot_context = (ctx) => ({});
const get_root_slot_changes = (dirty) => ({});
const get_root_slot_context = (ctx) => ({});
const get_content_end_slot_changes_5 = (dirty) => ({});
const get_content_end_slot_context_5 = (ctx) => ({});
const get_content_slot_changes_5 = (dirty) => ({});
const get_content_slot_context_5 = (ctx) => ({});
const get_inner_end_slot_changes_5 = (dirty) => ({});
const get_inner_end_slot_context_5 = (ctx) => ({});
const get_inner_slot_changes_11 = (dirty) => ({});
const get_inner_slot_context_11 = (ctx) => ({});
const get_after_end_slot_changes_11 = (dirty) => ({});
const get_after_end_slot_context_11 = (ctx) => ({});
const get_after_slot_changes_11 = (dirty) => ({});
const get_after_slot_context_11 = (ctx) => ({});
const get_after_start_slot_changes_11 = (dirty) => ({});
const get_after_start_slot_context_11 = (ctx) => ({});
const get_after_title_slot_changes_11 = (dirty) => ({});
const get_after_title_slot_context_11 = (ctx) => ({});
const get_footer_slot_changes_11 = (dirty) => ({});
const get_footer_slot_context_11 = (ctx) => ({});
const get_title_slot_changes_11 = (dirty) => ({});
const get_title_slot_context_11 = (ctx) => ({});
const get_header_slot_changes_11 = (dirty) => ({});
const get_header_slot_context_11 = (ctx) => ({});
const get_before_title_slot_changes_11 = (dirty) => ({});
const get_before_title_slot_context_11 = (ctx) => ({});
const get_footer_slot_changes_10 = (dirty) => ({});
const get_footer_slot_context_10 = (ctx) => ({});
const get_inner_slot_changes_10 = (dirty) => ({});
const get_inner_slot_context_10 = (ctx) => ({});
const get_text_slot_changes_5 = (dirty) => ({});
const get_text_slot_context_5 = (ctx) => ({});
const get_subtitle_slot_changes_5 = (dirty) => ({});
const get_subtitle_slot_context_5 = (ctx) => ({});
const get_after_end_slot_changes_10 = (dirty) => ({});
const get_after_end_slot_context_10 = (ctx) => ({});
const get_after_slot_changes_10 = (dirty) => ({});
const get_after_slot_context_10 = (ctx) => ({});
const get_after_start_slot_changes_10 = (dirty) => ({});
const get_after_start_slot_context_10 = (ctx) => ({});
const get_after_title_slot_changes_10 = (dirty) => ({});
const get_after_title_slot_context_10 = (ctx) => ({});
const get_title_slot_changes_10 = (dirty) => ({});
const get_title_slot_context_10 = (ctx) => ({});
const get_before_title_slot_changes_10 = (dirty) => ({});
const get_before_title_slot_context_10 = (ctx) => ({});
const get_header_slot_changes_10 = (dirty) => ({});
const get_header_slot_context_10 = (ctx) => ({});
const get_inner_start_slot_changes_5 = (dirty) => ({});
const get_inner_start_slot_context_5 = (ctx) => ({});
const get_media_slot_changes_5 = (dirty) => ({});
const get_media_slot_context_5 = (ctx) => ({});
const get_content_start_slot_changes_5 = (dirty) => ({});
const get_content_start_slot_context_5 = (ctx) => ({});
const get_content_end_slot_changes_4 = (dirty) => ({});
const get_content_end_slot_context_4 = (ctx) => ({});
const get_content_slot_changes_4 = (dirty) => ({});
const get_content_slot_context_4 = (ctx) => ({});
const get_inner_end_slot_changes_4 = (dirty) => ({});
const get_inner_end_slot_context_4 = (ctx) => ({});
const get_inner_slot_changes_9 = (dirty) => ({});
const get_inner_slot_context_9 = (ctx) => ({});
const get_after_end_slot_changes_9 = (dirty) => ({});
const get_after_end_slot_context_9 = (ctx) => ({});
const get_after_slot_changes_9 = (dirty) => ({});
const get_after_slot_context_9 = (ctx) => ({});
const get_after_start_slot_changes_9 = (dirty) => ({});
const get_after_start_slot_context_9 = (ctx) => ({});
const get_after_title_slot_changes_9 = (dirty) => ({});
const get_after_title_slot_context_9 = (ctx) => ({});
const get_footer_slot_changes_9 = (dirty) => ({});
const get_footer_slot_context_9 = (ctx) => ({});
const get_title_slot_changes_9 = (dirty) => ({});
const get_title_slot_context_9 = (ctx) => ({});
const get_header_slot_changes_9 = (dirty) => ({});
const get_header_slot_context_9 = (ctx) => ({});
const get_before_title_slot_changes_9 = (dirty) => ({});
const get_before_title_slot_context_9 = (ctx) => ({});
const get_footer_slot_changes_8 = (dirty) => ({});
const get_footer_slot_context_8 = (ctx) => ({});
const get_inner_slot_changes_8 = (dirty) => ({});
const get_inner_slot_context_8 = (ctx) => ({});
const get_text_slot_changes_4 = (dirty) => ({});
const get_text_slot_context_4 = (ctx) => ({});
const get_subtitle_slot_changes_4 = (dirty) => ({});
const get_subtitle_slot_context_4 = (ctx) => ({});
const get_after_end_slot_changes_8 = (dirty) => ({});
const get_after_end_slot_context_8 = (ctx) => ({});
const get_after_slot_changes_8 = (dirty) => ({});
const get_after_slot_context_8 = (ctx) => ({});
const get_after_start_slot_changes_8 = (dirty) => ({});
const get_after_start_slot_context_8 = (ctx) => ({});
const get_after_title_slot_changes_8 = (dirty) => ({});
const get_after_title_slot_context_8 = (ctx) => ({});
const get_title_slot_changes_8 = (dirty) => ({});
const get_title_slot_context_8 = (ctx) => ({});
const get_before_title_slot_changes_8 = (dirty) => ({});
const get_before_title_slot_context_8 = (ctx) => ({});
const get_header_slot_changes_8 = (dirty) => ({});
const get_header_slot_context_8 = (ctx) => ({});
const get_inner_start_slot_changes_4 = (dirty) => ({});
const get_inner_start_slot_context_4 = (ctx) => ({});
const get_media_slot_changes_4 = (dirty) => ({});
const get_media_slot_context_4 = (ctx) => ({});
const get_content_start_slot_changes_4 = (dirty) => ({});
const get_content_start_slot_context_4 = (ctx) => ({});
const get_content_end_slot_changes_3 = (dirty) => ({});
const get_content_end_slot_context_3 = (ctx) => ({});
const get_content_slot_changes_3 = (dirty) => ({});
const get_content_slot_context_3 = (ctx) => ({});
const get_inner_end_slot_changes_3 = (dirty) => ({});
const get_inner_end_slot_context_3 = (ctx) => ({});
const get_inner_slot_changes_7 = (dirty) => ({});
const get_inner_slot_context_7 = (ctx) => ({});
const get_after_end_slot_changes_7 = (dirty) => ({});
const get_after_end_slot_context_7 = (ctx) => ({});
const get_after_slot_changes_7 = (dirty) => ({});
const get_after_slot_context_7 = (ctx) => ({});
const get_after_start_slot_changes_7 = (dirty) => ({});
const get_after_start_slot_context_7 = (ctx) => ({});
const get_after_title_slot_changes_7 = (dirty) => ({});
const get_after_title_slot_context_7 = (ctx) => ({});
const get_footer_slot_changes_7 = (dirty) => ({});
const get_footer_slot_context_7 = (ctx) => ({});
const get_title_slot_changes_7 = (dirty) => ({});
const get_title_slot_context_7 = (ctx) => ({});
const get_header_slot_changes_7 = (dirty) => ({});
const get_header_slot_context_7 = (ctx) => ({});
const get_before_title_slot_changes_7 = (dirty) => ({});
const get_before_title_slot_context_7 = (ctx) => ({});
const get_footer_slot_changes_6 = (dirty) => ({});
const get_footer_slot_context_6 = (ctx) => ({});
const get_inner_slot_changes_6 = (dirty) => ({});
const get_inner_slot_context_6 = (ctx) => ({});
const get_text_slot_changes_3 = (dirty) => ({});
const get_text_slot_context_3 = (ctx) => ({});
const get_subtitle_slot_changes_3 = (dirty) => ({});
const get_subtitle_slot_context_3 = (ctx) => ({});
const get_after_end_slot_changes_6 = (dirty) => ({});
const get_after_end_slot_context_6 = (ctx) => ({});
const get_after_slot_changes_6 = (dirty) => ({});
const get_after_slot_context_6 = (ctx) => ({});
const get_after_start_slot_changes_6 = (dirty) => ({});
const get_after_start_slot_context_6 = (ctx) => ({});
const get_after_title_slot_changes_6 = (dirty) => ({});
const get_after_title_slot_context_6 = (ctx) => ({});
const get_title_slot_changes_6 = (dirty) => ({});
const get_title_slot_context_6 = (ctx) => ({});
const get_before_title_slot_changes_6 = (dirty) => ({});
const get_before_title_slot_context_6 = (ctx) => ({});
const get_header_slot_changes_6 = (dirty) => ({});
const get_header_slot_context_6 = (ctx) => ({});
const get_inner_start_slot_changes_3 = (dirty) => ({});
const get_inner_start_slot_context_3 = (ctx) => ({});
const get_media_slot_changes_3 = (dirty) => ({});
const get_media_slot_context_3 = (ctx) => ({});
const get_content_start_slot_changes_3 = (dirty) => ({});
const get_content_start_slot_context_3 = (ctx) => ({});
const get_content_end_slot_changes_2 = (dirty) => ({});
const get_content_end_slot_context_2 = (ctx) => ({});
const get_content_slot_changes_2 = (dirty) => ({});
const get_content_slot_context_2 = (ctx) => ({});
const get_inner_end_slot_changes_2 = (dirty) => ({});
const get_inner_end_slot_context_2 = (ctx) => ({});
const get_inner_slot_changes_5 = (dirty) => ({});
const get_inner_slot_context_5 = (ctx) => ({});
const get_after_end_slot_changes_5 = (dirty) => ({});
const get_after_end_slot_context_5 = (ctx) => ({});
const get_after_slot_changes_5 = (dirty) => ({});
const get_after_slot_context_5 = (ctx) => ({});
const get_after_start_slot_changes_5 = (dirty) => ({});
const get_after_start_slot_context_5 = (ctx) => ({});
const get_after_title_slot_changes_5 = (dirty) => ({});
const get_after_title_slot_context_5 = (ctx) => ({});
const get_footer_slot_changes_5 = (dirty) => ({});
const get_footer_slot_context_5 = (ctx) => ({});
const get_title_slot_changes_5 = (dirty) => ({});
const get_title_slot_context_5 = (ctx) => ({});
const get_header_slot_changes_5 = (dirty) => ({});
const get_header_slot_context_5 = (ctx) => ({});
const get_before_title_slot_changes_5 = (dirty) => ({});
const get_before_title_slot_context_5 = (ctx) => ({});
const get_footer_slot_changes_4 = (dirty) => ({});
const get_footer_slot_context_4 = (ctx) => ({});
const get_inner_slot_changes_4 = (dirty) => ({});
const get_inner_slot_context_4 = (ctx) => ({});
const get_text_slot_changes_2 = (dirty) => ({});
const get_text_slot_context_2 = (ctx) => ({});
const get_subtitle_slot_changes_2 = (dirty) => ({});
const get_subtitle_slot_context_2 = (ctx) => ({});
const get_after_end_slot_changes_4 = (dirty) => ({});
const get_after_end_slot_context_4 = (ctx) => ({});
const get_after_slot_changes_4 = (dirty) => ({});
const get_after_slot_context_4 = (ctx) => ({});
const get_after_start_slot_changes_4 = (dirty) => ({});
const get_after_start_slot_context_4 = (ctx) => ({});
const get_after_title_slot_changes_4 = (dirty) => ({});
const get_after_title_slot_context_4 = (ctx) => ({});
const get_title_slot_changes_4 = (dirty) => ({});
const get_title_slot_context_4 = (ctx) => ({});
const get_before_title_slot_changes_4 = (dirty) => ({});
const get_before_title_slot_context_4 = (ctx) => ({});
const get_header_slot_changes_4 = (dirty) => ({});
const get_header_slot_context_4 = (ctx) => ({});
const get_inner_start_slot_changes_2 = (dirty) => ({});
const get_inner_start_slot_context_2 = (ctx) => ({});
const get_media_slot_changes_2 = (dirty) => ({});
const get_media_slot_context_2 = (ctx) => ({});
const get_content_start_slot_changes_2 = (dirty) => ({});
const get_content_start_slot_context_2 = (ctx) => ({});
const get_content_end_slot_changes_1 = (dirty) => ({});
const get_content_end_slot_context_1 = (ctx) => ({});
const get_content_slot_changes_1 = (dirty) => ({});
const get_content_slot_context_1 = (ctx) => ({});
const get_inner_end_slot_changes_1 = (dirty) => ({});
const get_inner_end_slot_context_1 = (ctx) => ({});
const get_inner_slot_changes_3 = (dirty) => ({});
const get_inner_slot_context_3 = (ctx) => ({});
const get_after_end_slot_changes_3 = (dirty) => ({});
const get_after_end_slot_context_3 = (ctx) => ({});
const get_after_slot_changes_3 = (dirty) => ({});
const get_after_slot_context_3 = (ctx) => ({});
const get_after_start_slot_changes_3 = (dirty) => ({});
const get_after_start_slot_context_3 = (ctx) => ({});
const get_after_title_slot_changes_3 = (dirty) => ({});
const get_after_title_slot_context_3 = (ctx) => ({});
const get_footer_slot_changes_3 = (dirty) => ({});
const get_footer_slot_context_3 = (ctx) => ({});
const get_title_slot_changes_3 = (dirty) => ({});
const get_title_slot_context_3 = (ctx) => ({});
const get_header_slot_changes_3 = (dirty) => ({});
const get_header_slot_context_3 = (ctx) => ({});
const get_before_title_slot_changes_3 = (dirty) => ({});
const get_before_title_slot_context_3 = (ctx) => ({});
const get_footer_slot_changes_2 = (dirty) => ({});
const get_footer_slot_context_2 = (ctx) => ({});
const get_inner_slot_changes_2 = (dirty) => ({});
const get_inner_slot_context_2 = (ctx) => ({});
const get_text_slot_changes_1 = (dirty) => ({});
const get_text_slot_context_1 = (ctx) => ({});
const get_subtitle_slot_changes_1 = (dirty) => ({});
const get_subtitle_slot_context_1 = (ctx) => ({});
const get_after_end_slot_changes_2 = (dirty) => ({});
const get_after_end_slot_context_2 = (ctx) => ({});
const get_after_slot_changes_2 = (dirty) => ({});
const get_after_slot_context_2 = (ctx) => ({});
const get_after_start_slot_changes_2 = (dirty) => ({});
const get_after_start_slot_context_2 = (ctx) => ({});
const get_after_title_slot_changes_2 = (dirty) => ({});
const get_after_title_slot_context_2 = (ctx) => ({});
const get_title_slot_changes_2 = (dirty) => ({});
const get_title_slot_context_2 = (ctx) => ({});
const get_before_title_slot_changes_2 = (dirty) => ({});
const get_before_title_slot_context_2 = (ctx) => ({});
const get_header_slot_changes_2 = (dirty) => ({});
const get_header_slot_context_2 = (ctx) => ({});
const get_inner_start_slot_changes_1 = (dirty) => ({});
const get_inner_start_slot_context_1 = (ctx) => ({});
const get_media_slot_changes_1 = (dirty) => ({});
const get_media_slot_context_1 = (ctx) => ({});
const get_content_start_slot_changes_1 = (dirty) => ({});
const get_content_start_slot_context_1 = (ctx) => ({});
const get_content_end_slot_changes = (dirty) => ({});
const get_content_end_slot_context = (ctx) => ({});
const get_content_slot_changes = (dirty) => ({});
const get_content_slot_context = (ctx) => ({});
const get_inner_end_slot_changes = (dirty) => ({});
const get_inner_end_slot_context = (ctx) => ({});
const get_inner_slot_changes_1 = (dirty) => ({});
const get_inner_slot_context_1 = (ctx) => ({});
const get_after_end_slot_changes_1 = (dirty) => ({});
const get_after_end_slot_context_1 = (ctx) => ({});
const get_after_slot_changes_1 = (dirty) => ({});
const get_after_slot_context_1 = (ctx) => ({});
const get_after_start_slot_changes_1 = (dirty) => ({});
const get_after_start_slot_context_1 = (ctx) => ({});
const get_after_title_slot_changes_1 = (dirty) => ({});
const get_after_title_slot_context_1 = (ctx) => ({});
const get_footer_slot_changes_1 = (dirty) => ({});
const get_footer_slot_context_1 = (ctx) => ({});
const get_title_slot_changes_1 = (dirty) => ({});
const get_title_slot_context_1 = (ctx) => ({});
const get_header_slot_changes_1 = (dirty) => ({});
const get_header_slot_context_1 = (ctx) => ({});
const get_before_title_slot_changes_1 = (dirty) => ({});
const get_before_title_slot_context_1 = (ctx) => ({});
const get_footer_slot_changes = (dirty) => ({});
const get_footer_slot_context = (ctx) => ({});
const get_inner_slot_changes = (dirty) => ({});
const get_inner_slot_context = (ctx) => ({});
const get_text_slot_changes = (dirty) => ({});
const get_text_slot_context = (ctx) => ({});
const get_subtitle_slot_changes = (dirty) => ({});
const get_subtitle_slot_context = (ctx) => ({});
const get_after_end_slot_changes = (dirty) => ({});
const get_after_end_slot_context = (ctx) => ({});
const get_after_slot_changes = (dirty) => ({});
const get_after_slot_context = (ctx) => ({});
const get_after_start_slot_changes = (dirty) => ({});
const get_after_start_slot_context = (ctx) => ({});
const get_after_title_slot_changes = (dirty) => ({});
const get_after_title_slot_context = (ctx) => ({});
const get_title_slot_changes$1 = (dirty) => ({});
const get_title_slot_context$1 = (ctx) => ({});
const get_before_title_slot_changes = (dirty) => ({});
const get_before_title_slot_context = (ctx) => ({});
const get_header_slot_changes = (dirty) => ({});
const get_header_slot_context = (ctx) => ({});
const get_inner_start_slot_changes = (dirty) => ({});
const get_inner_start_slot_context = (ctx) => ({});
const get_media_slot_changes = (dirty) => ({});
const get_media_slot_context = (ctx) => ({});
const get_content_start_slot_changes = (dirty) => ({});
const get_content_start_slot_context = (ctx) => ({});
const get_root_start_slot_changes = (dirty) => ({});
const get_root_start_slot_context = (ctx) => ({});
function create_else_block$2(ctx) {
  let li;
  let t0;
  let current_block_type_index;
  let if_block0;
  let t1;
  let t2;
  let t3;
  let t4;
  let useTooltip_action;
  let current;
  let mounted;
  let dispose;
  const root_start_slot_template = (
    /*#slots*/
    ctx[69]["root-start"]
  );
  const root_start_slot = create_slot(
    root_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_root_start_slot_context
  );
  const if_block_creators = [create_if_block_4, create_if_block_67, create_else_block_7];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*swipeout*/
      ctx2[13]
    ) return 0;
    if (
      /*isLink*/
      ctx2[37]
    ) return 1;
    return 2;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = (
    /*isSortable*/
    ctx[44] && /*sortable*/
    ctx[14] !== false && !/*isSortableOpposite*/
    ctx[43] && create_if_block_3$2()
  );
  let if_block2 = (
    /*swipeout*/
    (ctx[13] || /*accordionItem*/
    ctx[15]) && create_if_block_2$3(ctx)
  );
  const root_slot_template = (
    /*#slots*/
    ctx[69].root
  );
  const root_slot = create_slot(
    root_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_root_slot_context
  );
  const root_end_slot_template = (
    /*#slots*/
    ctx[69]["root-end"]
  );
  const root_end_slot = create_slot(
    root_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_root_end_slot_context
  );
  let li_levels = [
    { class: (
      /*liClasses*/
      ctx[41]
    ) },
    {
      "data-virtual-list-index": (
        /*virtualListIndex*/
        ctx[23]
      )
    },
    restProps(
      /*$$restProps*/
      ctx[47]
    )
  ];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  return {
    c() {
      li = element("li");
      if (root_start_slot) root_start_slot.c();
      t0 = space();
      if_block0.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      if (if_block2) if_block2.c();
      t3 = space();
      if (root_slot) root_slot.c();
      t4 = space();
      if (root_end_slot) root_end_slot.c();
      set_attributes(li, li_data);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      if (root_start_slot) {
        root_start_slot.m(li, null);
      }
      append(li, t0);
      if_blocks[current_block_type_index].m(li, null);
      append(li, t1);
      if (if_block1) if_block1.m(li, null);
      append(li, t2);
      if (if_block2) if_block2.m(li, null);
      append(li, t3);
      if (root_slot) {
        root_slot.m(li, null);
      }
      append(li, t4);
      if (root_end_slot) {
        root_end_slot.m(li, null);
      }
      ctx[82](li);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(useTooltip_action = useTooltip.call(null, li, {
          tooltip: (
            /*tooltip*/
            ctx[7]
          ),
          tooltipTrigger: (
            /*tooltipTrigger*/
            ctx[8]
          )
        }));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (root_start_slot) {
        if (root_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            root_start_slot,
            root_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              root_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_root_start_slot_changes
            ),
            get_root_start_slot_context
          );
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(li, t1);
      }
      if (
        /*isSortable*/
        ctx2[44] && /*sortable*/
        ctx2[14] !== false && !/*isSortableOpposite*/
        ctx2[43]
      ) {
        if (if_block1) ;
        else {
          if_block1 = create_if_block_3$2();
          if_block1.c();
          if_block1.m(li, t2);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*swipeout*/
        ctx2[13] || /*accordionItem*/
        ctx2[15]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*swipeout, accordionItem*/
          40960) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_2$3(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(li, t3);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (root_slot) {
        if (root_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            root_slot,
            root_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              root_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_root_slot_changes
            ),
            get_root_slot_context
          );
        }
      }
      if (root_end_slot) {
        if (root_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            root_end_slot,
            root_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              root_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_root_end_slot_changes
            ),
            get_root_end_slot_context
          );
        }
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [
        (!current || dirty[1] & /*liClasses*/
        1024) && { class: (
          /*liClasses*/
          ctx2[41]
        ) },
        (!current || dirty[0] & /*virtualListIndex*/
        8388608) && {
          "data-virtual-list-index": (
            /*virtualListIndex*/
            ctx2[23]
          )
        },
        dirty[1] & /*$$restProps*/
        65536 && restProps(
          /*$$restProps*/
          ctx2[47]
        )
      ]));
      if (useTooltip_action && is_function(useTooltip_action.update) && dirty[0] & /*tooltip, tooltipTrigger*/
      384) useTooltip_action.update.call(null, {
        tooltip: (
          /*tooltip*/
          ctx2[7]
        ),
        tooltipTrigger: (
          /*tooltipTrigger*/
          ctx2[8]
        )
      });
    },
    i(local) {
      if (current) return;
      transition_in(root_start_slot, local);
      transition_in(if_block0);
      transition_in(if_block2);
      transition_in(root_slot, local);
      transition_in(root_end_slot, local);
      current = true;
    },
    o(local) {
      transition_out(root_start_slot, local);
      transition_out(if_block0);
      transition_out(if_block2);
      transition_out(root_slot, local);
      transition_out(root_end_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      if (root_start_slot) root_start_slot.d(detaching);
      if_blocks[current_block_type_index].d();
      if (if_block1) if_block1.d();
      if (if_block2) if_block2.d();
      if (root_slot) root_slot.d(detaching);
      if (root_end_slot) root_end_slot.d(detaching);
      ctx[82](null);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$4(ctx) {
  let li;
  let t0_value = plainText(
    /*title*/
    ctx[1]
  ) + "";
  let t0;
  let t1;
  let useTooltip_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[69].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    null
  );
  let li_levels = [
    { class: (
      /*liClasses*/
      ctx[41]
    ) },
    {
      "data-virtual-list-index": (
        /*virtualListIndex*/
        ctx[23]
      )
    },
    restProps(
      /*$$restProps*/
      ctx[47]
    )
  ];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  return {
    c() {
      li = element("li");
      t0 = text(t0_value);
      t1 = space();
      if (default_slot) default_slot.c();
      set_attributes(li, li_data);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, t0);
      append(li, t1);
      if (default_slot) {
        default_slot.m(li, null);
      }
      ctx[71](li);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            li,
            "click",
            /*onClick*/
            ctx[45]
          ),
          action_destroyer(useTooltip_action = useTooltip.call(null, li, {
            tooltip: (
              /*tooltip*/
              ctx[7]
            ),
            tooltipTrigger: (
              /*tooltipTrigger*/
              ctx[8]
            )
          }))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*title*/
      2) && t0_value !== (t0_value = plainText(
        /*title*/
        ctx2[1]
      ) + "")) set_data_maybe_contenteditable(t0, t0_value, li_data["contenteditable"]);
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [
        (!current || dirty[1] & /*liClasses*/
        1024) && { class: (
          /*liClasses*/
          ctx2[41]
        ) },
        (!current || dirty[0] & /*virtualListIndex*/
        8388608) && {
          "data-virtual-list-index": (
            /*virtualListIndex*/
            ctx2[23]
          )
        },
        dirty[1] & /*$$restProps*/
        65536 && restProps(
          /*$$restProps*/
          ctx2[47]
        )
      ]));
      if (useTooltip_action && is_function(useTooltip_action.update) && dirty[0] & /*tooltip, tooltipTrigger*/
      384) useTooltip_action.update.call(null, {
        tooltip: (
          /*tooltip*/
          ctx2[7]
        ),
        tooltipTrigger: (
          /*tooltipTrigger*/
          ctx2[8]
        )
      });
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      if (default_slot) default_slot.d(detaching);
      ctx[71](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$8(ctx) {
  let li;
  let span;
  let useTooltip_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[69].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block(ctx);
  let li_levels = [
    { class: (
      /*liClasses*/
      ctx[41]
    ) },
    {
      "data-virtual-list-index": (
        /*virtualListIndex*/
        ctx[23]
      )
    },
    restProps(
      /*$$restProps*/
      ctx[47]
    )
  ];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  return {
    c() {
      li = element("li");
      span = element("span");
      if (default_slot_or_fallback) default_slot_or_fallback.c();
      set_attributes(li, li_data);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, span);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(span, null);
      }
      ctx[70](li);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            li,
            "click",
            /*onClick*/
            ctx[45]
          ),
          action_destroyer(useTooltip_action = useTooltip.call(null, li, {
            tooltip: (
              /*tooltip*/
              ctx[7]
            ),
            tooltipTrigger: (
              /*tooltipTrigger*/
              ctx[8]
            )
          }))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              null
            ),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty[0] & /*title*/
        2)) {
          default_slot_or_fallback.p(ctx2, !current ? [-1, -1, -1, -1] : dirty);
        }
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [
        (!current || dirty[1] & /*liClasses*/
        1024) && { class: (
          /*liClasses*/
          ctx2[41]
        ) },
        (!current || dirty[0] & /*virtualListIndex*/
        8388608) && {
          "data-virtual-list-index": (
            /*virtualListIndex*/
            ctx2[23]
          )
        },
        dirty[1] & /*$$restProps*/
        65536 && restProps(
          /*$$restProps*/
          ctx2[47]
        )
      ]));
      if (useTooltip_action && is_function(useTooltip_action.update) && dirty[0] & /*tooltip, tooltipTrigger*/
      384) useTooltip_action.update.call(null, {
        tooltip: (
          /*tooltip*/
          ctx2[7]
        ),
        tooltipTrigger: (
          /*tooltipTrigger*/
          ctx2[8]
        )
      });
    },
    i(local) {
      if (current) return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
      ctx[70](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_else_block_7(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_88, create_else_block_9];
  const if_blocks = [];
  function select_block_type_8(ctx2, dirty) {
    if (
      /*checkbox*/
      ctx2[16] || /*radio*/
      ctx2[17]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type_8(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_8(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_if_block_67(ctx) {
  let a;
  let div1;
  let t0;
  let t1;
  let t2;
  let div0;
  let t3;
  let current_block_type_index;
  let if_block2;
  let t4;
  let t5;
  let t6;
  let useRouteProps_action;
  let current;
  let mounted;
  let dispose;
  const content_start_slot_template = (
    /*#slots*/
    ctx[69]["content-start"]
  );
  const content_start_slot = create_slot(
    content_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_content_start_slot_context_3
  );
  let if_block0 = (
    /*isSortable*/
    ctx[44] && /*sortable*/
    ctx[14] !== false && /*isSortableOpposite*/
    ctx[43] && create_if_block_87()
  );
  let if_block1 = (
    /*hasMedia*/
    ctx[36] && create_if_block_85(ctx)
  );
  const inner_start_slot_template = (
    /*#slots*/
    ctx[69]["inner-start"]
  );
  const inner_start_slot = create_slot(
    inner_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_start_slot_context_3
  );
  const if_block_creators = [create_if_block_68, create_else_block_6];
  const if_blocks = [];
  function select_block_type_7(ctx2, dirty) {
    if (
      /*isMedia*/
      ctx2[25]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type_7(ctx);
  if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const inner_end_slot_template = (
    /*#slots*/
    ctx[69]["inner-end"]
  );
  const inner_end_slot = create_slot(
    inner_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_end_slot_context_3
  );
  const content_slot_template = (
    /*#slots*/
    ctx[69].content
  );
  const content_slot = create_slot(
    content_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_content_slot_context_3
  );
  const content_end_slot_template = (
    /*#slots*/
    ctx[69]["content-end"]
  );
  const content_end_slot = create_slot(
    content_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_content_end_slot_context_3
  );
  let a_levels = [
    { class: (
      /*linkClasses*/
      ctx[39]
    ) },
    /*linkAttrs*/
    ctx[38]
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  return {
    c() {
      a = element("a");
      div1 = element("div");
      if (content_start_slot) content_start_slot.c();
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      div0 = element("div");
      if (inner_start_slot) inner_start_slot.c();
      t3 = space();
      if_block2.c();
      t4 = space();
      if (inner_end_slot) inner_end_slot.c();
      t5 = space();
      if (content_slot) content_slot.c();
      t6 = space();
      if (content_end_slot) content_end_slot.c();
      attr(div0, "class", "item-inner");
      attr(
        div1,
        "class",
        /*contentClasses*/
        ctx[40]
      );
      set_attributes(a, a_data);
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, div1);
      if (content_start_slot) {
        content_start_slot.m(div1, null);
      }
      append(div1, t0);
      if (if_block0) if_block0.m(div1, null);
      append(div1, t1);
      if (if_block1) if_block1.m(div1, null);
      append(div1, t2);
      append(div1, div0);
      if (inner_start_slot) {
        inner_start_slot.m(div0, null);
      }
      append(div0, t3);
      if_blocks[current_block_type_index].m(div0, null);
      append(div0, t4);
      if (inner_end_slot) {
        inner_end_slot.m(div0, null);
      }
      ctx[77](div0);
      append(div1, t5);
      if (content_slot) {
        content_slot.m(div1, null);
      }
      append(div1, t6);
      if (content_end_slot) {
        content_end_slot.m(div1, null);
      }
      ctx[78](a);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useRouteProps_action = useRouteProps.call(
            null,
            a,
            /*routeProps*/
            ctx[24]
          )),
          listen(
            a,
            "click",
            /*onClick*/
            ctx[45]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (content_start_slot) {
        if (content_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            content_start_slot,
            content_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              content_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_content_start_slot_changes_3
            ),
            get_content_start_slot_context_3
          );
        }
      }
      if (
        /*isSortable*/
        ctx2[44] && /*sortable*/
        ctx2[14] !== false && /*isSortableOpposite*/
        ctx2[43]
      ) {
        if (if_block0) ;
        else {
          if_block0 = create_if_block_87();
          if_block0.c();
          if_block0.m(div1, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*hasMedia*/
        ctx2[36]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasMedia*/
          32) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_85(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (inner_start_slot) {
        if (inner_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_start_slot,
            inner_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_start_slot_changes_3
            ),
            get_inner_start_slot_context_3
          );
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_7(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block2 = if_blocks[current_block_type_index];
        if (!if_block2) {
          if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block2.c();
        } else {
          if_block2.p(ctx2, dirty);
        }
        transition_in(if_block2, 1);
        if_block2.m(div0, t4);
      }
      if (inner_end_slot) {
        if (inner_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_end_slot,
            inner_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_end_slot_changes_3
            ),
            get_inner_end_slot_context_3
          );
        }
      }
      if (content_slot) {
        if (content_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            content_slot,
            content_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              content_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_content_slot_changes_3
            ),
            get_content_slot_context_3
          );
        }
      }
      if (content_end_slot) {
        if (content_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            content_end_slot,
            content_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              content_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_content_end_slot_changes_3
            ),
            get_content_end_slot_context_3
          );
        }
      }
      if (!current || dirty[1] & /*contentClasses*/
      512) {
        attr(
          div1,
          "class",
          /*contentClasses*/
          ctx2[40]
        );
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty[1] & /*linkClasses*/
        256) && { class: (
          /*linkClasses*/
          ctx2[39]
        ) },
        dirty[1] & /*linkAttrs*/
        128 && /*linkAttrs*/
        ctx2[38]
      ]));
      if (useRouteProps_action && is_function(useRouteProps_action.update) && dirty[0] & /*routeProps*/
      16777216) useRouteProps_action.update.call(
        null,
        /*routeProps*/
        ctx2[24]
      );
    },
    i(local) {
      if (current) return;
      transition_in(content_start_slot, local);
      transition_in(if_block1);
      transition_in(inner_start_slot, local);
      transition_in(if_block2);
      transition_in(inner_end_slot, local);
      transition_in(content_slot, local);
      transition_in(content_end_slot, local);
      current = true;
    },
    o(local) {
      transition_out(content_start_slot, local);
      transition_out(if_block1);
      transition_out(inner_start_slot, local);
      transition_out(if_block2);
      transition_out(inner_end_slot, local);
      transition_out(content_slot, local);
      transition_out(content_end_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(a);
      }
      if (content_start_slot) content_start_slot.d(detaching);
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (inner_start_slot) inner_start_slot.d(detaching);
      if_blocks[current_block_type_index].d();
      if (inner_end_slot) inner_end_slot.d(detaching);
      ctx[77](null);
      if (content_slot) content_slot.d(detaching);
      if (content_end_slot) content_end_slot.d(detaching);
      ctx[78](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_4(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_5, create_else_block_2$1];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*isLink*/
      ctx2[37]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "swipeout-content");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_blocks[current_block_type_index].d();
    }
  };
}
function create_else_block_9(ctx) {
  let div1;
  let t0;
  let t1;
  let t2;
  let div0;
  let t3;
  let current_block_type_index;
  let if_block2;
  let t4;
  let t5;
  let t6;
  let current;
  let mounted;
  let dispose;
  const content_start_slot_template = (
    /*#slots*/
    ctx[69]["content-start"]
  );
  const content_start_slot = create_slot(
    content_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_content_start_slot_context_5
  );
  let if_block0 = (
    /*isSortable*/
    ctx[44] && /*sortable*/
    ctx[14] !== false && /*isSortableOpposite*/
    ctx[43] && create_if_block_128()
  );
  let if_block1 = (
    /*hasMedia*/
    ctx[36] && create_if_block_126(ctx)
  );
  const inner_start_slot_template = (
    /*#slots*/
    ctx[69]["inner-start"]
  );
  const inner_start_slot = create_slot(
    inner_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_start_slot_context_5
  );
  const if_block_creators = [create_if_block_109, create_else_block_10];
  const if_blocks = [];
  function select_block_type_10(ctx2, dirty) {
    if (
      /*isMedia*/
      ctx2[25]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type_10(ctx);
  if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const inner_end_slot_template = (
    /*#slots*/
    ctx[69]["inner-end"]
  );
  const inner_end_slot = create_slot(
    inner_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_end_slot_context_5
  );
  const content_slot_template = (
    /*#slots*/
    ctx[69].content
  );
  const content_slot = create_slot(
    content_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_content_slot_context_5
  );
  const content_end_slot_template = (
    /*#slots*/
    ctx[69]["content-end"]
  );
  const content_end_slot = create_slot(
    content_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_content_end_slot_context_5
  );
  return {
    c() {
      div1 = element("div");
      if (content_start_slot) content_start_slot.c();
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      div0 = element("div");
      if (inner_start_slot) inner_start_slot.c();
      t3 = space();
      if_block2.c();
      t4 = space();
      if (inner_end_slot) inner_end_slot.c();
      t5 = space();
      if (content_slot) content_slot.c();
      t6 = space();
      if (content_end_slot) content_end_slot.c();
      attr(div0, "class", "item-inner");
      attr(
        div1,
        "class",
        /*contentClasses*/
        ctx[40]
      );
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      if (content_start_slot) {
        content_start_slot.m(div1, null);
      }
      append(div1, t0);
      if (if_block0) if_block0.m(div1, null);
      append(div1, t1);
      if (if_block1) if_block1.m(div1, null);
      append(div1, t2);
      append(div1, div0);
      if (inner_start_slot) {
        inner_start_slot.m(div0, null);
      }
      append(div0, t3);
      if_blocks[current_block_type_index].m(div0, null);
      append(div0, t4);
      if (inner_end_slot) {
        inner_end_slot.m(div0, null);
      }
      ctx[81](div0);
      append(div1, t5);
      if (content_slot) {
        content_slot.m(div1, null);
      }
      append(div1, t6);
      if (content_end_slot) {
        content_end_slot.m(div1, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(
          div1,
          "click",
          /*onClick*/
          ctx[45]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (content_start_slot) {
        if (content_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            content_start_slot,
            content_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              content_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_content_start_slot_changes_5
            ),
            get_content_start_slot_context_5
          );
        }
      }
      if (
        /*isSortable*/
        ctx2[44] && /*sortable*/
        ctx2[14] !== false && /*isSortableOpposite*/
        ctx2[43]
      ) {
        if (if_block0) ;
        else {
          if_block0 = create_if_block_128();
          if_block0.c();
          if_block0.m(div1, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*hasMedia*/
        ctx2[36]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasMedia*/
          32) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_126(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (inner_start_slot) {
        if (inner_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_start_slot,
            inner_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_start_slot_changes_5
            ),
            get_inner_start_slot_context_5
          );
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_10(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block2 = if_blocks[current_block_type_index];
        if (!if_block2) {
          if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block2.c();
        } else {
          if_block2.p(ctx2, dirty);
        }
        transition_in(if_block2, 1);
        if_block2.m(div0, t4);
      }
      if (inner_end_slot) {
        if (inner_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_end_slot,
            inner_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_end_slot_changes_5
            ),
            get_inner_end_slot_context_5
          );
        }
      }
      if (content_slot) {
        if (content_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            content_slot,
            content_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              content_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_content_slot_changes_5
            ),
            get_content_slot_context_5
          );
        }
      }
      if (content_end_slot) {
        if (content_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            content_end_slot,
            content_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              content_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_content_end_slot_changes_5
            ),
            get_content_end_slot_context_5
          );
        }
      }
      if (!current || dirty[1] & /*contentClasses*/
      512) {
        attr(
          div1,
          "class",
          /*contentClasses*/
          ctx2[40]
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(content_start_slot, local);
      transition_in(if_block1);
      transition_in(inner_start_slot, local);
      transition_in(if_block2);
      transition_in(inner_end_slot, local);
      transition_in(content_slot, local);
      transition_in(content_end_slot, local);
      current = true;
    },
    o(local) {
      transition_out(content_start_slot, local);
      transition_out(if_block1);
      transition_out(inner_start_slot, local);
      transition_out(if_block2);
      transition_out(inner_end_slot, local);
      transition_out(content_slot, local);
      transition_out(content_end_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (content_start_slot) content_start_slot.d(detaching);
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (inner_start_slot) inner_start_slot.d(detaching);
      if_blocks[current_block_type_index].d();
      if (inner_end_slot) inner_end_slot.d(detaching);
      ctx[81](null);
      if (content_slot) content_slot.d(detaching);
      if (content_end_slot) content_end_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_88(ctx) {
  let label;
  let t0;
  let t1;
  let input;
  let input_value_value;
  let input_type_value;
  let t2;
  let i;
  let i_class_value;
  let t3;
  let t4;
  let div;
  let t5;
  let current_block_type_index;
  let if_block2;
  let t6;
  let t7;
  let t8;
  let current;
  let mounted;
  let dispose;
  const content_start_slot_template = (
    /*#slots*/
    ctx[69]["content-start"]
  );
  const content_start_slot = create_slot(
    content_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_content_start_slot_context_4
  );
  let if_block0 = (
    /*isSortable*/
    ctx[44] && /*sortable*/
    ctx[14] !== false && /*isSortableOpposite*/
    ctx[43] && create_if_block_108()
  );
  let if_block1 = (
    /*hasMedia*/
    ctx[36] && create_if_block_106(ctx)
  );
  const inner_start_slot_template = (
    /*#slots*/
    ctx[69]["inner-start"]
  );
  const inner_start_slot = create_slot(
    inner_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_start_slot_context_4
  );
  const if_block_creators = [create_if_block_89, create_else_block_8];
  const if_blocks = [];
  function select_block_type_9(ctx2, dirty) {
    if (
      /*isMedia*/
      ctx2[25]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type_9(ctx);
  if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const inner_end_slot_template = (
    /*#slots*/
    ctx[69]["inner-end"]
  );
  const inner_end_slot = create_slot(
    inner_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_end_slot_context_4
  );
  const content_slot_template = (
    /*#slots*/
    ctx[69].content
  );
  const content_slot = create_slot(
    content_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_content_slot_context_4
  );
  const content_end_slot_template = (
    /*#slots*/
    ctx[69]["content-end"]
  );
  const content_end_slot = create_slot(
    content_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_content_end_slot_context_4
  );
  return {
    c() {
      label = element("label");
      if (content_start_slot) content_start_slot.c();
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      input = element("input");
      t2 = space();
      i = element("i");
      t3 = space();
      if (if_block1) if_block1.c();
      t4 = space();
      div = element("div");
      if (inner_start_slot) inner_start_slot.c();
      t5 = space();
      if_block2.c();
      t6 = space();
      if (inner_end_slot) inner_end_slot.c();
      t7 = space();
      if (content_slot) content_slot.c();
      t8 = space();
      if (content_end_slot) content_end_slot.c();
      input.value = input_value_value = typeof /*value*/
      ctx[19] === "undefined" ? "" : (
        /*value*/
        ctx[19]
      );
      attr(
        input,
        "name",
        /*name*/
        ctx[18]
      );
      input.checked = /*checked*/
      ctx[0];
      input.readOnly = /*readonly*/
      ctx[20];
      input.disabled = /*disabled*/
      ctx[22];
      input.required = /*required*/
      ctx[21];
      attr(input, "type", input_type_value = /*radio*/
      ctx[17] ? "radio" : "checkbox");
      attr(i, "class", i_class_value = `icon icon-${/*radio*/
      ctx[17] ? "radio" : "checkbox"}`);
      attr(div, "class", "item-inner");
      attr(
        label,
        "class",
        /*contentClasses*/
        ctx[40]
      );
    },
    m(target, anchor) {
      insert(target, label, anchor);
      if (content_start_slot) {
        content_start_slot.m(label, null);
      }
      append(label, t0);
      if (if_block0) if_block0.m(label, null);
      append(label, t1);
      append(label, input);
      ctx[79](input);
      append(label, t2);
      append(label, i);
      append(label, t3);
      if (if_block1) if_block1.m(label, null);
      append(label, t4);
      append(label, div);
      if (inner_start_slot) {
        inner_start_slot.m(div, null);
      }
      append(div, t5);
      if_blocks[current_block_type_index].m(div, null);
      append(div, t6);
      if (inner_end_slot) {
        inner_end_slot.m(div, null);
      }
      ctx[80](div);
      append(label, t7);
      if (content_slot) {
        content_slot.m(label, null);
      }
      append(label, t8);
      if (content_end_slot) {
        content_end_slot.m(label, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input,
            "change",
            /*onChange*/
            ctx[46]
          ),
          listen(
            label,
            "click",
            /*onClick*/
            ctx[45]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (content_start_slot) {
        if (content_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            content_start_slot,
            content_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              content_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_content_start_slot_changes_4
            ),
            get_content_start_slot_context_4
          );
        }
      }
      if (
        /*isSortable*/
        ctx2[44] && /*sortable*/
        ctx2[14] !== false && /*isSortableOpposite*/
        ctx2[43]
      ) {
        if (if_block0) ;
        else {
          if_block0 = create_if_block_108();
          if_block0.c();
          if_block0.m(label, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!current || dirty[0] & /*value*/
      524288 && input_value_value !== (input_value_value = typeof /*value*/
      ctx2[19] === "undefined" ? "" : (
        /*value*/
        ctx2[19]
      )) && input.value !== input_value_value) {
        input.value = input_value_value;
      }
      if (!current || dirty[0] & /*name*/
      262144) {
        attr(
          input,
          "name",
          /*name*/
          ctx2[18]
        );
      }
      if (!current || dirty[0] & /*checked*/
      1) {
        input.checked = /*checked*/
        ctx2[0];
      }
      if (!current || dirty[0] & /*readonly*/
      1048576) {
        input.readOnly = /*readonly*/
        ctx2[20];
      }
      if (!current || dirty[0] & /*disabled*/
      4194304) {
        input.disabled = /*disabled*/
        ctx2[22];
      }
      if (!current || dirty[0] & /*required*/
      2097152) {
        input.required = /*required*/
        ctx2[21];
      }
      if (!current || dirty[0] & /*radio*/
      131072 && input_type_value !== (input_type_value = /*radio*/
      ctx2[17] ? "radio" : "checkbox")) {
        attr(input, "type", input_type_value);
      }
      if (!current || dirty[0] & /*radio*/
      131072 && i_class_value !== (i_class_value = `icon icon-${/*radio*/
      ctx2[17] ? "radio" : "checkbox"}`)) {
        attr(i, "class", i_class_value);
      }
      if (
        /*hasMedia*/
        ctx2[36]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasMedia*/
          32) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_106(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(label, t4);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (inner_start_slot) {
        if (inner_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_start_slot,
            inner_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_start_slot_changes_4
            ),
            get_inner_start_slot_context_4
          );
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_9(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block2 = if_blocks[current_block_type_index];
        if (!if_block2) {
          if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block2.c();
        } else {
          if_block2.p(ctx2, dirty);
        }
        transition_in(if_block2, 1);
        if_block2.m(div, t6);
      }
      if (inner_end_slot) {
        if (inner_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_end_slot,
            inner_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_end_slot_changes_4
            ),
            get_inner_end_slot_context_4
          );
        }
      }
      if (content_slot) {
        if (content_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            content_slot,
            content_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              content_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_content_slot_changes_4
            ),
            get_content_slot_context_4
          );
        }
      }
      if (content_end_slot) {
        if (content_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            content_end_slot,
            content_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              content_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_content_end_slot_changes_4
            ),
            get_content_end_slot_context_4
          );
        }
      }
      if (!current || dirty[1] & /*contentClasses*/
      512) {
        attr(
          label,
          "class",
          /*contentClasses*/
          ctx2[40]
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(content_start_slot, local);
      transition_in(if_block1);
      transition_in(inner_start_slot, local);
      transition_in(if_block2);
      transition_in(inner_end_slot, local);
      transition_in(content_slot, local);
      transition_in(content_end_slot, local);
      current = true;
    },
    o(local) {
      transition_out(content_start_slot, local);
      transition_out(if_block1);
      transition_out(inner_start_slot, local);
      transition_out(if_block2);
      transition_out(inner_end_slot, local);
      transition_out(content_slot, local);
      transition_out(content_end_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(label);
      }
      if (content_start_slot) content_start_slot.d(detaching);
      if (if_block0) if_block0.d();
      ctx[79](null);
      if (if_block1) if_block1.d();
      if (inner_start_slot) inner_start_slot.d(detaching);
      if_blocks[current_block_type_index].d();
      if (inner_end_slot) inner_end_slot.d(detaching);
      ctx[80](null);
      if (content_slot) content_slot.d(detaching);
      if (content_end_slot) content_end_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_128(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "sortable-handler");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block_126(ctx) {
  let div;
  let t2;
  let current;
  let if_block = typeof /*media*/
  ctx[3] !== "undefined" && create_if_block_127(ctx);
  const media_slot_template = (
    /*#slots*/
    ctx[69].media
  );
  const media_slot = create_slot(
    media_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_media_slot_context_5
  );
  return {
    c() {
      div = element("div");
      if (if_block) if_block.c();
      t2 = space();
      if (media_slot) media_slot.c();
      attr(div, "class", "item-media");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block) if_block.m(div, null);
      append(div, t2);
      if (media_slot) {
        media_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (typeof /*media*/
      ctx2[3] !== "undefined") {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_127(ctx2);
          if_block.c();
          if_block.m(div, t2);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (media_slot) {
        if (media_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            media_slot,
            media_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              media_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_media_slot_changes_5
            ),
            get_media_slot_context_5
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(media_slot, local);
      current = true;
    },
    o(local) {
      transition_out(media_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block) if_block.d();
      if (media_slot) media_slot.d(detaching);
    }
  };
}
function create_if_block_127(ctx) {
  let img;
  let img_src_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*media*/
      ctx[3])) attr(img, "src", img_src_value);
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*media*/
      8 && !src_url_equal(img.src, img_src_value = /*media*/
      ctx2[3])) {
        attr(img, "src", img_src_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_else_block_10(ctx) {
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let if_block2_anchor;
  let current;
  const before_title_slot_template = (
    /*#slots*/
    ctx[69]["before-title"]
  );
  const before_title_slot = create_slot(
    before_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_before_title_slot_context_11
  );
  let if_block0 = (
    /*hasTitle*/
    (ctx[35] || /*hasHeader*/
    ctx[34] || /*hasFooter*/
    ctx[33]) && create_if_block_123(ctx)
  );
  const after_title_slot_template = (
    /*#slots*/
    ctx[69]["after-title"]
  );
  const after_title_slot = create_slot(
    after_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_title_slot_context_11
  );
  let if_block1 = (
    /*hasAfter*/
    ctx[30] && create_if_block_120(ctx)
  );
  const inner_slot_template = (
    /*#slots*/
    ctx[69].inner
  );
  const inner_slot = create_slot(
    inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_slot_context_11
  );
  let if_block2 = !/*swipeout*/
  (ctx[13] || /*accordionItem*/
  ctx[15]) && create_if_block_119(ctx);
  return {
    c() {
      if (before_title_slot) before_title_slot.c();
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (after_title_slot) after_title_slot.c();
      t2 = space();
      if (if_block1) if_block1.c();
      t3 = space();
      if (inner_slot) inner_slot.c();
      t4 = space();
      if (if_block2) if_block2.c();
      if_block2_anchor = empty();
    },
    m(target, anchor) {
      if (before_title_slot) {
        before_title_slot.m(target, anchor);
      }
      insert(target, t0, anchor);
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (after_title_slot) {
        after_title_slot.m(target, anchor);
      }
      insert(target, t2, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, t3, anchor);
      if (inner_slot) {
        inner_slot.m(target, anchor);
      }
      insert(target, t4, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (before_title_slot) {
        if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            before_title_slot,
            before_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              before_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_before_title_slot_changes_11
            ),
            get_before_title_slot_context_11
          );
        }
      }
      if (
        /*hasTitle*/
        ctx2[35] || /*hasHeader*/
        ctx2[34] || /*hasFooter*/
        ctx2[33]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/
          28) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_123(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (after_title_slot) {
        if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_title_slot,
            after_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_title_slot_changes_11
            ),
            get_after_title_slot_context_11
          );
        }
      }
      if (
        /*hasAfter*/
        ctx2[30]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*hasAfter*/
          1073741824) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_120(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t3.parentNode, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (inner_slot) {
        if (inner_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_slot,
            inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_slot_changes_11
            ),
            get_inner_slot_context_11
          );
        }
      }
      if (!/*swipeout*/
      (ctx2[13] || /*accordionItem*/
      ctx2[15])) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*swipeout, accordionItem*/
          40960) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_119(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(before_title_slot, local);
      transition_in(if_block0);
      transition_in(after_title_slot, local);
      transition_in(if_block1);
      transition_in(inner_slot, local);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(before_title_slot, local);
      transition_out(if_block0);
      transition_out(after_title_slot, local);
      transition_out(if_block1);
      transition_out(inner_slot, local);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(if_block2_anchor);
      }
      if (before_title_slot) before_title_slot.d(detaching);
      if (if_block0) if_block0.d(detaching);
      if (after_title_slot) after_title_slot.d(detaching);
      if (if_block1) if_block1.d(detaching);
      if (inner_slot) inner_slot.d(detaching);
      if (if_block2) if_block2.d(detaching);
    }
  };
}
function create_if_block_109(ctx) {
  let t0;
  let div;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let t6;
  let t7;
  let t8;
  let if_block6_anchor;
  let current;
  let if_block0 = (
    /*hasHeader*/
    ctx[34] && create_if_block_118(ctx)
  );
  const before_title_slot_template = (
    /*#slots*/
    ctx[69]["before-title"]
  );
  const before_title_slot = create_slot(
    before_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_before_title_slot_context_10
  );
  let if_block1 = (
    /*hasTitle*/
    ctx[35] && create_if_block_117(ctx)
  );
  const after_title_slot_template = (
    /*#slots*/
    ctx[69]["after-title"]
  );
  const after_title_slot = create_slot(
    after_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_title_slot_context_10
  );
  let if_block2 = (
    /*hasAfter*/
    ctx[30] && create_if_block_114(ctx)
  );
  let if_block3 = (
    /*hasSubtitle*/
    ctx[32] && create_if_block_113(ctx)
  );
  let if_block4 = (
    /*hasText*/
    ctx[31] && create_if_block_112(ctx)
  );
  const inner_slot_template = (
    /*#slots*/
    ctx[69].inner
  );
  const inner_slot = create_slot(
    inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_slot_context_10
  );
  let if_block5 = !/*swipeout*/
  (ctx[13] || /*accordionItem*/
  ctx[15]) && create_if_block_111(ctx);
  let if_block6 = (
    /*hasFooter*/
    ctx[33] && create_if_block_110(ctx)
  );
  return {
    c() {
      if (if_block0) if_block0.c();
      t0 = space();
      div = element("div");
      if (before_title_slot) before_title_slot.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      if (after_title_slot) after_title_slot.c();
      t3 = space();
      if (if_block2) if_block2.c();
      t4 = space();
      if (if_block3) if_block3.c();
      t5 = space();
      if (if_block4) if_block4.c();
      t6 = space();
      if (inner_slot) inner_slot.c();
      t7 = space();
      if (if_block5) if_block5.c();
      t8 = space();
      if (if_block6) if_block6.c();
      if_block6_anchor = empty();
      attr(div, "class", "item-title-row");
    },
    m(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, div, anchor);
      if (before_title_slot) {
        before_title_slot.m(div, null);
      }
      append(div, t1);
      if (if_block1) if_block1.m(div, null);
      append(div, t2);
      if (after_title_slot) {
        after_title_slot.m(div, null);
      }
      append(div, t3);
      if (if_block2) if_block2.m(div, null);
      insert(target, t4, anchor);
      if (if_block3) if_block3.m(target, anchor);
      insert(target, t5, anchor);
      if (if_block4) if_block4.m(target, anchor);
      insert(target, t6, anchor);
      if (inner_slot) {
        inner_slot.m(target, anchor);
      }
      insert(target, t7, anchor);
      if (if_block5) if_block5.m(target, anchor);
      insert(target, t8, anchor);
      if (if_block6) if_block6.m(target, anchor);
      insert(target, if_block6_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*hasHeader*/
        ctx2[34]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & /*hasHeader*/
          8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_118(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (before_title_slot) {
        if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            before_title_slot,
            before_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              before_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_before_title_slot_changes_10
            ),
            get_before_title_slot_context_10
          );
        }
      }
      if (
        /*hasTitle*/
        ctx2[35]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasTitle*/
          16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_117(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (after_title_slot) {
        if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_title_slot,
            after_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_title_slot_changes_10
            ),
            get_after_title_slot_context_10
          );
        }
      }
      if (
        /*hasAfter*/
        ctx2[30]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*hasAfter*/
          1073741824) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_114(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*hasSubtitle*/
        ctx2[32]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[1] & /*hasSubtitle*/
          2) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_113(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(t5.parentNode, t5);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (
        /*hasText*/
        ctx2[31]
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[1] & /*hasText*/
          1) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_112(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(t6.parentNode, t6);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (inner_slot) {
        if (inner_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_slot,
            inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_slot_changes_10
            ),
            get_inner_slot_context_10
          );
        }
      }
      if (!/*swipeout*/
      (ctx2[13] || /*accordionItem*/
      ctx2[15])) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty[0] & /*swipeout, accordionItem*/
          40960) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block_111(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(t8.parentNode, t8);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      if (
        /*hasFooter*/
        ctx2[33]
      ) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
          if (dirty[1] & /*hasFooter*/
          4) {
            transition_in(if_block6, 1);
          }
        } else {
          if_block6 = create_if_block_110(ctx2);
          if_block6.c();
          transition_in(if_block6, 1);
          if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
        }
      } else if (if_block6) {
        group_outros();
        transition_out(if_block6, 1, 1, () => {
          if_block6 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(before_title_slot, local);
      transition_in(if_block1);
      transition_in(after_title_slot, local);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(inner_slot, local);
      transition_in(if_block5);
      transition_in(if_block6);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(before_title_slot, local);
      transition_out(if_block1);
      transition_out(after_title_slot, local);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(inner_slot, local);
      transition_out(if_block5);
      transition_out(if_block6);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div);
        detach(t4);
        detach(t5);
        detach(t6);
        detach(t7);
        detach(t8);
        detach(if_block6_anchor);
      }
      if (if_block0) if_block0.d(detaching);
      if (before_title_slot) before_title_slot.d(detaching);
      if (if_block1) if_block1.d();
      if (after_title_slot) after_title_slot.d(detaching);
      if (if_block2) if_block2.d();
      if (if_block3) if_block3.d(detaching);
      if (if_block4) if_block4.d(detaching);
      if (inner_slot) inner_slot.d(detaching);
      if (if_block5) if_block5.d(detaching);
      if (if_block6) if_block6.d(detaching);
    }
  };
}
function create_if_block_123(ctx) {
  let div;
  let t0;
  let t1_value = plainText(
    /*title*/
    ctx[1]
  ) + "";
  let t1;
  let t2;
  let t3;
  let current;
  let if_block0 = (
    /*hasHeader*/
    ctx[34] && create_if_block_125(ctx)
  );
  const title_slot_template = (
    /*#slots*/
    ctx[69].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_title_slot_context_11
  );
  let if_block1 = (
    /*hasFooter*/
    ctx[33] && create_if_block_124(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block0) if_block0.c();
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      if (title_slot) title_slot.c();
      t3 = space();
      if (if_block1) if_block1.c();
      attr(div, "class", "item-title");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0) if_block0.m(div, null);
      append(div, t0);
      append(div, t1);
      append(div, t2);
      if (title_slot) {
        title_slot.m(div, null);
      }
      append(div, t3);
      if (if_block1) if_block1.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*hasHeader*/
        ctx2[34]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & /*hasHeader*/
          8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_125(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if ((!current || dirty[0] & /*title*/
      2) && t1_value !== (t1_value = plainText(
        /*title*/
        ctx2[1]
      ) + "")) set_data(t1, t1_value);
      if (title_slot) {
        if (title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_title_slot_changes_11
            ),
            get_title_slot_context_11
          );
        }
      }
      if (
        /*hasFooter*/
        ctx2[33]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasFooter*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_124(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(title_slot, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(title_slot, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block0) if_block0.d();
      if (title_slot) title_slot.d(detaching);
      if (if_block1) if_block1.d();
    }
  };
}
function create_if_block_125(ctx) {
  let div;
  let t0_value = plainText(
    /*header*/
    ctx[5]
  ) + "";
  let t0;
  let t1;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[69].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_header_slot_context_11
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (header_slot) header_slot.c();
      attr(div, "class", "item-header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (header_slot) {
        header_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*header*/
      32) && t0_value !== (t0_value = plainText(
        /*header*/
        ctx2[5]
      ) + "")) set_data(t0, t0_value);
      if (header_slot) {
        if (header_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_header_slot_changes_11
            ),
            get_header_slot_context_11
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(header_slot, local);
      current = true;
    },
    o(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (header_slot) header_slot.d(detaching);
    }
  };
}
function create_if_block_124(ctx) {
  let div;
  let t0_value = plainText(
    /*footer*/
    ctx[6]
  ) + "";
  let t0;
  let t1;
  let current;
  const footer_slot_template = (
    /*#slots*/
    ctx[69].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_footer_slot_context_11
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (footer_slot) footer_slot.c();
      attr(div, "class", "item-footer");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (footer_slot) {
        footer_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*footer*/
      64) && t0_value !== (t0_value = plainText(
        /*footer*/
        ctx2[6]
      ) + "")) set_data(t0, t0_value);
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_footer_slot_changes_11
            ),
            get_footer_slot_context_11
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(footer_slot, local);
      current = true;
    },
    o(local) {
      transition_out(footer_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (footer_slot) footer_slot.d(detaching);
    }
  };
}
function create_if_block_120(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  let t3;
  let current;
  const after_start_slot_template = (
    /*#slots*/
    ctx[69]["after-start"]
  );
  const after_start_slot = create_slot(
    after_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_start_slot_context_11
  );
  let if_block0 = typeof /*after*/
  ctx[9] !== "undefined" && create_if_block_122(ctx);
  let if_block1 = typeof /*badge*/
  ctx[10] !== "undefined" && create_if_block_121(ctx);
  const after_slot_template = (
    /*#slots*/
    ctx[69].after
  );
  const after_slot = create_slot(
    after_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_slot_context_11
  );
  const after_end_slot_template = (
    /*#slots*/
    ctx[69]["after-end"]
  );
  const after_end_slot = create_slot(
    after_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_end_slot_context_11
  );
  return {
    c() {
      div = element("div");
      if (after_start_slot) after_start_slot.c();
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      if (after_slot) after_slot.c();
      t3 = space();
      if (after_end_slot) after_end_slot.c();
      attr(div, "class", "item-after");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (after_start_slot) {
        after_start_slot.m(div, null);
      }
      append(div, t0);
      if (if_block0) if_block0.m(div, null);
      append(div, t1);
      if (if_block1) if_block1.m(div, null);
      append(div, t2);
      if (after_slot) {
        after_slot.m(div, null);
      }
      append(div, t3);
      if (after_end_slot) {
        after_end_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (after_start_slot) {
        if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_start_slot,
            after_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_start_slot_changes_11
            ),
            get_after_start_slot_context_11
          );
        }
      }
      if (typeof /*after*/
      ctx2[9] !== "undefined") {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_122(ctx2);
          if_block0.c();
          if_block0.m(div, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (typeof /*badge*/
      ctx2[10] !== "undefined") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*badge*/
          1024) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_121(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (after_slot) {
        if (after_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_slot,
            after_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_slot_changes_11
            ),
            get_after_slot_context_11
          );
        }
      }
      if (after_end_slot) {
        if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_end_slot,
            after_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_end_slot_changes_11
            ),
            get_after_end_slot_context_11
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(after_start_slot, local);
      transition_in(if_block1);
      transition_in(after_slot, local);
      transition_in(after_end_slot, local);
      current = true;
    },
    o(local) {
      transition_out(after_start_slot, local);
      transition_out(if_block1);
      transition_out(after_slot, local);
      transition_out(after_end_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (after_start_slot) after_start_slot.d(detaching);
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (after_slot) after_slot.d(detaching);
      if (after_end_slot) after_end_slot.d(detaching);
    }
  };
}
function create_if_block_122(ctx) {
  let span;
  let t_value = plainText(
    /*after*/
    ctx[9]
  ) + "";
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*after*/
      512 && t_value !== (t_value = plainText(
        /*after*/
        ctx2[9]
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_121(ctx) {
  let badge_1;
  let current;
  badge_1 = new Badge({
    props: {
      color: (
        /*badgeColor*/
        ctx[11]
      ),
      $$slots: { default: [create_default_slot_11] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(badge_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(badge_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const badge_1_changes = {};
      if (dirty[0] & /*badgeColor*/
      2048) badge_1_changes.color = /*badgeColor*/
      ctx2[11];
      if (dirty[0] & /*badge*/
      1024 | dirty[2] & /*$$scope*/
      2097152) {
        badge_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      badge_1.$set(badge_1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(badge_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(badge_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(badge_1, detaching);
    }
  };
}
function create_default_slot_11(ctx) {
  let t_value = plainText(
    /*badge*/
    ctx[10]
  ) + "";
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*badge*/
      1024 && t_value !== (t_value = plainText(
        /*badge*/
        ctx2[10]
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_119(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[69].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    null
  );
  return {
    c() {
      if (default_slot) default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function create_if_block_118(ctx) {
  let div;
  let t0_value = plainText(
    /*header*/
    ctx[5]
  ) + "";
  let t0;
  let t1;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[69].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_header_slot_context_10
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (header_slot) header_slot.c();
      attr(div, "class", "item-header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (header_slot) {
        header_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*header*/
      32) && t0_value !== (t0_value = plainText(
        /*header*/
        ctx2[5]
      ) + "")) set_data(t0, t0_value);
      if (header_slot) {
        if (header_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_header_slot_changes_10
            ),
            get_header_slot_context_10
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(header_slot, local);
      current = true;
    },
    o(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (header_slot) header_slot.d(detaching);
    }
  };
}
function create_if_block_117(ctx) {
  let div;
  let t0_value = plainText(
    /*title*/
    ctx[1]
  ) + "";
  let t0;
  let t1;
  let current;
  const title_slot_template = (
    /*#slots*/
    ctx[69].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_title_slot_context_10
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (title_slot) title_slot.c();
      attr(div, "class", "item-title");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (title_slot) {
        title_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*title*/
      2) && t0_value !== (t0_value = plainText(
        /*title*/
        ctx2[1]
      ) + "")) set_data(t0, t0_value);
      if (title_slot) {
        if (title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_title_slot_changes_10
            ),
            get_title_slot_context_10
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(title_slot, local);
      current = true;
    },
    o(local) {
      transition_out(title_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (title_slot) title_slot.d(detaching);
    }
  };
}
function create_if_block_114(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  let t3;
  let current;
  const after_start_slot_template = (
    /*#slots*/
    ctx[69]["after-start"]
  );
  const after_start_slot = create_slot(
    after_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_start_slot_context_10
  );
  let if_block0 = typeof /*after*/
  ctx[9] !== "undefined" && create_if_block_116(ctx);
  let if_block1 = typeof /*badge*/
  ctx[10] !== "undefined" && create_if_block_115(ctx);
  const after_slot_template = (
    /*#slots*/
    ctx[69].after
  );
  const after_slot = create_slot(
    after_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_slot_context_10
  );
  const after_end_slot_template = (
    /*#slots*/
    ctx[69]["after-end"]
  );
  const after_end_slot = create_slot(
    after_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_end_slot_context_10
  );
  return {
    c() {
      div = element("div");
      if (after_start_slot) after_start_slot.c();
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      if (after_slot) after_slot.c();
      t3 = space();
      if (after_end_slot) after_end_slot.c();
      attr(div, "class", "item-after");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (after_start_slot) {
        after_start_slot.m(div, null);
      }
      append(div, t0);
      if (if_block0) if_block0.m(div, null);
      append(div, t1);
      if (if_block1) if_block1.m(div, null);
      append(div, t2);
      if (after_slot) {
        after_slot.m(div, null);
      }
      append(div, t3);
      if (after_end_slot) {
        after_end_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (after_start_slot) {
        if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_start_slot,
            after_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_start_slot_changes_10
            ),
            get_after_start_slot_context_10
          );
        }
      }
      if (typeof /*after*/
      ctx2[9] !== "undefined") {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_116(ctx2);
          if_block0.c();
          if_block0.m(div, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (typeof /*badge*/
      ctx2[10] !== "undefined") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*badge*/
          1024) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_115(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (after_slot) {
        if (after_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_slot,
            after_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_slot_changes_10
            ),
            get_after_slot_context_10
          );
        }
      }
      if (after_end_slot) {
        if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_end_slot,
            after_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_end_slot_changes_10
            ),
            get_after_end_slot_context_10
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(after_start_slot, local);
      transition_in(if_block1);
      transition_in(after_slot, local);
      transition_in(after_end_slot, local);
      current = true;
    },
    o(local) {
      transition_out(after_start_slot, local);
      transition_out(if_block1);
      transition_out(after_slot, local);
      transition_out(after_end_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (after_start_slot) after_start_slot.d(detaching);
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (after_slot) after_slot.d(detaching);
      if (after_end_slot) after_end_slot.d(detaching);
    }
  };
}
function create_if_block_116(ctx) {
  let span;
  let t_value = plainText(
    /*after*/
    ctx[9]
  ) + "";
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*after*/
      512 && t_value !== (t_value = plainText(
        /*after*/
        ctx2[9]
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_115(ctx) {
  let badge_1;
  let current;
  badge_1 = new Badge({
    props: {
      color: (
        /*badgeColor*/
        ctx[11]
      ),
      $$slots: { default: [create_default_slot_10] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(badge_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(badge_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const badge_1_changes = {};
      if (dirty[0] & /*badgeColor*/
      2048) badge_1_changes.color = /*badgeColor*/
      ctx2[11];
      if (dirty[0] & /*badge*/
      1024 | dirty[2] & /*$$scope*/
      2097152) {
        badge_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      badge_1.$set(badge_1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(badge_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(badge_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(badge_1, detaching);
    }
  };
}
function create_default_slot_10(ctx) {
  let t_value = plainText(
    /*badge*/
    ctx[10]
  ) + "";
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*badge*/
      1024 && t_value !== (t_value = plainText(
        /*badge*/
        ctx2[10]
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_113(ctx) {
  let div;
  let t0_value = plainText(
    /*subtitle*/
    ctx[4]
  ) + "";
  let t0;
  let t1;
  let current;
  const subtitle_slot_template = (
    /*#slots*/
    ctx[69].subtitle
  );
  const subtitle_slot = create_slot(
    subtitle_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_subtitle_slot_context_5
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (subtitle_slot) subtitle_slot.c();
      attr(div, "class", "item-subtitle");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (subtitle_slot) {
        subtitle_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*subtitle*/
      16) && t0_value !== (t0_value = plainText(
        /*subtitle*/
        ctx2[4]
      ) + "")) set_data(t0, t0_value);
      if (subtitle_slot) {
        if (subtitle_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            subtitle_slot,
            subtitle_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              subtitle_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_subtitle_slot_changes_5
            ),
            get_subtitle_slot_context_5
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(subtitle_slot, local);
      current = true;
    },
    o(local) {
      transition_out(subtitle_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (subtitle_slot) subtitle_slot.d(detaching);
    }
  };
}
function create_if_block_112(ctx) {
  let div;
  let t0_value = plainText(
    /*text*/
    ctx[2]
  ) + "";
  let t0;
  let t1;
  let current;
  const text_slot_template = (
    /*#slots*/
    ctx[69].text
  );
  const text_slot = create_slot(
    text_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_text_slot_context_5
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (text_slot) text_slot.c();
      attr(div, "class", "item-text");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (text_slot) {
        text_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*text*/
      4) && t0_value !== (t0_value = plainText(
        /*text*/
        ctx2[2]
      ) + "")) set_data(t0, t0_value);
      if (text_slot) {
        if (text_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            text_slot,
            text_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              text_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_text_slot_changes_5
            ),
            get_text_slot_context_5
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(text_slot, local);
      current = true;
    },
    o(local) {
      transition_out(text_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (text_slot) text_slot.d(detaching);
    }
  };
}
function create_if_block_111(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[69].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    null
  );
  return {
    c() {
      if (default_slot) default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function create_if_block_110(ctx) {
  let div;
  let t0_value = plainText(
    /*footer*/
    ctx[6]
  ) + "";
  let t0;
  let t1;
  let current;
  const footer_slot_template = (
    /*#slots*/
    ctx[69].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_footer_slot_context_10
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (footer_slot) footer_slot.c();
      attr(div, "class", "item-footer");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (footer_slot) {
        footer_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*footer*/
      64) && t0_value !== (t0_value = plainText(
        /*footer*/
        ctx2[6]
      ) + "")) set_data(t0, t0_value);
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_footer_slot_changes_10
            ),
            get_footer_slot_context_10
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(footer_slot, local);
      current = true;
    },
    o(local) {
      transition_out(footer_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (footer_slot) footer_slot.d(detaching);
    }
  };
}
function create_if_block_108(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "sortable-handler");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block_106(ctx) {
  let div;
  let t2;
  let current;
  let if_block = typeof /*media*/
  ctx[3] !== "undefined" && create_if_block_107(ctx);
  const media_slot_template = (
    /*#slots*/
    ctx[69].media
  );
  const media_slot = create_slot(
    media_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_media_slot_context_4
  );
  return {
    c() {
      div = element("div");
      if (if_block) if_block.c();
      t2 = space();
      if (media_slot) media_slot.c();
      attr(div, "class", "item-media");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block) if_block.m(div, null);
      append(div, t2);
      if (media_slot) {
        media_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (typeof /*media*/
      ctx2[3] !== "undefined") {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_107(ctx2);
          if_block.c();
          if_block.m(div, t2);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (media_slot) {
        if (media_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            media_slot,
            media_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              media_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_media_slot_changes_4
            ),
            get_media_slot_context_4
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(media_slot, local);
      current = true;
    },
    o(local) {
      transition_out(media_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block) if_block.d();
      if (media_slot) media_slot.d(detaching);
    }
  };
}
function create_if_block_107(ctx) {
  let img;
  let img_src_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*media*/
      ctx[3])) attr(img, "src", img_src_value);
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*media*/
      8 && !src_url_equal(img.src, img_src_value = /*media*/
      ctx2[3])) {
        attr(img, "src", img_src_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_else_block_8(ctx) {
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let if_block2_anchor;
  let current;
  const before_title_slot_template = (
    /*#slots*/
    ctx[69]["before-title"]
  );
  const before_title_slot = create_slot(
    before_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_before_title_slot_context_9
  );
  let if_block0 = (
    /*hasTitle*/
    (ctx[35] || /*hasHeader*/
    ctx[34] || /*hasFooter*/
    ctx[33]) && create_if_block_103(ctx)
  );
  const after_title_slot_template = (
    /*#slots*/
    ctx[69]["after-title"]
  );
  const after_title_slot = create_slot(
    after_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_title_slot_context_9
  );
  let if_block1 = (
    /*hasAfter*/
    ctx[30] && create_if_block_100(ctx)
  );
  const inner_slot_template = (
    /*#slots*/
    ctx[69].inner
  );
  const inner_slot = create_slot(
    inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_slot_context_9
  );
  let if_block2 = !/*swipeout*/
  (ctx[13] || /*accordionItem*/
  ctx[15]) && create_if_block_99(ctx);
  return {
    c() {
      if (before_title_slot) before_title_slot.c();
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (after_title_slot) after_title_slot.c();
      t2 = space();
      if (if_block1) if_block1.c();
      t3 = space();
      if (inner_slot) inner_slot.c();
      t4 = space();
      if (if_block2) if_block2.c();
      if_block2_anchor = empty();
    },
    m(target, anchor) {
      if (before_title_slot) {
        before_title_slot.m(target, anchor);
      }
      insert(target, t0, anchor);
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (after_title_slot) {
        after_title_slot.m(target, anchor);
      }
      insert(target, t2, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, t3, anchor);
      if (inner_slot) {
        inner_slot.m(target, anchor);
      }
      insert(target, t4, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (before_title_slot) {
        if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            before_title_slot,
            before_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              before_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_before_title_slot_changes_9
            ),
            get_before_title_slot_context_9
          );
        }
      }
      if (
        /*hasTitle*/
        ctx2[35] || /*hasHeader*/
        ctx2[34] || /*hasFooter*/
        ctx2[33]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/
          28) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_103(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (after_title_slot) {
        if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_title_slot,
            after_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_title_slot_changes_9
            ),
            get_after_title_slot_context_9
          );
        }
      }
      if (
        /*hasAfter*/
        ctx2[30]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*hasAfter*/
          1073741824) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_100(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t3.parentNode, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (inner_slot) {
        if (inner_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_slot,
            inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_slot_changes_9
            ),
            get_inner_slot_context_9
          );
        }
      }
      if (!/*swipeout*/
      (ctx2[13] || /*accordionItem*/
      ctx2[15])) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*swipeout, accordionItem*/
          40960) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_99(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(before_title_slot, local);
      transition_in(if_block0);
      transition_in(after_title_slot, local);
      transition_in(if_block1);
      transition_in(inner_slot, local);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(before_title_slot, local);
      transition_out(if_block0);
      transition_out(after_title_slot, local);
      transition_out(if_block1);
      transition_out(inner_slot, local);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(if_block2_anchor);
      }
      if (before_title_slot) before_title_slot.d(detaching);
      if (if_block0) if_block0.d(detaching);
      if (after_title_slot) after_title_slot.d(detaching);
      if (if_block1) if_block1.d(detaching);
      if (inner_slot) inner_slot.d(detaching);
      if (if_block2) if_block2.d(detaching);
    }
  };
}
function create_if_block_89(ctx) {
  let t0;
  let div;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let t6;
  let t7;
  let t8;
  let if_block6_anchor;
  let current;
  let if_block0 = (
    /*hasHeader*/
    ctx[34] && create_if_block_98(ctx)
  );
  const before_title_slot_template = (
    /*#slots*/
    ctx[69]["before-title"]
  );
  const before_title_slot = create_slot(
    before_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_before_title_slot_context_8
  );
  let if_block1 = (
    /*hasTitle*/
    ctx[35] && create_if_block_97(ctx)
  );
  const after_title_slot_template = (
    /*#slots*/
    ctx[69]["after-title"]
  );
  const after_title_slot = create_slot(
    after_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_title_slot_context_8
  );
  let if_block2 = (
    /*hasAfter*/
    ctx[30] && create_if_block_94(ctx)
  );
  let if_block3 = (
    /*hasSubtitle*/
    ctx[32] && create_if_block_93(ctx)
  );
  let if_block4 = (
    /*hasText*/
    ctx[31] && create_if_block_92(ctx)
  );
  const inner_slot_template = (
    /*#slots*/
    ctx[69].inner
  );
  const inner_slot = create_slot(
    inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_slot_context_8
  );
  let if_block5 = !/*swipeout*/
  (ctx[13] || /*accordionItem*/
  ctx[15]) && create_if_block_91(ctx);
  let if_block6 = (
    /*hasFooter*/
    ctx[33] && create_if_block_90(ctx)
  );
  return {
    c() {
      if (if_block0) if_block0.c();
      t0 = space();
      div = element("div");
      if (before_title_slot) before_title_slot.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      if (after_title_slot) after_title_slot.c();
      t3 = space();
      if (if_block2) if_block2.c();
      t4 = space();
      if (if_block3) if_block3.c();
      t5 = space();
      if (if_block4) if_block4.c();
      t6 = space();
      if (inner_slot) inner_slot.c();
      t7 = space();
      if (if_block5) if_block5.c();
      t8 = space();
      if (if_block6) if_block6.c();
      if_block6_anchor = empty();
      attr(div, "class", "item-title-row");
    },
    m(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, div, anchor);
      if (before_title_slot) {
        before_title_slot.m(div, null);
      }
      append(div, t1);
      if (if_block1) if_block1.m(div, null);
      append(div, t2);
      if (after_title_slot) {
        after_title_slot.m(div, null);
      }
      append(div, t3);
      if (if_block2) if_block2.m(div, null);
      insert(target, t4, anchor);
      if (if_block3) if_block3.m(target, anchor);
      insert(target, t5, anchor);
      if (if_block4) if_block4.m(target, anchor);
      insert(target, t6, anchor);
      if (inner_slot) {
        inner_slot.m(target, anchor);
      }
      insert(target, t7, anchor);
      if (if_block5) if_block5.m(target, anchor);
      insert(target, t8, anchor);
      if (if_block6) if_block6.m(target, anchor);
      insert(target, if_block6_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*hasHeader*/
        ctx2[34]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & /*hasHeader*/
          8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_98(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (before_title_slot) {
        if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            before_title_slot,
            before_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              before_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_before_title_slot_changes_8
            ),
            get_before_title_slot_context_8
          );
        }
      }
      if (
        /*hasTitle*/
        ctx2[35]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasTitle*/
          16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_97(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (after_title_slot) {
        if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_title_slot,
            after_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_title_slot_changes_8
            ),
            get_after_title_slot_context_8
          );
        }
      }
      if (
        /*hasAfter*/
        ctx2[30]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*hasAfter*/
          1073741824) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_94(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*hasSubtitle*/
        ctx2[32]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[1] & /*hasSubtitle*/
          2) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_93(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(t5.parentNode, t5);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (
        /*hasText*/
        ctx2[31]
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[1] & /*hasText*/
          1) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_92(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(t6.parentNode, t6);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (inner_slot) {
        if (inner_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_slot,
            inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_slot_changes_8
            ),
            get_inner_slot_context_8
          );
        }
      }
      if (!/*swipeout*/
      (ctx2[13] || /*accordionItem*/
      ctx2[15])) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty[0] & /*swipeout, accordionItem*/
          40960) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block_91(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(t8.parentNode, t8);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      if (
        /*hasFooter*/
        ctx2[33]
      ) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
          if (dirty[1] & /*hasFooter*/
          4) {
            transition_in(if_block6, 1);
          }
        } else {
          if_block6 = create_if_block_90(ctx2);
          if_block6.c();
          transition_in(if_block6, 1);
          if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
        }
      } else if (if_block6) {
        group_outros();
        transition_out(if_block6, 1, 1, () => {
          if_block6 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(before_title_slot, local);
      transition_in(if_block1);
      transition_in(after_title_slot, local);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(inner_slot, local);
      transition_in(if_block5);
      transition_in(if_block6);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(before_title_slot, local);
      transition_out(if_block1);
      transition_out(after_title_slot, local);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(inner_slot, local);
      transition_out(if_block5);
      transition_out(if_block6);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div);
        detach(t4);
        detach(t5);
        detach(t6);
        detach(t7);
        detach(t8);
        detach(if_block6_anchor);
      }
      if (if_block0) if_block0.d(detaching);
      if (before_title_slot) before_title_slot.d(detaching);
      if (if_block1) if_block1.d();
      if (after_title_slot) after_title_slot.d(detaching);
      if (if_block2) if_block2.d();
      if (if_block3) if_block3.d(detaching);
      if (if_block4) if_block4.d(detaching);
      if (inner_slot) inner_slot.d(detaching);
      if (if_block5) if_block5.d(detaching);
      if (if_block6) if_block6.d(detaching);
    }
  };
}
function create_if_block_103(ctx) {
  let div;
  let t0;
  let t1_value = plainText(
    /*title*/
    ctx[1]
  ) + "";
  let t1;
  let t2;
  let t3;
  let current;
  let if_block0 = (
    /*hasHeader*/
    ctx[34] && create_if_block_105(ctx)
  );
  const title_slot_template = (
    /*#slots*/
    ctx[69].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_title_slot_context_9
  );
  let if_block1 = (
    /*hasFooter*/
    ctx[33] && create_if_block_104(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block0) if_block0.c();
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      if (title_slot) title_slot.c();
      t3 = space();
      if (if_block1) if_block1.c();
      attr(div, "class", "item-title");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0) if_block0.m(div, null);
      append(div, t0);
      append(div, t1);
      append(div, t2);
      if (title_slot) {
        title_slot.m(div, null);
      }
      append(div, t3);
      if (if_block1) if_block1.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*hasHeader*/
        ctx2[34]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & /*hasHeader*/
          8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_105(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if ((!current || dirty[0] & /*title*/
      2) && t1_value !== (t1_value = plainText(
        /*title*/
        ctx2[1]
      ) + "")) set_data(t1, t1_value);
      if (title_slot) {
        if (title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_title_slot_changes_9
            ),
            get_title_slot_context_9
          );
        }
      }
      if (
        /*hasFooter*/
        ctx2[33]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasFooter*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_104(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(title_slot, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(title_slot, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block0) if_block0.d();
      if (title_slot) title_slot.d(detaching);
      if (if_block1) if_block1.d();
    }
  };
}
function create_if_block_105(ctx) {
  let div;
  let t0_value = plainText(
    /*header*/
    ctx[5]
  ) + "";
  let t0;
  let t1;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[69].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_header_slot_context_9
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (header_slot) header_slot.c();
      attr(div, "class", "item-header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (header_slot) {
        header_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*header*/
      32) && t0_value !== (t0_value = plainText(
        /*header*/
        ctx2[5]
      ) + "")) set_data(t0, t0_value);
      if (header_slot) {
        if (header_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_header_slot_changes_9
            ),
            get_header_slot_context_9
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(header_slot, local);
      current = true;
    },
    o(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (header_slot) header_slot.d(detaching);
    }
  };
}
function create_if_block_104(ctx) {
  let div;
  let t0_value = plainText(
    /*footer*/
    ctx[6]
  ) + "";
  let t0;
  let t1;
  let current;
  const footer_slot_template = (
    /*#slots*/
    ctx[69].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_footer_slot_context_9
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (footer_slot) footer_slot.c();
      attr(div, "class", "item-footer");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (footer_slot) {
        footer_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*footer*/
      64) && t0_value !== (t0_value = plainText(
        /*footer*/
        ctx2[6]
      ) + "")) set_data(t0, t0_value);
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_footer_slot_changes_9
            ),
            get_footer_slot_context_9
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(footer_slot, local);
      current = true;
    },
    o(local) {
      transition_out(footer_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (footer_slot) footer_slot.d(detaching);
    }
  };
}
function create_if_block_100(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  let t3;
  let current;
  const after_start_slot_template = (
    /*#slots*/
    ctx[69]["after-start"]
  );
  const after_start_slot = create_slot(
    after_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_start_slot_context_9
  );
  let if_block0 = typeof /*after*/
  ctx[9] !== "undefined" && create_if_block_102(ctx);
  let if_block1 = typeof /*badge*/
  ctx[10] !== "undefined" && create_if_block_101(ctx);
  const after_slot_template = (
    /*#slots*/
    ctx[69].after
  );
  const after_slot = create_slot(
    after_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_slot_context_9
  );
  const after_end_slot_template = (
    /*#slots*/
    ctx[69]["after-end"]
  );
  const after_end_slot = create_slot(
    after_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_end_slot_context_9
  );
  return {
    c() {
      div = element("div");
      if (after_start_slot) after_start_slot.c();
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      if (after_slot) after_slot.c();
      t3 = space();
      if (after_end_slot) after_end_slot.c();
      attr(div, "class", "item-after");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (after_start_slot) {
        after_start_slot.m(div, null);
      }
      append(div, t0);
      if (if_block0) if_block0.m(div, null);
      append(div, t1);
      if (if_block1) if_block1.m(div, null);
      append(div, t2);
      if (after_slot) {
        after_slot.m(div, null);
      }
      append(div, t3);
      if (after_end_slot) {
        after_end_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (after_start_slot) {
        if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_start_slot,
            after_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_start_slot_changes_9
            ),
            get_after_start_slot_context_9
          );
        }
      }
      if (typeof /*after*/
      ctx2[9] !== "undefined") {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_102(ctx2);
          if_block0.c();
          if_block0.m(div, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (typeof /*badge*/
      ctx2[10] !== "undefined") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*badge*/
          1024) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_101(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (after_slot) {
        if (after_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_slot,
            after_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_slot_changes_9
            ),
            get_after_slot_context_9
          );
        }
      }
      if (after_end_slot) {
        if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_end_slot,
            after_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_end_slot_changes_9
            ),
            get_after_end_slot_context_9
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(after_start_slot, local);
      transition_in(if_block1);
      transition_in(after_slot, local);
      transition_in(after_end_slot, local);
      current = true;
    },
    o(local) {
      transition_out(after_start_slot, local);
      transition_out(if_block1);
      transition_out(after_slot, local);
      transition_out(after_end_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (after_start_slot) after_start_slot.d(detaching);
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (after_slot) after_slot.d(detaching);
      if (after_end_slot) after_end_slot.d(detaching);
    }
  };
}
function create_if_block_102(ctx) {
  let span;
  let t_value = plainText(
    /*after*/
    ctx[9]
  ) + "";
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*after*/
      512 && t_value !== (t_value = plainText(
        /*after*/
        ctx2[9]
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_101(ctx) {
  let badge_1;
  let current;
  badge_1 = new Badge({
    props: {
      color: (
        /*badgeColor*/
        ctx[11]
      ),
      $$slots: { default: [create_default_slot_9] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(badge_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(badge_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const badge_1_changes = {};
      if (dirty[0] & /*badgeColor*/
      2048) badge_1_changes.color = /*badgeColor*/
      ctx2[11];
      if (dirty[0] & /*badge*/
      1024 | dirty[2] & /*$$scope*/
      2097152) {
        badge_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      badge_1.$set(badge_1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(badge_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(badge_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(badge_1, detaching);
    }
  };
}
function create_default_slot_9(ctx) {
  let t_value = plainText(
    /*badge*/
    ctx[10]
  ) + "";
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*badge*/
      1024 && t_value !== (t_value = plainText(
        /*badge*/
        ctx2[10]
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_99(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[69].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    null
  );
  return {
    c() {
      if (default_slot) default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function create_if_block_98(ctx) {
  let div;
  let t0_value = plainText(
    /*header*/
    ctx[5]
  ) + "";
  let t0;
  let t1;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[69].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_header_slot_context_8
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (header_slot) header_slot.c();
      attr(div, "class", "item-header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (header_slot) {
        header_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*header*/
      32) && t0_value !== (t0_value = plainText(
        /*header*/
        ctx2[5]
      ) + "")) set_data(t0, t0_value);
      if (header_slot) {
        if (header_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_header_slot_changes_8
            ),
            get_header_slot_context_8
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(header_slot, local);
      current = true;
    },
    o(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (header_slot) header_slot.d(detaching);
    }
  };
}
function create_if_block_97(ctx) {
  let div;
  let t0_value = plainText(
    /*title*/
    ctx[1]
  ) + "";
  let t0;
  let t1;
  let current;
  const title_slot_template = (
    /*#slots*/
    ctx[69].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_title_slot_context_8
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (title_slot) title_slot.c();
      attr(div, "class", "item-title");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (title_slot) {
        title_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*title*/
      2) && t0_value !== (t0_value = plainText(
        /*title*/
        ctx2[1]
      ) + "")) set_data(t0, t0_value);
      if (title_slot) {
        if (title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_title_slot_changes_8
            ),
            get_title_slot_context_8
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(title_slot, local);
      current = true;
    },
    o(local) {
      transition_out(title_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (title_slot) title_slot.d(detaching);
    }
  };
}
function create_if_block_94(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  let t3;
  let current;
  const after_start_slot_template = (
    /*#slots*/
    ctx[69]["after-start"]
  );
  const after_start_slot = create_slot(
    after_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_start_slot_context_8
  );
  let if_block0 = typeof /*after*/
  ctx[9] !== "undefined" && create_if_block_96(ctx);
  let if_block1 = typeof /*badge*/
  ctx[10] !== "undefined" && create_if_block_95(ctx);
  const after_slot_template = (
    /*#slots*/
    ctx[69].after
  );
  const after_slot = create_slot(
    after_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_slot_context_8
  );
  const after_end_slot_template = (
    /*#slots*/
    ctx[69]["after-end"]
  );
  const after_end_slot = create_slot(
    after_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_end_slot_context_8
  );
  return {
    c() {
      div = element("div");
      if (after_start_slot) after_start_slot.c();
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      if (after_slot) after_slot.c();
      t3 = space();
      if (after_end_slot) after_end_slot.c();
      attr(div, "class", "item-after");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (after_start_slot) {
        after_start_slot.m(div, null);
      }
      append(div, t0);
      if (if_block0) if_block0.m(div, null);
      append(div, t1);
      if (if_block1) if_block1.m(div, null);
      append(div, t2);
      if (after_slot) {
        after_slot.m(div, null);
      }
      append(div, t3);
      if (after_end_slot) {
        after_end_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (after_start_slot) {
        if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_start_slot,
            after_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_start_slot_changes_8
            ),
            get_after_start_slot_context_8
          );
        }
      }
      if (typeof /*after*/
      ctx2[9] !== "undefined") {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_96(ctx2);
          if_block0.c();
          if_block0.m(div, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (typeof /*badge*/
      ctx2[10] !== "undefined") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*badge*/
          1024) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_95(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (after_slot) {
        if (after_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_slot,
            after_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_slot_changes_8
            ),
            get_after_slot_context_8
          );
        }
      }
      if (after_end_slot) {
        if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_end_slot,
            after_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_end_slot_changes_8
            ),
            get_after_end_slot_context_8
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(after_start_slot, local);
      transition_in(if_block1);
      transition_in(after_slot, local);
      transition_in(after_end_slot, local);
      current = true;
    },
    o(local) {
      transition_out(after_start_slot, local);
      transition_out(if_block1);
      transition_out(after_slot, local);
      transition_out(after_end_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (after_start_slot) after_start_slot.d(detaching);
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (after_slot) after_slot.d(detaching);
      if (after_end_slot) after_end_slot.d(detaching);
    }
  };
}
function create_if_block_96(ctx) {
  let span;
  let t_value = plainText(
    /*after*/
    ctx[9]
  ) + "";
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*after*/
      512 && t_value !== (t_value = plainText(
        /*after*/
        ctx2[9]
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_95(ctx) {
  let badge_1;
  let current;
  badge_1 = new Badge({
    props: {
      color: (
        /*badgeColor*/
        ctx[11]
      ),
      $$slots: { default: [create_default_slot_8$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(badge_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(badge_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const badge_1_changes = {};
      if (dirty[0] & /*badgeColor*/
      2048) badge_1_changes.color = /*badgeColor*/
      ctx2[11];
      if (dirty[0] & /*badge*/
      1024 | dirty[2] & /*$$scope*/
      2097152) {
        badge_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      badge_1.$set(badge_1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(badge_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(badge_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(badge_1, detaching);
    }
  };
}
function create_default_slot_8$1(ctx) {
  let t_value = plainText(
    /*badge*/
    ctx[10]
  ) + "";
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*badge*/
      1024 && t_value !== (t_value = plainText(
        /*badge*/
        ctx2[10]
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_93(ctx) {
  let div;
  let t0_value = plainText(
    /*subtitle*/
    ctx[4]
  ) + "";
  let t0;
  let t1;
  let current;
  const subtitle_slot_template = (
    /*#slots*/
    ctx[69].subtitle
  );
  const subtitle_slot = create_slot(
    subtitle_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_subtitle_slot_context_4
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (subtitle_slot) subtitle_slot.c();
      attr(div, "class", "item-subtitle");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (subtitle_slot) {
        subtitle_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*subtitle*/
      16) && t0_value !== (t0_value = plainText(
        /*subtitle*/
        ctx2[4]
      ) + "")) set_data(t0, t0_value);
      if (subtitle_slot) {
        if (subtitle_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            subtitle_slot,
            subtitle_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              subtitle_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_subtitle_slot_changes_4
            ),
            get_subtitle_slot_context_4
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(subtitle_slot, local);
      current = true;
    },
    o(local) {
      transition_out(subtitle_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (subtitle_slot) subtitle_slot.d(detaching);
    }
  };
}
function create_if_block_92(ctx) {
  let div;
  let t0_value = plainText(
    /*text*/
    ctx[2]
  ) + "";
  let t0;
  let t1;
  let current;
  const text_slot_template = (
    /*#slots*/
    ctx[69].text
  );
  const text_slot = create_slot(
    text_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_text_slot_context_4
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (text_slot) text_slot.c();
      attr(div, "class", "item-text");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (text_slot) {
        text_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*text*/
      4) && t0_value !== (t0_value = plainText(
        /*text*/
        ctx2[2]
      ) + "")) set_data(t0, t0_value);
      if (text_slot) {
        if (text_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            text_slot,
            text_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              text_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_text_slot_changes_4
            ),
            get_text_slot_context_4
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(text_slot, local);
      current = true;
    },
    o(local) {
      transition_out(text_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (text_slot) text_slot.d(detaching);
    }
  };
}
function create_if_block_91(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[69].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    null
  );
  return {
    c() {
      if (default_slot) default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function create_if_block_90(ctx) {
  let div;
  let t0_value = plainText(
    /*footer*/
    ctx[6]
  ) + "";
  let t0;
  let t1;
  let current;
  const footer_slot_template = (
    /*#slots*/
    ctx[69].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_footer_slot_context_8
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (footer_slot) footer_slot.c();
      attr(div, "class", "item-footer");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (footer_slot) {
        footer_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*footer*/
      64) && t0_value !== (t0_value = plainText(
        /*footer*/
        ctx2[6]
      ) + "")) set_data(t0, t0_value);
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_footer_slot_changes_8
            ),
            get_footer_slot_context_8
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(footer_slot, local);
      current = true;
    },
    o(local) {
      transition_out(footer_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (footer_slot) footer_slot.d(detaching);
    }
  };
}
function create_if_block_87(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "sortable-handler");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block_85(ctx) {
  let div;
  let t2;
  let current;
  let if_block = typeof /*media*/
  ctx[3] !== "undefined" && create_if_block_86(ctx);
  const media_slot_template = (
    /*#slots*/
    ctx[69].media
  );
  const media_slot = create_slot(
    media_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_media_slot_context_3
  );
  return {
    c() {
      div = element("div");
      if (if_block) if_block.c();
      t2 = space();
      if (media_slot) media_slot.c();
      attr(div, "class", "item-media");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block) if_block.m(div, null);
      append(div, t2);
      if (media_slot) {
        media_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (typeof /*media*/
      ctx2[3] !== "undefined") {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_86(ctx2);
          if_block.c();
          if_block.m(div, t2);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (media_slot) {
        if (media_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            media_slot,
            media_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              media_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_media_slot_changes_3
            ),
            get_media_slot_context_3
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(media_slot, local);
      current = true;
    },
    o(local) {
      transition_out(media_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block) if_block.d();
      if (media_slot) media_slot.d(detaching);
    }
  };
}
function create_if_block_86(ctx) {
  let img;
  let img_src_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*media*/
      ctx[3])) attr(img, "src", img_src_value);
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*media*/
      8 && !src_url_equal(img.src, img_src_value = /*media*/
      ctx2[3])) {
        attr(img, "src", img_src_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_else_block_6(ctx) {
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let if_block2_anchor;
  let current;
  const before_title_slot_template = (
    /*#slots*/
    ctx[69]["before-title"]
  );
  const before_title_slot = create_slot(
    before_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_before_title_slot_context_7
  );
  let if_block0 = (
    /*hasTitle*/
    (ctx[35] || /*hasHeader*/
    ctx[34] || /*hasFooter*/
    ctx[33]) && create_if_block_82(ctx)
  );
  const after_title_slot_template = (
    /*#slots*/
    ctx[69]["after-title"]
  );
  const after_title_slot = create_slot(
    after_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_title_slot_context_7
  );
  let if_block1 = (
    /*hasAfter*/
    ctx[30] && create_if_block_79(ctx)
  );
  const inner_slot_template = (
    /*#slots*/
    ctx[69].inner
  );
  const inner_slot = create_slot(
    inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_slot_context_7
  );
  let if_block2 = !/*swipeout*/
  (ctx[13] || /*accordionItem*/
  ctx[15]) && create_if_block_78(ctx);
  return {
    c() {
      if (before_title_slot) before_title_slot.c();
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (after_title_slot) after_title_slot.c();
      t2 = space();
      if (if_block1) if_block1.c();
      t3 = space();
      if (inner_slot) inner_slot.c();
      t4 = space();
      if (if_block2) if_block2.c();
      if_block2_anchor = empty();
    },
    m(target, anchor) {
      if (before_title_slot) {
        before_title_slot.m(target, anchor);
      }
      insert(target, t0, anchor);
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (after_title_slot) {
        after_title_slot.m(target, anchor);
      }
      insert(target, t2, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, t3, anchor);
      if (inner_slot) {
        inner_slot.m(target, anchor);
      }
      insert(target, t4, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (before_title_slot) {
        if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            before_title_slot,
            before_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              before_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_before_title_slot_changes_7
            ),
            get_before_title_slot_context_7
          );
        }
      }
      if (
        /*hasTitle*/
        ctx2[35] || /*hasHeader*/
        ctx2[34] || /*hasFooter*/
        ctx2[33]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/
          28) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_82(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (after_title_slot) {
        if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_title_slot,
            after_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_title_slot_changes_7
            ),
            get_after_title_slot_context_7
          );
        }
      }
      if (
        /*hasAfter*/
        ctx2[30]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*hasAfter*/
          1073741824) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_79(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t3.parentNode, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (inner_slot) {
        if (inner_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_slot,
            inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_slot_changes_7
            ),
            get_inner_slot_context_7
          );
        }
      }
      if (!/*swipeout*/
      (ctx2[13] || /*accordionItem*/
      ctx2[15])) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*swipeout, accordionItem*/
          40960) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_78(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(before_title_slot, local);
      transition_in(if_block0);
      transition_in(after_title_slot, local);
      transition_in(if_block1);
      transition_in(inner_slot, local);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(before_title_slot, local);
      transition_out(if_block0);
      transition_out(after_title_slot, local);
      transition_out(if_block1);
      transition_out(inner_slot, local);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(if_block2_anchor);
      }
      if (before_title_slot) before_title_slot.d(detaching);
      if (if_block0) if_block0.d(detaching);
      if (after_title_slot) after_title_slot.d(detaching);
      if (if_block1) if_block1.d(detaching);
      if (inner_slot) inner_slot.d(detaching);
      if (if_block2) if_block2.d(detaching);
    }
  };
}
function create_if_block_68(ctx) {
  let t0;
  let div;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let t6;
  let t7;
  let t8;
  let if_block6_anchor;
  let current;
  let if_block0 = (
    /*hasHeader*/
    ctx[34] && create_if_block_77(ctx)
  );
  const before_title_slot_template = (
    /*#slots*/
    ctx[69]["before-title"]
  );
  const before_title_slot = create_slot(
    before_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_before_title_slot_context_6
  );
  let if_block1 = (
    /*hasTitle*/
    ctx[35] && create_if_block_76(ctx)
  );
  const after_title_slot_template = (
    /*#slots*/
    ctx[69]["after-title"]
  );
  const after_title_slot = create_slot(
    after_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_title_slot_context_6
  );
  let if_block2 = (
    /*hasAfter*/
    ctx[30] && create_if_block_73(ctx)
  );
  let if_block3 = (
    /*hasSubtitle*/
    ctx[32] && create_if_block_72(ctx)
  );
  let if_block4 = (
    /*hasText*/
    ctx[31] && create_if_block_71(ctx)
  );
  const inner_slot_template = (
    /*#slots*/
    ctx[69].inner
  );
  const inner_slot = create_slot(
    inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_slot_context_6
  );
  let if_block5 = !/*swipeout*/
  (ctx[13] || /*accordionItem*/
  ctx[15]) && create_if_block_70(ctx);
  let if_block6 = (
    /*hasFooter*/
    ctx[33] && create_if_block_69(ctx)
  );
  return {
    c() {
      if (if_block0) if_block0.c();
      t0 = space();
      div = element("div");
      if (before_title_slot) before_title_slot.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      if (after_title_slot) after_title_slot.c();
      t3 = space();
      if (if_block2) if_block2.c();
      t4 = space();
      if (if_block3) if_block3.c();
      t5 = space();
      if (if_block4) if_block4.c();
      t6 = space();
      if (inner_slot) inner_slot.c();
      t7 = space();
      if (if_block5) if_block5.c();
      t8 = space();
      if (if_block6) if_block6.c();
      if_block6_anchor = empty();
      attr(div, "class", "item-title-row");
    },
    m(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, div, anchor);
      if (before_title_slot) {
        before_title_slot.m(div, null);
      }
      append(div, t1);
      if (if_block1) if_block1.m(div, null);
      append(div, t2);
      if (after_title_slot) {
        after_title_slot.m(div, null);
      }
      append(div, t3);
      if (if_block2) if_block2.m(div, null);
      insert(target, t4, anchor);
      if (if_block3) if_block3.m(target, anchor);
      insert(target, t5, anchor);
      if (if_block4) if_block4.m(target, anchor);
      insert(target, t6, anchor);
      if (inner_slot) {
        inner_slot.m(target, anchor);
      }
      insert(target, t7, anchor);
      if (if_block5) if_block5.m(target, anchor);
      insert(target, t8, anchor);
      if (if_block6) if_block6.m(target, anchor);
      insert(target, if_block6_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*hasHeader*/
        ctx2[34]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & /*hasHeader*/
          8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_77(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (before_title_slot) {
        if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            before_title_slot,
            before_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              before_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_before_title_slot_changes_6
            ),
            get_before_title_slot_context_6
          );
        }
      }
      if (
        /*hasTitle*/
        ctx2[35]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasTitle*/
          16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_76(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (after_title_slot) {
        if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_title_slot,
            after_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_title_slot_changes_6
            ),
            get_after_title_slot_context_6
          );
        }
      }
      if (
        /*hasAfter*/
        ctx2[30]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*hasAfter*/
          1073741824) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_73(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*hasSubtitle*/
        ctx2[32]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[1] & /*hasSubtitle*/
          2) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_72(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(t5.parentNode, t5);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (
        /*hasText*/
        ctx2[31]
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[1] & /*hasText*/
          1) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_71(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(t6.parentNode, t6);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (inner_slot) {
        if (inner_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_slot,
            inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_slot_changes_6
            ),
            get_inner_slot_context_6
          );
        }
      }
      if (!/*swipeout*/
      (ctx2[13] || /*accordionItem*/
      ctx2[15])) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty[0] & /*swipeout, accordionItem*/
          40960) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block_70(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(t8.parentNode, t8);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      if (
        /*hasFooter*/
        ctx2[33]
      ) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
          if (dirty[1] & /*hasFooter*/
          4) {
            transition_in(if_block6, 1);
          }
        } else {
          if_block6 = create_if_block_69(ctx2);
          if_block6.c();
          transition_in(if_block6, 1);
          if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
        }
      } else if (if_block6) {
        group_outros();
        transition_out(if_block6, 1, 1, () => {
          if_block6 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(before_title_slot, local);
      transition_in(if_block1);
      transition_in(after_title_slot, local);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(inner_slot, local);
      transition_in(if_block5);
      transition_in(if_block6);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(before_title_slot, local);
      transition_out(if_block1);
      transition_out(after_title_slot, local);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(inner_slot, local);
      transition_out(if_block5);
      transition_out(if_block6);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div);
        detach(t4);
        detach(t5);
        detach(t6);
        detach(t7);
        detach(t8);
        detach(if_block6_anchor);
      }
      if (if_block0) if_block0.d(detaching);
      if (before_title_slot) before_title_slot.d(detaching);
      if (if_block1) if_block1.d();
      if (after_title_slot) after_title_slot.d(detaching);
      if (if_block2) if_block2.d();
      if (if_block3) if_block3.d(detaching);
      if (if_block4) if_block4.d(detaching);
      if (inner_slot) inner_slot.d(detaching);
      if (if_block5) if_block5.d(detaching);
      if (if_block6) if_block6.d(detaching);
    }
  };
}
function create_if_block_82(ctx) {
  let div;
  let t0;
  let t1_value = plainText(
    /*title*/
    ctx[1]
  ) + "";
  let t1;
  let t2;
  let t3;
  let current;
  let if_block0 = (
    /*hasHeader*/
    ctx[34] && create_if_block_84(ctx)
  );
  const title_slot_template = (
    /*#slots*/
    ctx[69].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_title_slot_context_7
  );
  let if_block1 = (
    /*hasFooter*/
    ctx[33] && create_if_block_83(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block0) if_block0.c();
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      if (title_slot) title_slot.c();
      t3 = space();
      if (if_block1) if_block1.c();
      attr(div, "class", "item-title");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0) if_block0.m(div, null);
      append(div, t0);
      append(div, t1);
      append(div, t2);
      if (title_slot) {
        title_slot.m(div, null);
      }
      append(div, t3);
      if (if_block1) if_block1.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*hasHeader*/
        ctx2[34]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & /*hasHeader*/
          8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_84(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if ((!current || dirty[0] & /*title*/
      2) && t1_value !== (t1_value = plainText(
        /*title*/
        ctx2[1]
      ) + "")) set_data(t1, t1_value);
      if (title_slot) {
        if (title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_title_slot_changes_7
            ),
            get_title_slot_context_7
          );
        }
      }
      if (
        /*hasFooter*/
        ctx2[33]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasFooter*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_83(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(title_slot, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(title_slot, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block0) if_block0.d();
      if (title_slot) title_slot.d(detaching);
      if (if_block1) if_block1.d();
    }
  };
}
function create_if_block_84(ctx) {
  let div;
  let t0_value = plainText(
    /*header*/
    ctx[5]
  ) + "";
  let t0;
  let t1;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[69].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_header_slot_context_7
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (header_slot) header_slot.c();
      attr(div, "class", "item-header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (header_slot) {
        header_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*header*/
      32) && t0_value !== (t0_value = plainText(
        /*header*/
        ctx2[5]
      ) + "")) set_data(t0, t0_value);
      if (header_slot) {
        if (header_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_header_slot_changes_7
            ),
            get_header_slot_context_7
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(header_slot, local);
      current = true;
    },
    o(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (header_slot) header_slot.d(detaching);
    }
  };
}
function create_if_block_83(ctx) {
  let div;
  let t0_value = plainText(
    /*footer*/
    ctx[6]
  ) + "";
  let t0;
  let t1;
  let current;
  const footer_slot_template = (
    /*#slots*/
    ctx[69].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_footer_slot_context_7
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (footer_slot) footer_slot.c();
      attr(div, "class", "item-footer");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (footer_slot) {
        footer_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*footer*/
      64) && t0_value !== (t0_value = plainText(
        /*footer*/
        ctx2[6]
      ) + "")) set_data(t0, t0_value);
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_footer_slot_changes_7
            ),
            get_footer_slot_context_7
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(footer_slot, local);
      current = true;
    },
    o(local) {
      transition_out(footer_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (footer_slot) footer_slot.d(detaching);
    }
  };
}
function create_if_block_79(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  let t3;
  let current;
  const after_start_slot_template = (
    /*#slots*/
    ctx[69]["after-start"]
  );
  const after_start_slot = create_slot(
    after_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_start_slot_context_7
  );
  let if_block0 = typeof /*after*/
  ctx[9] !== "undefined" && create_if_block_81(ctx);
  let if_block1 = typeof /*badge*/
  ctx[10] !== "undefined" && create_if_block_80(ctx);
  const after_slot_template = (
    /*#slots*/
    ctx[69].after
  );
  const after_slot = create_slot(
    after_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_slot_context_7
  );
  const after_end_slot_template = (
    /*#slots*/
    ctx[69]["after-end"]
  );
  const after_end_slot = create_slot(
    after_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_end_slot_context_7
  );
  return {
    c() {
      div = element("div");
      if (after_start_slot) after_start_slot.c();
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      if (after_slot) after_slot.c();
      t3 = space();
      if (after_end_slot) after_end_slot.c();
      attr(div, "class", "item-after");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (after_start_slot) {
        after_start_slot.m(div, null);
      }
      append(div, t0);
      if (if_block0) if_block0.m(div, null);
      append(div, t1);
      if (if_block1) if_block1.m(div, null);
      append(div, t2);
      if (after_slot) {
        after_slot.m(div, null);
      }
      append(div, t3);
      if (after_end_slot) {
        after_end_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (after_start_slot) {
        if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_start_slot,
            after_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_start_slot_changes_7
            ),
            get_after_start_slot_context_7
          );
        }
      }
      if (typeof /*after*/
      ctx2[9] !== "undefined") {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_81(ctx2);
          if_block0.c();
          if_block0.m(div, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (typeof /*badge*/
      ctx2[10] !== "undefined") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*badge*/
          1024) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_80(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (after_slot) {
        if (after_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_slot,
            after_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_slot_changes_7
            ),
            get_after_slot_context_7
          );
        }
      }
      if (after_end_slot) {
        if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_end_slot,
            after_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_end_slot_changes_7
            ),
            get_after_end_slot_context_7
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(after_start_slot, local);
      transition_in(if_block1);
      transition_in(after_slot, local);
      transition_in(after_end_slot, local);
      current = true;
    },
    o(local) {
      transition_out(after_start_slot, local);
      transition_out(if_block1);
      transition_out(after_slot, local);
      transition_out(after_end_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (after_start_slot) after_start_slot.d(detaching);
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (after_slot) after_slot.d(detaching);
      if (after_end_slot) after_end_slot.d(detaching);
    }
  };
}
function create_if_block_81(ctx) {
  let span;
  let t_value = plainText(
    /*after*/
    ctx[9]
  ) + "";
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*after*/
      512 && t_value !== (t_value = plainText(
        /*after*/
        ctx2[9]
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_80(ctx) {
  let badge_1;
  let current;
  badge_1 = new Badge({
    props: {
      color: (
        /*badgeColor*/
        ctx[11]
      ),
      $$slots: { default: [create_default_slot_7$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(badge_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(badge_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const badge_1_changes = {};
      if (dirty[0] & /*badgeColor*/
      2048) badge_1_changes.color = /*badgeColor*/
      ctx2[11];
      if (dirty[0] & /*badge*/
      1024 | dirty[2] & /*$$scope*/
      2097152) {
        badge_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      badge_1.$set(badge_1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(badge_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(badge_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(badge_1, detaching);
    }
  };
}
function create_default_slot_7$1(ctx) {
  let t_value = plainText(
    /*badge*/
    ctx[10]
  ) + "";
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*badge*/
      1024 && t_value !== (t_value = plainText(
        /*badge*/
        ctx2[10]
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_78(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[69].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    null
  );
  return {
    c() {
      if (default_slot) default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function create_if_block_77(ctx) {
  let div;
  let t0_value = plainText(
    /*header*/
    ctx[5]
  ) + "";
  let t0;
  let t1;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[69].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_header_slot_context_6
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (header_slot) header_slot.c();
      attr(div, "class", "item-header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (header_slot) {
        header_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*header*/
      32) && t0_value !== (t0_value = plainText(
        /*header*/
        ctx2[5]
      ) + "")) set_data(t0, t0_value);
      if (header_slot) {
        if (header_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_header_slot_changes_6
            ),
            get_header_slot_context_6
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(header_slot, local);
      current = true;
    },
    o(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (header_slot) header_slot.d(detaching);
    }
  };
}
function create_if_block_76(ctx) {
  let div;
  let t0_value = plainText(
    /*title*/
    ctx[1]
  ) + "";
  let t0;
  let t1;
  let current;
  const title_slot_template = (
    /*#slots*/
    ctx[69].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_title_slot_context_6
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (title_slot) title_slot.c();
      attr(div, "class", "item-title");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (title_slot) {
        title_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*title*/
      2) && t0_value !== (t0_value = plainText(
        /*title*/
        ctx2[1]
      ) + "")) set_data(t0, t0_value);
      if (title_slot) {
        if (title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_title_slot_changes_6
            ),
            get_title_slot_context_6
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(title_slot, local);
      current = true;
    },
    o(local) {
      transition_out(title_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (title_slot) title_slot.d(detaching);
    }
  };
}
function create_if_block_73(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  let t3;
  let current;
  const after_start_slot_template = (
    /*#slots*/
    ctx[69]["after-start"]
  );
  const after_start_slot = create_slot(
    after_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_start_slot_context_6
  );
  let if_block0 = typeof /*after*/
  ctx[9] !== "undefined" && create_if_block_75(ctx);
  let if_block1 = typeof /*badge*/
  ctx[10] !== "undefined" && create_if_block_74(ctx);
  const after_slot_template = (
    /*#slots*/
    ctx[69].after
  );
  const after_slot = create_slot(
    after_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_slot_context_6
  );
  const after_end_slot_template = (
    /*#slots*/
    ctx[69]["after-end"]
  );
  const after_end_slot = create_slot(
    after_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_end_slot_context_6
  );
  return {
    c() {
      div = element("div");
      if (after_start_slot) after_start_slot.c();
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      if (after_slot) after_slot.c();
      t3 = space();
      if (after_end_slot) after_end_slot.c();
      attr(div, "class", "item-after");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (after_start_slot) {
        after_start_slot.m(div, null);
      }
      append(div, t0);
      if (if_block0) if_block0.m(div, null);
      append(div, t1);
      if (if_block1) if_block1.m(div, null);
      append(div, t2);
      if (after_slot) {
        after_slot.m(div, null);
      }
      append(div, t3);
      if (after_end_slot) {
        after_end_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (after_start_slot) {
        if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_start_slot,
            after_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_start_slot_changes_6
            ),
            get_after_start_slot_context_6
          );
        }
      }
      if (typeof /*after*/
      ctx2[9] !== "undefined") {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_75(ctx2);
          if_block0.c();
          if_block0.m(div, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (typeof /*badge*/
      ctx2[10] !== "undefined") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*badge*/
          1024) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_74(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (after_slot) {
        if (after_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_slot,
            after_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_slot_changes_6
            ),
            get_after_slot_context_6
          );
        }
      }
      if (after_end_slot) {
        if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_end_slot,
            after_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_end_slot_changes_6
            ),
            get_after_end_slot_context_6
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(after_start_slot, local);
      transition_in(if_block1);
      transition_in(after_slot, local);
      transition_in(after_end_slot, local);
      current = true;
    },
    o(local) {
      transition_out(after_start_slot, local);
      transition_out(if_block1);
      transition_out(after_slot, local);
      transition_out(after_end_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (after_start_slot) after_start_slot.d(detaching);
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (after_slot) after_slot.d(detaching);
      if (after_end_slot) after_end_slot.d(detaching);
    }
  };
}
function create_if_block_75(ctx) {
  let span;
  let t_value = plainText(
    /*after*/
    ctx[9]
  ) + "";
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*after*/
      512 && t_value !== (t_value = plainText(
        /*after*/
        ctx2[9]
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_74(ctx) {
  let badge_1;
  let current;
  badge_1 = new Badge({
    props: {
      color: (
        /*badgeColor*/
        ctx[11]
      ),
      $$slots: { default: [create_default_slot_6$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(badge_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(badge_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const badge_1_changes = {};
      if (dirty[0] & /*badgeColor*/
      2048) badge_1_changes.color = /*badgeColor*/
      ctx2[11];
      if (dirty[0] & /*badge*/
      1024 | dirty[2] & /*$$scope*/
      2097152) {
        badge_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      badge_1.$set(badge_1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(badge_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(badge_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(badge_1, detaching);
    }
  };
}
function create_default_slot_6$1(ctx) {
  let t_value = plainText(
    /*badge*/
    ctx[10]
  ) + "";
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*badge*/
      1024 && t_value !== (t_value = plainText(
        /*badge*/
        ctx2[10]
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_72(ctx) {
  let div;
  let t0_value = plainText(
    /*subtitle*/
    ctx[4]
  ) + "";
  let t0;
  let t1;
  let current;
  const subtitle_slot_template = (
    /*#slots*/
    ctx[69].subtitle
  );
  const subtitle_slot = create_slot(
    subtitle_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_subtitle_slot_context_3
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (subtitle_slot) subtitle_slot.c();
      attr(div, "class", "item-subtitle");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (subtitle_slot) {
        subtitle_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*subtitle*/
      16) && t0_value !== (t0_value = plainText(
        /*subtitle*/
        ctx2[4]
      ) + "")) set_data(t0, t0_value);
      if (subtitle_slot) {
        if (subtitle_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            subtitle_slot,
            subtitle_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              subtitle_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_subtitle_slot_changes_3
            ),
            get_subtitle_slot_context_3
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(subtitle_slot, local);
      current = true;
    },
    o(local) {
      transition_out(subtitle_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (subtitle_slot) subtitle_slot.d(detaching);
    }
  };
}
function create_if_block_71(ctx) {
  let div;
  let t0_value = plainText(
    /*text*/
    ctx[2]
  ) + "";
  let t0;
  let t1;
  let current;
  const text_slot_template = (
    /*#slots*/
    ctx[69].text
  );
  const text_slot = create_slot(
    text_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_text_slot_context_3
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (text_slot) text_slot.c();
      attr(div, "class", "item-text");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (text_slot) {
        text_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*text*/
      4) && t0_value !== (t0_value = plainText(
        /*text*/
        ctx2[2]
      ) + "")) set_data(t0, t0_value);
      if (text_slot) {
        if (text_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            text_slot,
            text_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              text_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_text_slot_changes_3
            ),
            get_text_slot_context_3
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(text_slot, local);
      current = true;
    },
    o(local) {
      transition_out(text_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (text_slot) text_slot.d(detaching);
    }
  };
}
function create_if_block_70(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[69].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    null
  );
  return {
    c() {
      if (default_slot) default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function create_if_block_69(ctx) {
  let div;
  let t0_value = plainText(
    /*footer*/
    ctx[6]
  ) + "";
  let t0;
  let t1;
  let current;
  const footer_slot_template = (
    /*#slots*/
    ctx[69].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_footer_slot_context_6
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (footer_slot) footer_slot.c();
      attr(div, "class", "item-footer");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (footer_slot) {
        footer_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*footer*/
      64) && t0_value !== (t0_value = plainText(
        /*footer*/
        ctx2[6]
      ) + "")) set_data(t0, t0_value);
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_footer_slot_changes_6
            ),
            get_footer_slot_context_6
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(footer_slot, local);
      current = true;
    },
    o(local) {
      transition_out(footer_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (footer_slot) footer_slot.d(detaching);
    }
  };
}
function create_else_block_2$1(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_26, create_else_block_4];
  const if_blocks = [];
  function select_block_type_4(ctx2, dirty) {
    if (
      /*checkbox*/
      ctx2[16] || /*radio*/
      ctx2[17]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type_4(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_4(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_if_block_5(ctx) {
  let a;
  let div1;
  let t0;
  let t1;
  let t2;
  let div0;
  let t3;
  let current_block_type_index;
  let if_block2;
  let t4;
  let t5;
  let t6;
  let useRouteProps_action;
  let current;
  let mounted;
  let dispose;
  const content_start_slot_template = (
    /*#slots*/
    ctx[69]["content-start"]
  );
  const content_start_slot = create_slot(
    content_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_content_start_slot_context
  );
  let if_block0 = (
    /*isSortable*/
    ctx[44] && /*sortable*/
    ctx[14] !== false && /*isSortableOpposite*/
    ctx[43] && create_if_block_25()
  );
  let if_block1 = (
    /*hasMedia*/
    ctx[36] && create_if_block_23(ctx)
  );
  const inner_start_slot_template = (
    /*#slots*/
    ctx[69]["inner-start"]
  );
  const inner_start_slot = create_slot(
    inner_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_start_slot_context
  );
  const if_block_creators = [create_if_block_6, create_else_block_1$1];
  const if_blocks = [];
  function select_block_type_3(ctx2, dirty) {
    if (
      /*isMedia*/
      ctx2[25]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type_3(ctx);
  if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const inner_end_slot_template = (
    /*#slots*/
    ctx[69]["inner-end"]
  );
  const inner_end_slot = create_slot(
    inner_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_end_slot_context
  );
  const content_slot_template = (
    /*#slots*/
    ctx[69].content
  );
  const content_slot = create_slot(
    content_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_content_slot_context
  );
  const content_end_slot_template = (
    /*#slots*/
    ctx[69]["content-end"]
  );
  const content_end_slot = create_slot(
    content_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_content_end_slot_context
  );
  let a_levels = [
    { class: (
      /*linkClasses*/
      ctx[39]
    ) },
    /*linkAttrs*/
    ctx[38]
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  return {
    c() {
      a = element("a");
      div1 = element("div");
      if (content_start_slot) content_start_slot.c();
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      div0 = element("div");
      if (inner_start_slot) inner_start_slot.c();
      t3 = space();
      if_block2.c();
      t4 = space();
      if (inner_end_slot) inner_end_slot.c();
      t5 = space();
      if (content_slot) content_slot.c();
      t6 = space();
      if (content_end_slot) content_end_slot.c();
      attr(div0, "class", "item-inner");
      attr(
        div1,
        "class",
        /*contentClasses*/
        ctx[40]
      );
      set_attributes(a, a_data);
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, div1);
      if (content_start_slot) {
        content_start_slot.m(div1, null);
      }
      append(div1, t0);
      if (if_block0) if_block0.m(div1, null);
      append(div1, t1);
      if (if_block1) if_block1.m(div1, null);
      append(div1, t2);
      append(div1, div0);
      if (inner_start_slot) {
        inner_start_slot.m(div0, null);
      }
      append(div0, t3);
      if_blocks[current_block_type_index].m(div0, null);
      append(div0, t4);
      if (inner_end_slot) {
        inner_end_slot.m(div0, null);
      }
      ctx[72](div0);
      append(div1, t5);
      if (content_slot) {
        content_slot.m(div1, null);
      }
      append(div1, t6);
      if (content_end_slot) {
        content_end_slot.m(div1, null);
      }
      ctx[73](a);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useRouteProps_action = useRouteProps.call(
            null,
            a,
            /*routeProps*/
            ctx[24]
          )),
          listen(
            a,
            "click",
            /*onClick*/
            ctx[45]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (content_start_slot) {
        if (content_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            content_start_slot,
            content_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              content_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_content_start_slot_changes
            ),
            get_content_start_slot_context
          );
        }
      }
      if (
        /*isSortable*/
        ctx2[44] && /*sortable*/
        ctx2[14] !== false && /*isSortableOpposite*/
        ctx2[43]
      ) {
        if (if_block0) ;
        else {
          if_block0 = create_if_block_25();
          if_block0.c();
          if_block0.m(div1, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*hasMedia*/
        ctx2[36]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasMedia*/
          32) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_23(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (inner_start_slot) {
        if (inner_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_start_slot,
            inner_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_start_slot_changes
            ),
            get_inner_start_slot_context
          );
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_3(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block2 = if_blocks[current_block_type_index];
        if (!if_block2) {
          if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block2.c();
        } else {
          if_block2.p(ctx2, dirty);
        }
        transition_in(if_block2, 1);
        if_block2.m(div0, t4);
      }
      if (inner_end_slot) {
        if (inner_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_end_slot,
            inner_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_end_slot_changes
            ),
            get_inner_end_slot_context
          );
        }
      }
      if (content_slot) {
        if (content_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            content_slot,
            content_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              content_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_content_slot_changes
            ),
            get_content_slot_context
          );
        }
      }
      if (content_end_slot) {
        if (content_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            content_end_slot,
            content_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              content_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_content_end_slot_changes
            ),
            get_content_end_slot_context
          );
        }
      }
      if (!current || dirty[1] & /*contentClasses*/
      512) {
        attr(
          div1,
          "class",
          /*contentClasses*/
          ctx2[40]
        );
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty[1] & /*linkClasses*/
        256) && { class: (
          /*linkClasses*/
          ctx2[39]
        ) },
        dirty[1] & /*linkAttrs*/
        128 && /*linkAttrs*/
        ctx2[38]
      ]));
      if (useRouteProps_action && is_function(useRouteProps_action.update) && dirty[0] & /*routeProps*/
      16777216) useRouteProps_action.update.call(
        null,
        /*routeProps*/
        ctx2[24]
      );
    },
    i(local) {
      if (current) return;
      transition_in(content_start_slot, local);
      transition_in(if_block1);
      transition_in(inner_start_slot, local);
      transition_in(if_block2);
      transition_in(inner_end_slot, local);
      transition_in(content_slot, local);
      transition_in(content_end_slot, local);
      current = true;
    },
    o(local) {
      transition_out(content_start_slot, local);
      transition_out(if_block1);
      transition_out(inner_start_slot, local);
      transition_out(if_block2);
      transition_out(inner_end_slot, local);
      transition_out(content_slot, local);
      transition_out(content_end_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(a);
      }
      if (content_start_slot) content_start_slot.d(detaching);
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (inner_start_slot) inner_start_slot.d(detaching);
      if_blocks[current_block_type_index].d();
      if (inner_end_slot) inner_end_slot.d(detaching);
      ctx[72](null);
      if (content_slot) content_slot.d(detaching);
      if (content_end_slot) content_end_slot.d(detaching);
      ctx[73](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_else_block_4(ctx) {
  let div1;
  let t0;
  let t1;
  let t2;
  let div0;
  let t3;
  let current_block_type_index;
  let if_block2;
  let t4;
  let t5;
  let t6;
  let current;
  let mounted;
  let dispose;
  const content_start_slot_template = (
    /*#slots*/
    ctx[69]["content-start"]
  );
  const content_start_slot = create_slot(
    content_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_content_start_slot_context_2
  );
  let if_block0 = (
    /*isSortable*/
    ctx[44] && /*sortable*/
    ctx[14] !== false && /*isSortableOpposite*/
    ctx[43] && create_if_block_66()
  );
  let if_block1 = (
    /*hasMedia*/
    ctx[36] && create_if_block_64(ctx)
  );
  const inner_start_slot_template = (
    /*#slots*/
    ctx[69]["inner-start"]
  );
  const inner_start_slot = create_slot(
    inner_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_start_slot_context_2
  );
  const if_block_creators = [create_if_block_47, create_else_block_5];
  const if_blocks = [];
  function select_block_type_6(ctx2, dirty) {
    if (
      /*isMedia*/
      ctx2[25]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type_6(ctx);
  if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const inner_end_slot_template = (
    /*#slots*/
    ctx[69]["inner-end"]
  );
  const inner_end_slot = create_slot(
    inner_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_end_slot_context_2
  );
  const content_slot_template = (
    /*#slots*/
    ctx[69].content
  );
  const content_slot = create_slot(
    content_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_content_slot_context_2
  );
  const content_end_slot_template = (
    /*#slots*/
    ctx[69]["content-end"]
  );
  const content_end_slot = create_slot(
    content_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_content_end_slot_context_2
  );
  return {
    c() {
      div1 = element("div");
      if (content_start_slot) content_start_slot.c();
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      div0 = element("div");
      if (inner_start_slot) inner_start_slot.c();
      t3 = space();
      if_block2.c();
      t4 = space();
      if (inner_end_slot) inner_end_slot.c();
      t5 = space();
      if (content_slot) content_slot.c();
      t6 = space();
      if (content_end_slot) content_end_slot.c();
      attr(div0, "class", "item-inner");
      attr(
        div1,
        "class",
        /*contentClasses*/
        ctx[40]
      );
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      if (content_start_slot) {
        content_start_slot.m(div1, null);
      }
      append(div1, t0);
      if (if_block0) if_block0.m(div1, null);
      append(div1, t1);
      if (if_block1) if_block1.m(div1, null);
      append(div1, t2);
      append(div1, div0);
      if (inner_start_slot) {
        inner_start_slot.m(div0, null);
      }
      append(div0, t3);
      if_blocks[current_block_type_index].m(div0, null);
      append(div0, t4);
      if (inner_end_slot) {
        inner_end_slot.m(div0, null);
      }
      ctx[76](div0);
      append(div1, t5);
      if (content_slot) {
        content_slot.m(div1, null);
      }
      append(div1, t6);
      if (content_end_slot) {
        content_end_slot.m(div1, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(
          div1,
          "click",
          /*onClick*/
          ctx[45]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (content_start_slot) {
        if (content_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            content_start_slot,
            content_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              content_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_content_start_slot_changes_2
            ),
            get_content_start_slot_context_2
          );
        }
      }
      if (
        /*isSortable*/
        ctx2[44] && /*sortable*/
        ctx2[14] !== false && /*isSortableOpposite*/
        ctx2[43]
      ) {
        if (if_block0) ;
        else {
          if_block0 = create_if_block_66();
          if_block0.c();
          if_block0.m(div1, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*hasMedia*/
        ctx2[36]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasMedia*/
          32) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_64(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (inner_start_slot) {
        if (inner_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_start_slot,
            inner_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_start_slot_changes_2
            ),
            get_inner_start_slot_context_2
          );
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_6(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block2 = if_blocks[current_block_type_index];
        if (!if_block2) {
          if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block2.c();
        } else {
          if_block2.p(ctx2, dirty);
        }
        transition_in(if_block2, 1);
        if_block2.m(div0, t4);
      }
      if (inner_end_slot) {
        if (inner_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_end_slot,
            inner_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_end_slot_changes_2
            ),
            get_inner_end_slot_context_2
          );
        }
      }
      if (content_slot) {
        if (content_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            content_slot,
            content_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              content_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_content_slot_changes_2
            ),
            get_content_slot_context_2
          );
        }
      }
      if (content_end_slot) {
        if (content_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            content_end_slot,
            content_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              content_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_content_end_slot_changes_2
            ),
            get_content_end_slot_context_2
          );
        }
      }
      if (!current || dirty[1] & /*contentClasses*/
      512) {
        attr(
          div1,
          "class",
          /*contentClasses*/
          ctx2[40]
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(content_start_slot, local);
      transition_in(if_block1);
      transition_in(inner_start_slot, local);
      transition_in(if_block2);
      transition_in(inner_end_slot, local);
      transition_in(content_slot, local);
      transition_in(content_end_slot, local);
      current = true;
    },
    o(local) {
      transition_out(content_start_slot, local);
      transition_out(if_block1);
      transition_out(inner_start_slot, local);
      transition_out(if_block2);
      transition_out(inner_end_slot, local);
      transition_out(content_slot, local);
      transition_out(content_end_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (content_start_slot) content_start_slot.d(detaching);
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (inner_start_slot) inner_start_slot.d(detaching);
      if_blocks[current_block_type_index].d();
      if (inner_end_slot) inner_end_slot.d(detaching);
      ctx[76](null);
      if (content_slot) content_slot.d(detaching);
      if (content_end_slot) content_end_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_26(ctx) {
  let label;
  let t0;
  let t1;
  let input;
  let input_value_value;
  let input_type_value;
  let t2;
  let i;
  let i_class_value;
  let t3;
  let t4;
  let div;
  let t5;
  let current_block_type_index;
  let if_block2;
  let t6;
  let t7;
  let t8;
  let current;
  let mounted;
  let dispose;
  const content_start_slot_template = (
    /*#slots*/
    ctx[69]["content-start"]
  );
  const content_start_slot = create_slot(
    content_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_content_start_slot_context_1
  );
  let if_block0 = (
    /*isSortable*/
    ctx[44] && /*sortable*/
    ctx[14] !== false && /*isSortableOpposite*/
    ctx[43] && create_if_block_46()
  );
  let if_block1 = (
    /*hasMedia*/
    ctx[36] && create_if_block_44(ctx)
  );
  const inner_start_slot_template = (
    /*#slots*/
    ctx[69]["inner-start"]
  );
  const inner_start_slot = create_slot(
    inner_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_start_slot_context_1
  );
  const if_block_creators = [create_if_block_27, create_else_block_3];
  const if_blocks = [];
  function select_block_type_5(ctx2, dirty) {
    if (
      /*isMedia*/
      ctx2[25]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type_5(ctx);
  if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const inner_end_slot_template = (
    /*#slots*/
    ctx[69]["inner-end"]
  );
  const inner_end_slot = create_slot(
    inner_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_end_slot_context_1
  );
  const content_slot_template = (
    /*#slots*/
    ctx[69].content
  );
  const content_slot = create_slot(
    content_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_content_slot_context_1
  );
  const content_end_slot_template = (
    /*#slots*/
    ctx[69]["content-end"]
  );
  const content_end_slot = create_slot(
    content_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_content_end_slot_context_1
  );
  return {
    c() {
      label = element("label");
      if (content_start_slot) content_start_slot.c();
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      input = element("input");
      t2 = space();
      i = element("i");
      t3 = space();
      if (if_block1) if_block1.c();
      t4 = space();
      div = element("div");
      if (inner_start_slot) inner_start_slot.c();
      t5 = space();
      if_block2.c();
      t6 = space();
      if (inner_end_slot) inner_end_slot.c();
      t7 = space();
      if (content_slot) content_slot.c();
      t8 = space();
      if (content_end_slot) content_end_slot.c();
      input.value = input_value_value = typeof /*value*/
      ctx[19] === "undefined" ? "" : (
        /*value*/
        ctx[19]
      );
      attr(
        input,
        "name",
        /*name*/
        ctx[18]
      );
      input.checked = /*checked*/
      ctx[0];
      input.readOnly = /*readonly*/
      ctx[20];
      input.disabled = /*disabled*/
      ctx[22];
      input.required = /*required*/
      ctx[21];
      attr(input, "type", input_type_value = /*radio*/
      ctx[17] ? "radio" : "checkbox");
      attr(i, "class", i_class_value = `icon icon-${/*radio*/
      ctx[17] ? "radio" : "checkbox"}`);
      attr(div, "class", "item-inner");
      attr(
        label,
        "class",
        /*contentClasses*/
        ctx[40]
      );
    },
    m(target, anchor) {
      insert(target, label, anchor);
      if (content_start_slot) {
        content_start_slot.m(label, null);
      }
      append(label, t0);
      if (if_block0) if_block0.m(label, null);
      append(label, t1);
      append(label, input);
      ctx[74](input);
      append(label, t2);
      append(label, i);
      append(label, t3);
      if (if_block1) if_block1.m(label, null);
      append(label, t4);
      append(label, div);
      if (inner_start_slot) {
        inner_start_slot.m(div, null);
      }
      append(div, t5);
      if_blocks[current_block_type_index].m(div, null);
      append(div, t6);
      if (inner_end_slot) {
        inner_end_slot.m(div, null);
      }
      ctx[75](div);
      append(label, t7);
      if (content_slot) {
        content_slot.m(label, null);
      }
      append(label, t8);
      if (content_end_slot) {
        content_end_slot.m(label, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input,
            "change",
            /*onChange*/
            ctx[46]
          ),
          listen(
            label,
            "click",
            /*onClick*/
            ctx[45]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (content_start_slot) {
        if (content_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            content_start_slot,
            content_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              content_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_content_start_slot_changes_1
            ),
            get_content_start_slot_context_1
          );
        }
      }
      if (
        /*isSortable*/
        ctx2[44] && /*sortable*/
        ctx2[14] !== false && /*isSortableOpposite*/
        ctx2[43]
      ) {
        if (if_block0) ;
        else {
          if_block0 = create_if_block_46();
          if_block0.c();
          if_block0.m(label, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!current || dirty[0] & /*value*/
      524288 && input_value_value !== (input_value_value = typeof /*value*/
      ctx2[19] === "undefined" ? "" : (
        /*value*/
        ctx2[19]
      )) && input.value !== input_value_value) {
        input.value = input_value_value;
      }
      if (!current || dirty[0] & /*name*/
      262144) {
        attr(
          input,
          "name",
          /*name*/
          ctx2[18]
        );
      }
      if (!current || dirty[0] & /*checked*/
      1) {
        input.checked = /*checked*/
        ctx2[0];
      }
      if (!current || dirty[0] & /*readonly*/
      1048576) {
        input.readOnly = /*readonly*/
        ctx2[20];
      }
      if (!current || dirty[0] & /*disabled*/
      4194304) {
        input.disabled = /*disabled*/
        ctx2[22];
      }
      if (!current || dirty[0] & /*required*/
      2097152) {
        input.required = /*required*/
        ctx2[21];
      }
      if (!current || dirty[0] & /*radio*/
      131072 && input_type_value !== (input_type_value = /*radio*/
      ctx2[17] ? "radio" : "checkbox")) {
        attr(input, "type", input_type_value);
      }
      if (!current || dirty[0] & /*radio*/
      131072 && i_class_value !== (i_class_value = `icon icon-${/*radio*/
      ctx2[17] ? "radio" : "checkbox"}`)) {
        attr(i, "class", i_class_value);
      }
      if (
        /*hasMedia*/
        ctx2[36]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasMedia*/
          32) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_44(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(label, t4);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (inner_start_slot) {
        if (inner_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_start_slot,
            inner_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_start_slot_changes_1
            ),
            get_inner_start_slot_context_1
          );
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_5(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block2 = if_blocks[current_block_type_index];
        if (!if_block2) {
          if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block2.c();
        } else {
          if_block2.p(ctx2, dirty);
        }
        transition_in(if_block2, 1);
        if_block2.m(div, t6);
      }
      if (inner_end_slot) {
        if (inner_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_end_slot,
            inner_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_end_slot_changes_1
            ),
            get_inner_end_slot_context_1
          );
        }
      }
      if (content_slot) {
        if (content_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            content_slot,
            content_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              content_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_content_slot_changes_1
            ),
            get_content_slot_context_1
          );
        }
      }
      if (content_end_slot) {
        if (content_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            content_end_slot,
            content_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              content_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_content_end_slot_changes_1
            ),
            get_content_end_slot_context_1
          );
        }
      }
      if (!current || dirty[1] & /*contentClasses*/
      512) {
        attr(
          label,
          "class",
          /*contentClasses*/
          ctx2[40]
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(content_start_slot, local);
      transition_in(if_block1);
      transition_in(inner_start_slot, local);
      transition_in(if_block2);
      transition_in(inner_end_slot, local);
      transition_in(content_slot, local);
      transition_in(content_end_slot, local);
      current = true;
    },
    o(local) {
      transition_out(content_start_slot, local);
      transition_out(if_block1);
      transition_out(inner_start_slot, local);
      transition_out(if_block2);
      transition_out(inner_end_slot, local);
      transition_out(content_slot, local);
      transition_out(content_end_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(label);
      }
      if (content_start_slot) content_start_slot.d(detaching);
      if (if_block0) if_block0.d();
      ctx[74](null);
      if (if_block1) if_block1.d();
      if (inner_start_slot) inner_start_slot.d(detaching);
      if_blocks[current_block_type_index].d();
      if (inner_end_slot) inner_end_slot.d(detaching);
      ctx[75](null);
      if (content_slot) content_slot.d(detaching);
      if (content_end_slot) content_end_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_66(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "sortable-handler");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block_64(ctx) {
  let div;
  let t2;
  let current;
  let if_block = typeof /*media*/
  ctx[3] !== "undefined" && create_if_block_65(ctx);
  const media_slot_template = (
    /*#slots*/
    ctx[69].media
  );
  const media_slot = create_slot(
    media_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_media_slot_context_2
  );
  return {
    c() {
      div = element("div");
      if (if_block) if_block.c();
      t2 = space();
      if (media_slot) media_slot.c();
      attr(div, "class", "item-media");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block) if_block.m(div, null);
      append(div, t2);
      if (media_slot) {
        media_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (typeof /*media*/
      ctx2[3] !== "undefined") {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_65(ctx2);
          if_block.c();
          if_block.m(div, t2);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (media_slot) {
        if (media_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            media_slot,
            media_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              media_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_media_slot_changes_2
            ),
            get_media_slot_context_2
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(media_slot, local);
      current = true;
    },
    o(local) {
      transition_out(media_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block) if_block.d();
      if (media_slot) media_slot.d(detaching);
    }
  };
}
function create_if_block_65(ctx) {
  let img;
  let img_src_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*media*/
      ctx[3])) attr(img, "src", img_src_value);
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*media*/
      8 && !src_url_equal(img.src, img_src_value = /*media*/
      ctx2[3])) {
        attr(img, "src", img_src_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_else_block_5(ctx) {
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let if_block2_anchor;
  let current;
  const before_title_slot_template = (
    /*#slots*/
    ctx[69]["before-title"]
  );
  const before_title_slot = create_slot(
    before_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_before_title_slot_context_5
  );
  let if_block0 = (
    /*hasTitle*/
    (ctx[35] || /*hasHeader*/
    ctx[34] || /*hasFooter*/
    ctx[33]) && create_if_block_61(ctx)
  );
  const after_title_slot_template = (
    /*#slots*/
    ctx[69]["after-title"]
  );
  const after_title_slot = create_slot(
    after_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_title_slot_context_5
  );
  let if_block1 = (
    /*hasAfter*/
    ctx[30] && create_if_block_58(ctx)
  );
  const inner_slot_template = (
    /*#slots*/
    ctx[69].inner
  );
  const inner_slot = create_slot(
    inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_slot_context_5
  );
  let if_block2 = !/*swipeout*/
  (ctx[13] || /*accordionItem*/
  ctx[15]) && create_if_block_57(ctx);
  return {
    c() {
      if (before_title_slot) before_title_slot.c();
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (after_title_slot) after_title_slot.c();
      t2 = space();
      if (if_block1) if_block1.c();
      t3 = space();
      if (inner_slot) inner_slot.c();
      t4 = space();
      if (if_block2) if_block2.c();
      if_block2_anchor = empty();
    },
    m(target, anchor) {
      if (before_title_slot) {
        before_title_slot.m(target, anchor);
      }
      insert(target, t0, anchor);
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (after_title_slot) {
        after_title_slot.m(target, anchor);
      }
      insert(target, t2, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, t3, anchor);
      if (inner_slot) {
        inner_slot.m(target, anchor);
      }
      insert(target, t4, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (before_title_slot) {
        if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            before_title_slot,
            before_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              before_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_before_title_slot_changes_5
            ),
            get_before_title_slot_context_5
          );
        }
      }
      if (
        /*hasTitle*/
        ctx2[35] || /*hasHeader*/
        ctx2[34] || /*hasFooter*/
        ctx2[33]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/
          28) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_61(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (after_title_slot) {
        if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_title_slot,
            after_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_title_slot_changes_5
            ),
            get_after_title_slot_context_5
          );
        }
      }
      if (
        /*hasAfter*/
        ctx2[30]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*hasAfter*/
          1073741824) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_58(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t3.parentNode, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (inner_slot) {
        if (inner_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_slot,
            inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_slot_changes_5
            ),
            get_inner_slot_context_5
          );
        }
      }
      if (!/*swipeout*/
      (ctx2[13] || /*accordionItem*/
      ctx2[15])) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*swipeout, accordionItem*/
          40960) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_57(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(before_title_slot, local);
      transition_in(if_block0);
      transition_in(after_title_slot, local);
      transition_in(if_block1);
      transition_in(inner_slot, local);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(before_title_slot, local);
      transition_out(if_block0);
      transition_out(after_title_slot, local);
      transition_out(if_block1);
      transition_out(inner_slot, local);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(if_block2_anchor);
      }
      if (before_title_slot) before_title_slot.d(detaching);
      if (if_block0) if_block0.d(detaching);
      if (after_title_slot) after_title_slot.d(detaching);
      if (if_block1) if_block1.d(detaching);
      if (inner_slot) inner_slot.d(detaching);
      if (if_block2) if_block2.d(detaching);
    }
  };
}
function create_if_block_47(ctx) {
  let t0;
  let div;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let t6;
  let t7;
  let t8;
  let if_block6_anchor;
  let current;
  let if_block0 = (
    /*hasHeader*/
    ctx[34] && create_if_block_56(ctx)
  );
  const before_title_slot_template = (
    /*#slots*/
    ctx[69]["before-title"]
  );
  const before_title_slot = create_slot(
    before_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_before_title_slot_context_4
  );
  let if_block1 = (
    /*hasTitle*/
    ctx[35] && create_if_block_55(ctx)
  );
  const after_title_slot_template = (
    /*#slots*/
    ctx[69]["after-title"]
  );
  const after_title_slot = create_slot(
    after_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_title_slot_context_4
  );
  let if_block2 = (
    /*hasAfter*/
    ctx[30] && create_if_block_52(ctx)
  );
  let if_block3 = (
    /*hasSubtitle*/
    ctx[32] && create_if_block_51(ctx)
  );
  let if_block4 = (
    /*hasText*/
    ctx[31] && create_if_block_50(ctx)
  );
  const inner_slot_template = (
    /*#slots*/
    ctx[69].inner
  );
  const inner_slot = create_slot(
    inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_slot_context_4
  );
  let if_block5 = !/*swipeout*/
  (ctx[13] || /*accordionItem*/
  ctx[15]) && create_if_block_49(ctx);
  let if_block6 = (
    /*hasFooter*/
    ctx[33] && create_if_block_48(ctx)
  );
  return {
    c() {
      if (if_block0) if_block0.c();
      t0 = space();
      div = element("div");
      if (before_title_slot) before_title_slot.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      if (after_title_slot) after_title_slot.c();
      t3 = space();
      if (if_block2) if_block2.c();
      t4 = space();
      if (if_block3) if_block3.c();
      t5 = space();
      if (if_block4) if_block4.c();
      t6 = space();
      if (inner_slot) inner_slot.c();
      t7 = space();
      if (if_block5) if_block5.c();
      t8 = space();
      if (if_block6) if_block6.c();
      if_block6_anchor = empty();
      attr(div, "class", "item-title-row");
    },
    m(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, div, anchor);
      if (before_title_slot) {
        before_title_slot.m(div, null);
      }
      append(div, t1);
      if (if_block1) if_block1.m(div, null);
      append(div, t2);
      if (after_title_slot) {
        after_title_slot.m(div, null);
      }
      append(div, t3);
      if (if_block2) if_block2.m(div, null);
      insert(target, t4, anchor);
      if (if_block3) if_block3.m(target, anchor);
      insert(target, t5, anchor);
      if (if_block4) if_block4.m(target, anchor);
      insert(target, t6, anchor);
      if (inner_slot) {
        inner_slot.m(target, anchor);
      }
      insert(target, t7, anchor);
      if (if_block5) if_block5.m(target, anchor);
      insert(target, t8, anchor);
      if (if_block6) if_block6.m(target, anchor);
      insert(target, if_block6_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*hasHeader*/
        ctx2[34]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & /*hasHeader*/
          8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_56(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (before_title_slot) {
        if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            before_title_slot,
            before_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              before_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_before_title_slot_changes_4
            ),
            get_before_title_slot_context_4
          );
        }
      }
      if (
        /*hasTitle*/
        ctx2[35]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasTitle*/
          16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_55(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (after_title_slot) {
        if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_title_slot,
            after_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_title_slot_changes_4
            ),
            get_after_title_slot_context_4
          );
        }
      }
      if (
        /*hasAfter*/
        ctx2[30]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*hasAfter*/
          1073741824) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_52(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*hasSubtitle*/
        ctx2[32]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[1] & /*hasSubtitle*/
          2) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_51(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(t5.parentNode, t5);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (
        /*hasText*/
        ctx2[31]
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[1] & /*hasText*/
          1) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_50(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(t6.parentNode, t6);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (inner_slot) {
        if (inner_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_slot,
            inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_slot_changes_4
            ),
            get_inner_slot_context_4
          );
        }
      }
      if (!/*swipeout*/
      (ctx2[13] || /*accordionItem*/
      ctx2[15])) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty[0] & /*swipeout, accordionItem*/
          40960) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block_49(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(t8.parentNode, t8);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      if (
        /*hasFooter*/
        ctx2[33]
      ) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
          if (dirty[1] & /*hasFooter*/
          4) {
            transition_in(if_block6, 1);
          }
        } else {
          if_block6 = create_if_block_48(ctx2);
          if_block6.c();
          transition_in(if_block6, 1);
          if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
        }
      } else if (if_block6) {
        group_outros();
        transition_out(if_block6, 1, 1, () => {
          if_block6 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(before_title_slot, local);
      transition_in(if_block1);
      transition_in(after_title_slot, local);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(inner_slot, local);
      transition_in(if_block5);
      transition_in(if_block6);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(before_title_slot, local);
      transition_out(if_block1);
      transition_out(after_title_slot, local);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(inner_slot, local);
      transition_out(if_block5);
      transition_out(if_block6);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div);
        detach(t4);
        detach(t5);
        detach(t6);
        detach(t7);
        detach(t8);
        detach(if_block6_anchor);
      }
      if (if_block0) if_block0.d(detaching);
      if (before_title_slot) before_title_slot.d(detaching);
      if (if_block1) if_block1.d();
      if (after_title_slot) after_title_slot.d(detaching);
      if (if_block2) if_block2.d();
      if (if_block3) if_block3.d(detaching);
      if (if_block4) if_block4.d(detaching);
      if (inner_slot) inner_slot.d(detaching);
      if (if_block5) if_block5.d(detaching);
      if (if_block6) if_block6.d(detaching);
    }
  };
}
function create_if_block_61(ctx) {
  let div;
  let t0;
  let t1_value = plainText(
    /*title*/
    ctx[1]
  ) + "";
  let t1;
  let t2;
  let t3;
  let current;
  let if_block0 = (
    /*hasHeader*/
    ctx[34] && create_if_block_63(ctx)
  );
  const title_slot_template = (
    /*#slots*/
    ctx[69].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_title_slot_context_5
  );
  let if_block1 = (
    /*hasFooter*/
    ctx[33] && create_if_block_62(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block0) if_block0.c();
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      if (title_slot) title_slot.c();
      t3 = space();
      if (if_block1) if_block1.c();
      attr(div, "class", "item-title");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0) if_block0.m(div, null);
      append(div, t0);
      append(div, t1);
      append(div, t2);
      if (title_slot) {
        title_slot.m(div, null);
      }
      append(div, t3);
      if (if_block1) if_block1.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*hasHeader*/
        ctx2[34]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & /*hasHeader*/
          8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_63(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if ((!current || dirty[0] & /*title*/
      2) && t1_value !== (t1_value = plainText(
        /*title*/
        ctx2[1]
      ) + "")) set_data(t1, t1_value);
      if (title_slot) {
        if (title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_title_slot_changes_5
            ),
            get_title_slot_context_5
          );
        }
      }
      if (
        /*hasFooter*/
        ctx2[33]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasFooter*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_62(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(title_slot, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(title_slot, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block0) if_block0.d();
      if (title_slot) title_slot.d(detaching);
      if (if_block1) if_block1.d();
    }
  };
}
function create_if_block_63(ctx) {
  let div;
  let t0_value = plainText(
    /*header*/
    ctx[5]
  ) + "";
  let t0;
  let t1;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[69].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_header_slot_context_5
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (header_slot) header_slot.c();
      attr(div, "class", "item-header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (header_slot) {
        header_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*header*/
      32) && t0_value !== (t0_value = plainText(
        /*header*/
        ctx2[5]
      ) + "")) set_data(t0, t0_value);
      if (header_slot) {
        if (header_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_header_slot_changes_5
            ),
            get_header_slot_context_5
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(header_slot, local);
      current = true;
    },
    o(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (header_slot) header_slot.d(detaching);
    }
  };
}
function create_if_block_62(ctx) {
  let div;
  let t0_value = plainText(
    /*footer*/
    ctx[6]
  ) + "";
  let t0;
  let t1;
  let current;
  const footer_slot_template = (
    /*#slots*/
    ctx[69].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_footer_slot_context_5
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (footer_slot) footer_slot.c();
      attr(div, "class", "item-footer");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (footer_slot) {
        footer_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*footer*/
      64) && t0_value !== (t0_value = plainText(
        /*footer*/
        ctx2[6]
      ) + "")) set_data(t0, t0_value);
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_footer_slot_changes_5
            ),
            get_footer_slot_context_5
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(footer_slot, local);
      current = true;
    },
    o(local) {
      transition_out(footer_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (footer_slot) footer_slot.d(detaching);
    }
  };
}
function create_if_block_58(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  let t3;
  let current;
  const after_start_slot_template = (
    /*#slots*/
    ctx[69]["after-start"]
  );
  const after_start_slot = create_slot(
    after_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_start_slot_context_5
  );
  let if_block0 = typeof /*after*/
  ctx[9] !== "undefined" && create_if_block_60(ctx);
  let if_block1 = typeof /*badge*/
  ctx[10] !== "undefined" && create_if_block_59(ctx);
  const after_slot_template = (
    /*#slots*/
    ctx[69].after
  );
  const after_slot = create_slot(
    after_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_slot_context_5
  );
  const after_end_slot_template = (
    /*#slots*/
    ctx[69]["after-end"]
  );
  const after_end_slot = create_slot(
    after_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_end_slot_context_5
  );
  return {
    c() {
      div = element("div");
      if (after_start_slot) after_start_slot.c();
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      if (after_slot) after_slot.c();
      t3 = space();
      if (after_end_slot) after_end_slot.c();
      attr(div, "class", "item-after");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (after_start_slot) {
        after_start_slot.m(div, null);
      }
      append(div, t0);
      if (if_block0) if_block0.m(div, null);
      append(div, t1);
      if (if_block1) if_block1.m(div, null);
      append(div, t2);
      if (after_slot) {
        after_slot.m(div, null);
      }
      append(div, t3);
      if (after_end_slot) {
        after_end_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (after_start_slot) {
        if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_start_slot,
            after_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_start_slot_changes_5
            ),
            get_after_start_slot_context_5
          );
        }
      }
      if (typeof /*after*/
      ctx2[9] !== "undefined") {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_60(ctx2);
          if_block0.c();
          if_block0.m(div, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (typeof /*badge*/
      ctx2[10] !== "undefined") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*badge*/
          1024) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_59(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (after_slot) {
        if (after_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_slot,
            after_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_slot_changes_5
            ),
            get_after_slot_context_5
          );
        }
      }
      if (after_end_slot) {
        if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_end_slot,
            after_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_end_slot_changes_5
            ),
            get_after_end_slot_context_5
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(after_start_slot, local);
      transition_in(if_block1);
      transition_in(after_slot, local);
      transition_in(after_end_slot, local);
      current = true;
    },
    o(local) {
      transition_out(after_start_slot, local);
      transition_out(if_block1);
      transition_out(after_slot, local);
      transition_out(after_end_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (after_start_slot) after_start_slot.d(detaching);
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (after_slot) after_slot.d(detaching);
      if (after_end_slot) after_end_slot.d(detaching);
    }
  };
}
function create_if_block_60(ctx) {
  let span;
  let t_value = plainText(
    /*after*/
    ctx[9]
  ) + "";
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*after*/
      512 && t_value !== (t_value = plainText(
        /*after*/
        ctx2[9]
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_59(ctx) {
  let badge_1;
  let current;
  badge_1 = new Badge({
    props: {
      color: (
        /*badgeColor*/
        ctx[11]
      ),
      $$slots: { default: [create_default_slot_5$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(badge_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(badge_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const badge_1_changes = {};
      if (dirty[0] & /*badgeColor*/
      2048) badge_1_changes.color = /*badgeColor*/
      ctx2[11];
      if (dirty[0] & /*badge*/
      1024 | dirty[2] & /*$$scope*/
      2097152) {
        badge_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      badge_1.$set(badge_1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(badge_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(badge_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(badge_1, detaching);
    }
  };
}
function create_default_slot_5$2(ctx) {
  let t_value = plainText(
    /*badge*/
    ctx[10]
  ) + "";
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*badge*/
      1024 && t_value !== (t_value = plainText(
        /*badge*/
        ctx2[10]
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_57(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[69].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    null
  );
  return {
    c() {
      if (default_slot) default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function create_if_block_56(ctx) {
  let div;
  let t0_value = plainText(
    /*header*/
    ctx[5]
  ) + "";
  let t0;
  let t1;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[69].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_header_slot_context_4
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (header_slot) header_slot.c();
      attr(div, "class", "item-header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (header_slot) {
        header_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*header*/
      32) && t0_value !== (t0_value = plainText(
        /*header*/
        ctx2[5]
      ) + "")) set_data(t0, t0_value);
      if (header_slot) {
        if (header_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_header_slot_changes_4
            ),
            get_header_slot_context_4
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(header_slot, local);
      current = true;
    },
    o(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (header_slot) header_slot.d(detaching);
    }
  };
}
function create_if_block_55(ctx) {
  let div;
  let t0_value = plainText(
    /*title*/
    ctx[1]
  ) + "";
  let t0;
  let t1;
  let current;
  const title_slot_template = (
    /*#slots*/
    ctx[69].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_title_slot_context_4
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (title_slot) title_slot.c();
      attr(div, "class", "item-title");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (title_slot) {
        title_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*title*/
      2) && t0_value !== (t0_value = plainText(
        /*title*/
        ctx2[1]
      ) + "")) set_data(t0, t0_value);
      if (title_slot) {
        if (title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_title_slot_changes_4
            ),
            get_title_slot_context_4
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(title_slot, local);
      current = true;
    },
    o(local) {
      transition_out(title_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (title_slot) title_slot.d(detaching);
    }
  };
}
function create_if_block_52(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  let t3;
  let current;
  const after_start_slot_template = (
    /*#slots*/
    ctx[69]["after-start"]
  );
  const after_start_slot = create_slot(
    after_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_start_slot_context_4
  );
  let if_block0 = typeof /*after*/
  ctx[9] !== "undefined" && create_if_block_54(ctx);
  let if_block1 = typeof /*badge*/
  ctx[10] !== "undefined" && create_if_block_53(ctx);
  const after_slot_template = (
    /*#slots*/
    ctx[69].after
  );
  const after_slot = create_slot(
    after_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_slot_context_4
  );
  const after_end_slot_template = (
    /*#slots*/
    ctx[69]["after-end"]
  );
  const after_end_slot = create_slot(
    after_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_end_slot_context_4
  );
  return {
    c() {
      div = element("div");
      if (after_start_slot) after_start_slot.c();
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      if (after_slot) after_slot.c();
      t3 = space();
      if (after_end_slot) after_end_slot.c();
      attr(div, "class", "item-after");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (after_start_slot) {
        after_start_slot.m(div, null);
      }
      append(div, t0);
      if (if_block0) if_block0.m(div, null);
      append(div, t1);
      if (if_block1) if_block1.m(div, null);
      append(div, t2);
      if (after_slot) {
        after_slot.m(div, null);
      }
      append(div, t3);
      if (after_end_slot) {
        after_end_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (after_start_slot) {
        if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_start_slot,
            after_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_start_slot_changes_4
            ),
            get_after_start_slot_context_4
          );
        }
      }
      if (typeof /*after*/
      ctx2[9] !== "undefined") {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_54(ctx2);
          if_block0.c();
          if_block0.m(div, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (typeof /*badge*/
      ctx2[10] !== "undefined") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*badge*/
          1024) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_53(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (after_slot) {
        if (after_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_slot,
            after_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_slot_changes_4
            ),
            get_after_slot_context_4
          );
        }
      }
      if (after_end_slot) {
        if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_end_slot,
            after_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_end_slot_changes_4
            ),
            get_after_end_slot_context_4
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(after_start_slot, local);
      transition_in(if_block1);
      transition_in(after_slot, local);
      transition_in(after_end_slot, local);
      current = true;
    },
    o(local) {
      transition_out(after_start_slot, local);
      transition_out(if_block1);
      transition_out(after_slot, local);
      transition_out(after_end_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (after_start_slot) after_start_slot.d(detaching);
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (after_slot) after_slot.d(detaching);
      if (after_end_slot) after_end_slot.d(detaching);
    }
  };
}
function create_if_block_54(ctx) {
  let span;
  let t_value = plainText(
    /*after*/
    ctx[9]
  ) + "";
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*after*/
      512 && t_value !== (t_value = plainText(
        /*after*/
        ctx2[9]
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_53(ctx) {
  let badge_1;
  let current;
  badge_1 = new Badge({
    props: {
      color: (
        /*badgeColor*/
        ctx[11]
      ),
      $$slots: { default: [create_default_slot_4$4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(badge_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(badge_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const badge_1_changes = {};
      if (dirty[0] & /*badgeColor*/
      2048) badge_1_changes.color = /*badgeColor*/
      ctx2[11];
      if (dirty[0] & /*badge*/
      1024 | dirty[2] & /*$$scope*/
      2097152) {
        badge_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      badge_1.$set(badge_1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(badge_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(badge_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(badge_1, detaching);
    }
  };
}
function create_default_slot_4$4(ctx) {
  let t_value = plainText(
    /*badge*/
    ctx[10]
  ) + "";
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*badge*/
      1024 && t_value !== (t_value = plainText(
        /*badge*/
        ctx2[10]
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_51(ctx) {
  let div;
  let t0_value = plainText(
    /*subtitle*/
    ctx[4]
  ) + "";
  let t0;
  let t1;
  let current;
  const subtitle_slot_template = (
    /*#slots*/
    ctx[69].subtitle
  );
  const subtitle_slot = create_slot(
    subtitle_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_subtitle_slot_context_2
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (subtitle_slot) subtitle_slot.c();
      attr(div, "class", "item-subtitle");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (subtitle_slot) {
        subtitle_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*subtitle*/
      16) && t0_value !== (t0_value = plainText(
        /*subtitle*/
        ctx2[4]
      ) + "")) set_data(t0, t0_value);
      if (subtitle_slot) {
        if (subtitle_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            subtitle_slot,
            subtitle_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              subtitle_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_subtitle_slot_changes_2
            ),
            get_subtitle_slot_context_2
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(subtitle_slot, local);
      current = true;
    },
    o(local) {
      transition_out(subtitle_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (subtitle_slot) subtitle_slot.d(detaching);
    }
  };
}
function create_if_block_50(ctx) {
  let div;
  let t0_value = plainText(
    /*text*/
    ctx[2]
  ) + "";
  let t0;
  let t1;
  let current;
  const text_slot_template = (
    /*#slots*/
    ctx[69].text
  );
  const text_slot = create_slot(
    text_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_text_slot_context_2
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (text_slot) text_slot.c();
      attr(div, "class", "item-text");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (text_slot) {
        text_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*text*/
      4) && t0_value !== (t0_value = plainText(
        /*text*/
        ctx2[2]
      ) + "")) set_data(t0, t0_value);
      if (text_slot) {
        if (text_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            text_slot,
            text_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              text_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_text_slot_changes_2
            ),
            get_text_slot_context_2
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(text_slot, local);
      current = true;
    },
    o(local) {
      transition_out(text_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (text_slot) text_slot.d(detaching);
    }
  };
}
function create_if_block_49(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[69].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    null
  );
  return {
    c() {
      if (default_slot) default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function create_if_block_48(ctx) {
  let div;
  let t0_value = plainText(
    /*footer*/
    ctx[6]
  ) + "";
  let t0;
  let t1;
  let current;
  const footer_slot_template = (
    /*#slots*/
    ctx[69].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_footer_slot_context_4
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (footer_slot) footer_slot.c();
      attr(div, "class", "item-footer");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (footer_slot) {
        footer_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*footer*/
      64) && t0_value !== (t0_value = plainText(
        /*footer*/
        ctx2[6]
      ) + "")) set_data(t0, t0_value);
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_footer_slot_changes_4
            ),
            get_footer_slot_context_4
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(footer_slot, local);
      current = true;
    },
    o(local) {
      transition_out(footer_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (footer_slot) footer_slot.d(detaching);
    }
  };
}
function create_if_block_46(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "sortable-handler");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block_44(ctx) {
  let div;
  let t2;
  let current;
  let if_block = typeof /*media*/
  ctx[3] !== "undefined" && create_if_block_45(ctx);
  const media_slot_template = (
    /*#slots*/
    ctx[69].media
  );
  const media_slot = create_slot(
    media_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_media_slot_context_1
  );
  return {
    c() {
      div = element("div");
      if (if_block) if_block.c();
      t2 = space();
      if (media_slot) media_slot.c();
      attr(div, "class", "item-media");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block) if_block.m(div, null);
      append(div, t2);
      if (media_slot) {
        media_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (typeof /*media*/
      ctx2[3] !== "undefined") {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_45(ctx2);
          if_block.c();
          if_block.m(div, t2);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (media_slot) {
        if (media_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            media_slot,
            media_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              media_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_media_slot_changes_1
            ),
            get_media_slot_context_1
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(media_slot, local);
      current = true;
    },
    o(local) {
      transition_out(media_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block) if_block.d();
      if (media_slot) media_slot.d(detaching);
    }
  };
}
function create_if_block_45(ctx) {
  let img;
  let img_src_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*media*/
      ctx[3])) attr(img, "src", img_src_value);
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*media*/
      8 && !src_url_equal(img.src, img_src_value = /*media*/
      ctx2[3])) {
        attr(img, "src", img_src_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_else_block_3(ctx) {
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let if_block2_anchor;
  let current;
  const before_title_slot_template = (
    /*#slots*/
    ctx[69]["before-title"]
  );
  const before_title_slot = create_slot(
    before_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_before_title_slot_context_3
  );
  let if_block0 = (
    /*hasTitle*/
    (ctx[35] || /*hasHeader*/
    ctx[34] || /*hasFooter*/
    ctx[33]) && create_if_block_41(ctx)
  );
  const after_title_slot_template = (
    /*#slots*/
    ctx[69]["after-title"]
  );
  const after_title_slot = create_slot(
    after_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_title_slot_context_3
  );
  let if_block1 = (
    /*hasAfter*/
    ctx[30] && create_if_block_38(ctx)
  );
  const inner_slot_template = (
    /*#slots*/
    ctx[69].inner
  );
  const inner_slot = create_slot(
    inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_slot_context_3
  );
  let if_block2 = !/*swipeout*/
  (ctx[13] || /*accordionItem*/
  ctx[15]) && create_if_block_37(ctx);
  return {
    c() {
      if (before_title_slot) before_title_slot.c();
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (after_title_slot) after_title_slot.c();
      t2 = space();
      if (if_block1) if_block1.c();
      t3 = space();
      if (inner_slot) inner_slot.c();
      t4 = space();
      if (if_block2) if_block2.c();
      if_block2_anchor = empty();
    },
    m(target, anchor) {
      if (before_title_slot) {
        before_title_slot.m(target, anchor);
      }
      insert(target, t0, anchor);
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (after_title_slot) {
        after_title_slot.m(target, anchor);
      }
      insert(target, t2, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, t3, anchor);
      if (inner_slot) {
        inner_slot.m(target, anchor);
      }
      insert(target, t4, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (before_title_slot) {
        if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            before_title_slot,
            before_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              before_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_before_title_slot_changes_3
            ),
            get_before_title_slot_context_3
          );
        }
      }
      if (
        /*hasTitle*/
        ctx2[35] || /*hasHeader*/
        ctx2[34] || /*hasFooter*/
        ctx2[33]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/
          28) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_41(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (after_title_slot) {
        if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_title_slot,
            after_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_title_slot_changes_3
            ),
            get_after_title_slot_context_3
          );
        }
      }
      if (
        /*hasAfter*/
        ctx2[30]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*hasAfter*/
          1073741824) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_38(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t3.parentNode, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (inner_slot) {
        if (inner_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_slot,
            inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_slot_changes_3
            ),
            get_inner_slot_context_3
          );
        }
      }
      if (!/*swipeout*/
      (ctx2[13] || /*accordionItem*/
      ctx2[15])) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*swipeout, accordionItem*/
          40960) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_37(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(before_title_slot, local);
      transition_in(if_block0);
      transition_in(after_title_slot, local);
      transition_in(if_block1);
      transition_in(inner_slot, local);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(before_title_slot, local);
      transition_out(if_block0);
      transition_out(after_title_slot, local);
      transition_out(if_block1);
      transition_out(inner_slot, local);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(if_block2_anchor);
      }
      if (before_title_slot) before_title_slot.d(detaching);
      if (if_block0) if_block0.d(detaching);
      if (after_title_slot) after_title_slot.d(detaching);
      if (if_block1) if_block1.d(detaching);
      if (inner_slot) inner_slot.d(detaching);
      if (if_block2) if_block2.d(detaching);
    }
  };
}
function create_if_block_27(ctx) {
  let t0;
  let div;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let t6;
  let t7;
  let t8;
  let if_block6_anchor;
  let current;
  let if_block0 = (
    /*hasHeader*/
    ctx[34] && create_if_block_36(ctx)
  );
  const before_title_slot_template = (
    /*#slots*/
    ctx[69]["before-title"]
  );
  const before_title_slot = create_slot(
    before_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_before_title_slot_context_2
  );
  let if_block1 = (
    /*hasTitle*/
    ctx[35] && create_if_block_35(ctx)
  );
  const after_title_slot_template = (
    /*#slots*/
    ctx[69]["after-title"]
  );
  const after_title_slot = create_slot(
    after_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_title_slot_context_2
  );
  let if_block2 = (
    /*hasAfter*/
    ctx[30] && create_if_block_32(ctx)
  );
  let if_block3 = (
    /*hasSubtitle*/
    ctx[32] && create_if_block_31(ctx)
  );
  let if_block4 = (
    /*hasText*/
    ctx[31] && create_if_block_30(ctx)
  );
  const inner_slot_template = (
    /*#slots*/
    ctx[69].inner
  );
  const inner_slot = create_slot(
    inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_slot_context_2
  );
  let if_block5 = !/*swipeout*/
  (ctx[13] || /*accordionItem*/
  ctx[15]) && create_if_block_29(ctx);
  let if_block6 = (
    /*hasFooter*/
    ctx[33] && create_if_block_28(ctx)
  );
  return {
    c() {
      if (if_block0) if_block0.c();
      t0 = space();
      div = element("div");
      if (before_title_slot) before_title_slot.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      if (after_title_slot) after_title_slot.c();
      t3 = space();
      if (if_block2) if_block2.c();
      t4 = space();
      if (if_block3) if_block3.c();
      t5 = space();
      if (if_block4) if_block4.c();
      t6 = space();
      if (inner_slot) inner_slot.c();
      t7 = space();
      if (if_block5) if_block5.c();
      t8 = space();
      if (if_block6) if_block6.c();
      if_block6_anchor = empty();
      attr(div, "class", "item-title-row");
    },
    m(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, div, anchor);
      if (before_title_slot) {
        before_title_slot.m(div, null);
      }
      append(div, t1);
      if (if_block1) if_block1.m(div, null);
      append(div, t2);
      if (after_title_slot) {
        after_title_slot.m(div, null);
      }
      append(div, t3);
      if (if_block2) if_block2.m(div, null);
      insert(target, t4, anchor);
      if (if_block3) if_block3.m(target, anchor);
      insert(target, t5, anchor);
      if (if_block4) if_block4.m(target, anchor);
      insert(target, t6, anchor);
      if (inner_slot) {
        inner_slot.m(target, anchor);
      }
      insert(target, t7, anchor);
      if (if_block5) if_block5.m(target, anchor);
      insert(target, t8, anchor);
      if (if_block6) if_block6.m(target, anchor);
      insert(target, if_block6_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*hasHeader*/
        ctx2[34]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & /*hasHeader*/
          8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_36(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (before_title_slot) {
        if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            before_title_slot,
            before_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              before_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_before_title_slot_changes_2
            ),
            get_before_title_slot_context_2
          );
        }
      }
      if (
        /*hasTitle*/
        ctx2[35]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasTitle*/
          16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_35(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (after_title_slot) {
        if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_title_slot,
            after_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_title_slot_changes_2
            ),
            get_after_title_slot_context_2
          );
        }
      }
      if (
        /*hasAfter*/
        ctx2[30]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*hasAfter*/
          1073741824) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_32(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*hasSubtitle*/
        ctx2[32]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[1] & /*hasSubtitle*/
          2) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_31(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(t5.parentNode, t5);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (
        /*hasText*/
        ctx2[31]
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[1] & /*hasText*/
          1) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_30(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(t6.parentNode, t6);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (inner_slot) {
        if (inner_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_slot,
            inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_slot_changes_2
            ),
            get_inner_slot_context_2
          );
        }
      }
      if (!/*swipeout*/
      (ctx2[13] || /*accordionItem*/
      ctx2[15])) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty[0] & /*swipeout, accordionItem*/
          40960) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block_29(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(t8.parentNode, t8);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      if (
        /*hasFooter*/
        ctx2[33]
      ) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
          if (dirty[1] & /*hasFooter*/
          4) {
            transition_in(if_block6, 1);
          }
        } else {
          if_block6 = create_if_block_28(ctx2);
          if_block6.c();
          transition_in(if_block6, 1);
          if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
        }
      } else if (if_block6) {
        group_outros();
        transition_out(if_block6, 1, 1, () => {
          if_block6 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(before_title_slot, local);
      transition_in(if_block1);
      transition_in(after_title_slot, local);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(inner_slot, local);
      transition_in(if_block5);
      transition_in(if_block6);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(before_title_slot, local);
      transition_out(if_block1);
      transition_out(after_title_slot, local);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(inner_slot, local);
      transition_out(if_block5);
      transition_out(if_block6);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div);
        detach(t4);
        detach(t5);
        detach(t6);
        detach(t7);
        detach(t8);
        detach(if_block6_anchor);
      }
      if (if_block0) if_block0.d(detaching);
      if (before_title_slot) before_title_slot.d(detaching);
      if (if_block1) if_block1.d();
      if (after_title_slot) after_title_slot.d(detaching);
      if (if_block2) if_block2.d();
      if (if_block3) if_block3.d(detaching);
      if (if_block4) if_block4.d(detaching);
      if (inner_slot) inner_slot.d(detaching);
      if (if_block5) if_block5.d(detaching);
      if (if_block6) if_block6.d(detaching);
    }
  };
}
function create_if_block_41(ctx) {
  let div;
  let t0;
  let t1_value = plainText(
    /*title*/
    ctx[1]
  ) + "";
  let t1;
  let t2;
  let t3;
  let current;
  let if_block0 = (
    /*hasHeader*/
    ctx[34] && create_if_block_43(ctx)
  );
  const title_slot_template = (
    /*#slots*/
    ctx[69].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_title_slot_context_3
  );
  let if_block1 = (
    /*hasFooter*/
    ctx[33] && create_if_block_42(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block0) if_block0.c();
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      if (title_slot) title_slot.c();
      t3 = space();
      if (if_block1) if_block1.c();
      attr(div, "class", "item-title");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0) if_block0.m(div, null);
      append(div, t0);
      append(div, t1);
      append(div, t2);
      if (title_slot) {
        title_slot.m(div, null);
      }
      append(div, t3);
      if (if_block1) if_block1.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*hasHeader*/
        ctx2[34]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & /*hasHeader*/
          8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_43(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if ((!current || dirty[0] & /*title*/
      2) && t1_value !== (t1_value = plainText(
        /*title*/
        ctx2[1]
      ) + "")) set_data(t1, t1_value);
      if (title_slot) {
        if (title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_title_slot_changes_3
            ),
            get_title_slot_context_3
          );
        }
      }
      if (
        /*hasFooter*/
        ctx2[33]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasFooter*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_42(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(title_slot, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(title_slot, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block0) if_block0.d();
      if (title_slot) title_slot.d(detaching);
      if (if_block1) if_block1.d();
    }
  };
}
function create_if_block_43(ctx) {
  let div;
  let t0_value = plainText(
    /*header*/
    ctx[5]
  ) + "";
  let t0;
  let t1;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[69].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_header_slot_context_3
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (header_slot) header_slot.c();
      attr(div, "class", "item-header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (header_slot) {
        header_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*header*/
      32) && t0_value !== (t0_value = plainText(
        /*header*/
        ctx2[5]
      ) + "")) set_data(t0, t0_value);
      if (header_slot) {
        if (header_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_header_slot_changes_3
            ),
            get_header_slot_context_3
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(header_slot, local);
      current = true;
    },
    o(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (header_slot) header_slot.d(detaching);
    }
  };
}
function create_if_block_42(ctx) {
  let div;
  let t0_value = plainText(
    /*footer*/
    ctx[6]
  ) + "";
  let t0;
  let t1;
  let current;
  const footer_slot_template = (
    /*#slots*/
    ctx[69].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_footer_slot_context_3
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (footer_slot) footer_slot.c();
      attr(div, "class", "item-footer");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (footer_slot) {
        footer_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*footer*/
      64) && t0_value !== (t0_value = plainText(
        /*footer*/
        ctx2[6]
      ) + "")) set_data(t0, t0_value);
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_footer_slot_changes_3
            ),
            get_footer_slot_context_3
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(footer_slot, local);
      current = true;
    },
    o(local) {
      transition_out(footer_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (footer_slot) footer_slot.d(detaching);
    }
  };
}
function create_if_block_38(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  let t3;
  let current;
  const after_start_slot_template = (
    /*#slots*/
    ctx[69]["after-start"]
  );
  const after_start_slot = create_slot(
    after_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_start_slot_context_3
  );
  let if_block0 = typeof /*after*/
  ctx[9] !== "undefined" && create_if_block_40(ctx);
  let if_block1 = typeof /*badge*/
  ctx[10] !== "undefined" && create_if_block_39(ctx);
  const after_slot_template = (
    /*#slots*/
    ctx[69].after
  );
  const after_slot = create_slot(
    after_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_slot_context_3
  );
  const after_end_slot_template = (
    /*#slots*/
    ctx[69]["after-end"]
  );
  const after_end_slot = create_slot(
    after_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_end_slot_context_3
  );
  return {
    c() {
      div = element("div");
      if (after_start_slot) after_start_slot.c();
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      if (after_slot) after_slot.c();
      t3 = space();
      if (after_end_slot) after_end_slot.c();
      attr(div, "class", "item-after");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (after_start_slot) {
        after_start_slot.m(div, null);
      }
      append(div, t0);
      if (if_block0) if_block0.m(div, null);
      append(div, t1);
      if (if_block1) if_block1.m(div, null);
      append(div, t2);
      if (after_slot) {
        after_slot.m(div, null);
      }
      append(div, t3);
      if (after_end_slot) {
        after_end_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (after_start_slot) {
        if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_start_slot,
            after_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_start_slot_changes_3
            ),
            get_after_start_slot_context_3
          );
        }
      }
      if (typeof /*after*/
      ctx2[9] !== "undefined") {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_40(ctx2);
          if_block0.c();
          if_block0.m(div, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (typeof /*badge*/
      ctx2[10] !== "undefined") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*badge*/
          1024) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_39(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (after_slot) {
        if (after_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_slot,
            after_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_slot_changes_3
            ),
            get_after_slot_context_3
          );
        }
      }
      if (after_end_slot) {
        if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_end_slot,
            after_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_end_slot_changes_3
            ),
            get_after_end_slot_context_3
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(after_start_slot, local);
      transition_in(if_block1);
      transition_in(after_slot, local);
      transition_in(after_end_slot, local);
      current = true;
    },
    o(local) {
      transition_out(after_start_slot, local);
      transition_out(if_block1);
      transition_out(after_slot, local);
      transition_out(after_end_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (after_start_slot) after_start_slot.d(detaching);
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (after_slot) after_slot.d(detaching);
      if (after_end_slot) after_end_slot.d(detaching);
    }
  };
}
function create_if_block_40(ctx) {
  let span;
  let t_value = plainText(
    /*after*/
    ctx[9]
  ) + "";
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*after*/
      512 && t_value !== (t_value = plainText(
        /*after*/
        ctx2[9]
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_39(ctx) {
  let badge_1;
  let current;
  badge_1 = new Badge({
    props: {
      color: (
        /*badgeColor*/
        ctx[11]
      ),
      $$slots: { default: [create_default_slot_3$4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(badge_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(badge_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const badge_1_changes = {};
      if (dirty[0] & /*badgeColor*/
      2048) badge_1_changes.color = /*badgeColor*/
      ctx2[11];
      if (dirty[0] & /*badge*/
      1024 | dirty[2] & /*$$scope*/
      2097152) {
        badge_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      badge_1.$set(badge_1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(badge_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(badge_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(badge_1, detaching);
    }
  };
}
function create_default_slot_3$4(ctx) {
  let t_value = plainText(
    /*badge*/
    ctx[10]
  ) + "";
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*badge*/
      1024 && t_value !== (t_value = plainText(
        /*badge*/
        ctx2[10]
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_37(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[69].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    null
  );
  return {
    c() {
      if (default_slot) default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function create_if_block_36(ctx) {
  let div;
  let t0_value = plainText(
    /*header*/
    ctx[5]
  ) + "";
  let t0;
  let t1;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[69].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_header_slot_context_2
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (header_slot) header_slot.c();
      attr(div, "class", "item-header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (header_slot) {
        header_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*header*/
      32) && t0_value !== (t0_value = plainText(
        /*header*/
        ctx2[5]
      ) + "")) set_data(t0, t0_value);
      if (header_slot) {
        if (header_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_header_slot_changes_2
            ),
            get_header_slot_context_2
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(header_slot, local);
      current = true;
    },
    o(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (header_slot) header_slot.d(detaching);
    }
  };
}
function create_if_block_35(ctx) {
  let div;
  let t0_value = plainText(
    /*title*/
    ctx[1]
  ) + "";
  let t0;
  let t1;
  let current;
  const title_slot_template = (
    /*#slots*/
    ctx[69].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_title_slot_context_2
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (title_slot) title_slot.c();
      attr(div, "class", "item-title");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (title_slot) {
        title_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*title*/
      2) && t0_value !== (t0_value = plainText(
        /*title*/
        ctx2[1]
      ) + "")) set_data(t0, t0_value);
      if (title_slot) {
        if (title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_title_slot_changes_2
            ),
            get_title_slot_context_2
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(title_slot, local);
      current = true;
    },
    o(local) {
      transition_out(title_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (title_slot) title_slot.d(detaching);
    }
  };
}
function create_if_block_32(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  let t3;
  let current;
  const after_start_slot_template = (
    /*#slots*/
    ctx[69]["after-start"]
  );
  const after_start_slot = create_slot(
    after_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_start_slot_context_2
  );
  let if_block0 = typeof /*after*/
  ctx[9] !== "undefined" && create_if_block_34(ctx);
  let if_block1 = typeof /*badge*/
  ctx[10] !== "undefined" && create_if_block_33(ctx);
  const after_slot_template = (
    /*#slots*/
    ctx[69].after
  );
  const after_slot = create_slot(
    after_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_slot_context_2
  );
  const after_end_slot_template = (
    /*#slots*/
    ctx[69]["after-end"]
  );
  const after_end_slot = create_slot(
    after_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_end_slot_context_2
  );
  return {
    c() {
      div = element("div");
      if (after_start_slot) after_start_slot.c();
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      if (after_slot) after_slot.c();
      t3 = space();
      if (after_end_slot) after_end_slot.c();
      attr(div, "class", "item-after");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (after_start_slot) {
        after_start_slot.m(div, null);
      }
      append(div, t0);
      if (if_block0) if_block0.m(div, null);
      append(div, t1);
      if (if_block1) if_block1.m(div, null);
      append(div, t2);
      if (after_slot) {
        after_slot.m(div, null);
      }
      append(div, t3);
      if (after_end_slot) {
        after_end_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (after_start_slot) {
        if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_start_slot,
            after_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_start_slot_changes_2
            ),
            get_after_start_slot_context_2
          );
        }
      }
      if (typeof /*after*/
      ctx2[9] !== "undefined") {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_34(ctx2);
          if_block0.c();
          if_block0.m(div, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (typeof /*badge*/
      ctx2[10] !== "undefined") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*badge*/
          1024) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_33(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (after_slot) {
        if (after_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_slot,
            after_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_slot_changes_2
            ),
            get_after_slot_context_2
          );
        }
      }
      if (after_end_slot) {
        if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_end_slot,
            after_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_end_slot_changes_2
            ),
            get_after_end_slot_context_2
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(after_start_slot, local);
      transition_in(if_block1);
      transition_in(after_slot, local);
      transition_in(after_end_slot, local);
      current = true;
    },
    o(local) {
      transition_out(after_start_slot, local);
      transition_out(if_block1);
      transition_out(after_slot, local);
      transition_out(after_end_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (after_start_slot) after_start_slot.d(detaching);
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (after_slot) after_slot.d(detaching);
      if (after_end_slot) after_end_slot.d(detaching);
    }
  };
}
function create_if_block_34(ctx) {
  let span;
  let t_value = plainText(
    /*after*/
    ctx[9]
  ) + "";
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*after*/
      512 && t_value !== (t_value = plainText(
        /*after*/
        ctx2[9]
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_33(ctx) {
  let badge_1;
  let current;
  badge_1 = new Badge({
    props: {
      color: (
        /*badgeColor*/
        ctx[11]
      ),
      $$slots: { default: [create_default_slot_2$5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(badge_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(badge_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const badge_1_changes = {};
      if (dirty[0] & /*badgeColor*/
      2048) badge_1_changes.color = /*badgeColor*/
      ctx2[11];
      if (dirty[0] & /*badge*/
      1024 | dirty[2] & /*$$scope*/
      2097152) {
        badge_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      badge_1.$set(badge_1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(badge_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(badge_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(badge_1, detaching);
    }
  };
}
function create_default_slot_2$5(ctx) {
  let t_value = plainText(
    /*badge*/
    ctx[10]
  ) + "";
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*badge*/
      1024 && t_value !== (t_value = plainText(
        /*badge*/
        ctx2[10]
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_31(ctx) {
  let div;
  let t0_value = plainText(
    /*subtitle*/
    ctx[4]
  ) + "";
  let t0;
  let t1;
  let current;
  const subtitle_slot_template = (
    /*#slots*/
    ctx[69].subtitle
  );
  const subtitle_slot = create_slot(
    subtitle_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_subtitle_slot_context_1
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (subtitle_slot) subtitle_slot.c();
      attr(div, "class", "item-subtitle");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (subtitle_slot) {
        subtitle_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*subtitle*/
      16) && t0_value !== (t0_value = plainText(
        /*subtitle*/
        ctx2[4]
      ) + "")) set_data(t0, t0_value);
      if (subtitle_slot) {
        if (subtitle_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            subtitle_slot,
            subtitle_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              subtitle_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_subtitle_slot_changes_1
            ),
            get_subtitle_slot_context_1
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(subtitle_slot, local);
      current = true;
    },
    o(local) {
      transition_out(subtitle_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (subtitle_slot) subtitle_slot.d(detaching);
    }
  };
}
function create_if_block_30(ctx) {
  let div;
  let t0_value = plainText(
    /*text*/
    ctx[2]
  ) + "";
  let t0;
  let t1;
  let current;
  const text_slot_template = (
    /*#slots*/
    ctx[69].text
  );
  const text_slot = create_slot(
    text_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_text_slot_context_1
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (text_slot) text_slot.c();
      attr(div, "class", "item-text");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (text_slot) {
        text_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*text*/
      4) && t0_value !== (t0_value = plainText(
        /*text*/
        ctx2[2]
      ) + "")) set_data(t0, t0_value);
      if (text_slot) {
        if (text_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            text_slot,
            text_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              text_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_text_slot_changes_1
            ),
            get_text_slot_context_1
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(text_slot, local);
      current = true;
    },
    o(local) {
      transition_out(text_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (text_slot) text_slot.d(detaching);
    }
  };
}
function create_if_block_29(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[69].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    null
  );
  return {
    c() {
      if (default_slot) default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function create_if_block_28(ctx) {
  let div;
  let t0_value = plainText(
    /*footer*/
    ctx[6]
  ) + "";
  let t0;
  let t1;
  let current;
  const footer_slot_template = (
    /*#slots*/
    ctx[69].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_footer_slot_context_2
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (footer_slot) footer_slot.c();
      attr(div, "class", "item-footer");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (footer_slot) {
        footer_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*footer*/
      64) && t0_value !== (t0_value = plainText(
        /*footer*/
        ctx2[6]
      ) + "")) set_data(t0, t0_value);
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_footer_slot_changes_2
            ),
            get_footer_slot_context_2
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(footer_slot, local);
      current = true;
    },
    o(local) {
      transition_out(footer_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (footer_slot) footer_slot.d(detaching);
    }
  };
}
function create_if_block_25(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "sortable-handler");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block_23(ctx) {
  let div;
  let t2;
  let current;
  let if_block = typeof /*media*/
  ctx[3] !== "undefined" && create_if_block_24(ctx);
  const media_slot_template = (
    /*#slots*/
    ctx[69].media
  );
  const media_slot = create_slot(
    media_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_media_slot_context
  );
  return {
    c() {
      div = element("div");
      if (if_block) if_block.c();
      t2 = space();
      if (media_slot) media_slot.c();
      attr(div, "class", "item-media");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block) if_block.m(div, null);
      append(div, t2);
      if (media_slot) {
        media_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (typeof /*media*/
      ctx2[3] !== "undefined") {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_24(ctx2);
          if_block.c();
          if_block.m(div, t2);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (media_slot) {
        if (media_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            media_slot,
            media_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              media_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_media_slot_changes
            ),
            get_media_slot_context
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(media_slot, local);
      current = true;
    },
    o(local) {
      transition_out(media_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block) if_block.d();
      if (media_slot) media_slot.d(detaching);
    }
  };
}
function create_if_block_24(ctx) {
  let img;
  let img_src_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*media*/
      ctx[3])) attr(img, "src", img_src_value);
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*media*/
      8 && !src_url_equal(img.src, img_src_value = /*media*/
      ctx2[3])) {
        attr(img, "src", img_src_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_else_block_1$1(ctx) {
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let if_block2_anchor;
  let current;
  const before_title_slot_template = (
    /*#slots*/
    ctx[69]["before-title"]
  );
  const before_title_slot = create_slot(
    before_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_before_title_slot_context_1
  );
  let if_block0 = (
    /*hasTitle*/
    (ctx[35] || /*hasHeader*/
    ctx[34] || /*hasFooter*/
    ctx[33]) && create_if_block_20(ctx)
  );
  const after_title_slot_template = (
    /*#slots*/
    ctx[69]["after-title"]
  );
  const after_title_slot = create_slot(
    after_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_title_slot_context_1
  );
  let if_block1 = (
    /*hasAfter*/
    ctx[30] && create_if_block_17(ctx)
  );
  const inner_slot_template = (
    /*#slots*/
    ctx[69].inner
  );
  const inner_slot = create_slot(
    inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_slot_context_1
  );
  let if_block2 = !/*swipeout*/
  (ctx[13] || /*accordionItem*/
  ctx[15]) && create_if_block_16(ctx);
  return {
    c() {
      if (before_title_slot) before_title_slot.c();
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (after_title_slot) after_title_slot.c();
      t2 = space();
      if (if_block1) if_block1.c();
      t3 = space();
      if (inner_slot) inner_slot.c();
      t4 = space();
      if (if_block2) if_block2.c();
      if_block2_anchor = empty();
    },
    m(target, anchor) {
      if (before_title_slot) {
        before_title_slot.m(target, anchor);
      }
      insert(target, t0, anchor);
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (after_title_slot) {
        after_title_slot.m(target, anchor);
      }
      insert(target, t2, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, t3, anchor);
      if (inner_slot) {
        inner_slot.m(target, anchor);
      }
      insert(target, t4, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (before_title_slot) {
        if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            before_title_slot,
            before_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              before_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_before_title_slot_changes_1
            ),
            get_before_title_slot_context_1
          );
        }
      }
      if (
        /*hasTitle*/
        ctx2[35] || /*hasHeader*/
        ctx2[34] || /*hasFooter*/
        ctx2[33]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/
          28) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_20(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (after_title_slot) {
        if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_title_slot,
            after_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_title_slot_changes_1
            ),
            get_after_title_slot_context_1
          );
        }
      }
      if (
        /*hasAfter*/
        ctx2[30]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*hasAfter*/
          1073741824) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_17(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t3.parentNode, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (inner_slot) {
        if (inner_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_slot,
            inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_slot_changes_1
            ),
            get_inner_slot_context_1
          );
        }
      }
      if (!/*swipeout*/
      (ctx2[13] || /*accordionItem*/
      ctx2[15])) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*swipeout, accordionItem*/
          40960) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_16(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(before_title_slot, local);
      transition_in(if_block0);
      transition_in(after_title_slot, local);
      transition_in(if_block1);
      transition_in(inner_slot, local);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(before_title_slot, local);
      transition_out(if_block0);
      transition_out(after_title_slot, local);
      transition_out(if_block1);
      transition_out(inner_slot, local);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(if_block2_anchor);
      }
      if (before_title_slot) before_title_slot.d(detaching);
      if (if_block0) if_block0.d(detaching);
      if (after_title_slot) after_title_slot.d(detaching);
      if (if_block1) if_block1.d(detaching);
      if (inner_slot) inner_slot.d(detaching);
      if (if_block2) if_block2.d(detaching);
    }
  };
}
function create_if_block_6(ctx) {
  let t0;
  let div;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let t6;
  let t7;
  let t8;
  let if_block6_anchor;
  let current;
  let if_block0 = (
    /*hasHeader*/
    ctx[34] && create_if_block_15(ctx)
  );
  const before_title_slot_template = (
    /*#slots*/
    ctx[69]["before-title"]
  );
  const before_title_slot = create_slot(
    before_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_before_title_slot_context
  );
  let if_block1 = (
    /*hasTitle*/
    ctx[35] && create_if_block_14(ctx)
  );
  const after_title_slot_template = (
    /*#slots*/
    ctx[69]["after-title"]
  );
  const after_title_slot = create_slot(
    after_title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_title_slot_context
  );
  let if_block2 = (
    /*hasAfter*/
    ctx[30] && create_if_block_11(ctx)
  );
  let if_block3 = (
    /*hasSubtitle*/
    ctx[32] && create_if_block_10(ctx)
  );
  let if_block4 = (
    /*hasText*/
    ctx[31] && create_if_block_9(ctx)
  );
  const inner_slot_template = (
    /*#slots*/
    ctx[69].inner
  );
  const inner_slot = create_slot(
    inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_inner_slot_context
  );
  let if_block5 = !/*swipeout*/
  (ctx[13] || /*accordionItem*/
  ctx[15]) && create_if_block_8(ctx);
  let if_block6 = (
    /*hasFooter*/
    ctx[33] && create_if_block_7(ctx)
  );
  return {
    c() {
      if (if_block0) if_block0.c();
      t0 = space();
      div = element("div");
      if (before_title_slot) before_title_slot.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      if (after_title_slot) after_title_slot.c();
      t3 = space();
      if (if_block2) if_block2.c();
      t4 = space();
      if (if_block3) if_block3.c();
      t5 = space();
      if (if_block4) if_block4.c();
      t6 = space();
      if (inner_slot) inner_slot.c();
      t7 = space();
      if (if_block5) if_block5.c();
      t8 = space();
      if (if_block6) if_block6.c();
      if_block6_anchor = empty();
      attr(div, "class", "item-title-row");
    },
    m(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, div, anchor);
      if (before_title_slot) {
        before_title_slot.m(div, null);
      }
      append(div, t1);
      if (if_block1) if_block1.m(div, null);
      append(div, t2);
      if (after_title_slot) {
        after_title_slot.m(div, null);
      }
      append(div, t3);
      if (if_block2) if_block2.m(div, null);
      insert(target, t4, anchor);
      if (if_block3) if_block3.m(target, anchor);
      insert(target, t5, anchor);
      if (if_block4) if_block4.m(target, anchor);
      insert(target, t6, anchor);
      if (inner_slot) {
        inner_slot.m(target, anchor);
      }
      insert(target, t7, anchor);
      if (if_block5) if_block5.m(target, anchor);
      insert(target, t8, anchor);
      if (if_block6) if_block6.m(target, anchor);
      insert(target, if_block6_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*hasHeader*/
        ctx2[34]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & /*hasHeader*/
          8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_15(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (before_title_slot) {
        if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            before_title_slot,
            before_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              before_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_before_title_slot_changes
            ),
            get_before_title_slot_context
          );
        }
      }
      if (
        /*hasTitle*/
        ctx2[35]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasTitle*/
          16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_14(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (after_title_slot) {
        if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_title_slot,
            after_title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_title_slot_changes
            ),
            get_after_title_slot_context
          );
        }
      }
      if (
        /*hasAfter*/
        ctx2[30]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*hasAfter*/
          1073741824) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_11(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*hasSubtitle*/
        ctx2[32]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[1] & /*hasSubtitle*/
          2) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_10(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(t5.parentNode, t5);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (
        /*hasText*/
        ctx2[31]
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[1] & /*hasText*/
          1) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_9(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(t6.parentNode, t6);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (inner_slot) {
        if (inner_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            inner_slot,
            inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              inner_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_inner_slot_changes
            ),
            get_inner_slot_context
          );
        }
      }
      if (!/*swipeout*/
      (ctx2[13] || /*accordionItem*/
      ctx2[15])) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty[0] & /*swipeout, accordionItem*/
          40960) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block_8(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(t8.parentNode, t8);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      if (
        /*hasFooter*/
        ctx2[33]
      ) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
          if (dirty[1] & /*hasFooter*/
          4) {
            transition_in(if_block6, 1);
          }
        } else {
          if_block6 = create_if_block_7(ctx2);
          if_block6.c();
          transition_in(if_block6, 1);
          if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
        }
      } else if (if_block6) {
        group_outros();
        transition_out(if_block6, 1, 1, () => {
          if_block6 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(before_title_slot, local);
      transition_in(if_block1);
      transition_in(after_title_slot, local);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(inner_slot, local);
      transition_in(if_block5);
      transition_in(if_block6);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(before_title_slot, local);
      transition_out(if_block1);
      transition_out(after_title_slot, local);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(inner_slot, local);
      transition_out(if_block5);
      transition_out(if_block6);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div);
        detach(t4);
        detach(t5);
        detach(t6);
        detach(t7);
        detach(t8);
        detach(if_block6_anchor);
      }
      if (if_block0) if_block0.d(detaching);
      if (before_title_slot) before_title_slot.d(detaching);
      if (if_block1) if_block1.d();
      if (after_title_slot) after_title_slot.d(detaching);
      if (if_block2) if_block2.d();
      if (if_block3) if_block3.d(detaching);
      if (if_block4) if_block4.d(detaching);
      if (inner_slot) inner_slot.d(detaching);
      if (if_block5) if_block5.d(detaching);
      if (if_block6) if_block6.d(detaching);
    }
  };
}
function create_if_block_20(ctx) {
  let div;
  let t0;
  let t1_value = plainText(
    /*title*/
    ctx[1]
  ) + "";
  let t1;
  let t2;
  let t3;
  let current;
  let if_block0 = (
    /*hasHeader*/
    ctx[34] && create_if_block_22(ctx)
  );
  const title_slot_template = (
    /*#slots*/
    ctx[69].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_title_slot_context_1
  );
  let if_block1 = (
    /*hasFooter*/
    ctx[33] && create_if_block_21(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block0) if_block0.c();
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      if (title_slot) title_slot.c();
      t3 = space();
      if (if_block1) if_block1.c();
      attr(div, "class", "item-title");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0) if_block0.m(div, null);
      append(div, t0);
      append(div, t1);
      append(div, t2);
      if (title_slot) {
        title_slot.m(div, null);
      }
      append(div, t3);
      if (if_block1) if_block1.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*hasHeader*/
        ctx2[34]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & /*hasHeader*/
          8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_22(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if ((!current || dirty[0] & /*title*/
      2) && t1_value !== (t1_value = plainText(
        /*title*/
        ctx2[1]
      ) + "")) set_data(t1, t1_value);
      if (title_slot) {
        if (title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_title_slot_changes_1
            ),
            get_title_slot_context_1
          );
        }
      }
      if (
        /*hasFooter*/
        ctx2[33]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & /*hasFooter*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_21(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(title_slot, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(title_slot, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block0) if_block0.d();
      if (title_slot) title_slot.d(detaching);
      if (if_block1) if_block1.d();
    }
  };
}
function create_if_block_22(ctx) {
  let div;
  let t0_value = plainText(
    /*header*/
    ctx[5]
  ) + "";
  let t0;
  let t1;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[69].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_header_slot_context_1
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (header_slot) header_slot.c();
      attr(div, "class", "item-header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (header_slot) {
        header_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*header*/
      32) && t0_value !== (t0_value = plainText(
        /*header*/
        ctx2[5]
      ) + "")) set_data(t0, t0_value);
      if (header_slot) {
        if (header_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_header_slot_changes_1
            ),
            get_header_slot_context_1
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(header_slot, local);
      current = true;
    },
    o(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (header_slot) header_slot.d(detaching);
    }
  };
}
function create_if_block_21(ctx) {
  let div;
  let t0_value = plainText(
    /*footer*/
    ctx[6]
  ) + "";
  let t0;
  let t1;
  let current;
  const footer_slot_template = (
    /*#slots*/
    ctx[69].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_footer_slot_context_1
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (footer_slot) footer_slot.c();
      attr(div, "class", "item-footer");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (footer_slot) {
        footer_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*footer*/
      64) && t0_value !== (t0_value = plainText(
        /*footer*/
        ctx2[6]
      ) + "")) set_data(t0, t0_value);
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_footer_slot_changes_1
            ),
            get_footer_slot_context_1
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(footer_slot, local);
      current = true;
    },
    o(local) {
      transition_out(footer_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (footer_slot) footer_slot.d(detaching);
    }
  };
}
function create_if_block_17(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  let t3;
  let current;
  const after_start_slot_template = (
    /*#slots*/
    ctx[69]["after-start"]
  );
  const after_start_slot = create_slot(
    after_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_start_slot_context_1
  );
  let if_block0 = typeof /*after*/
  ctx[9] !== "undefined" && create_if_block_19(ctx);
  let if_block1 = typeof /*badge*/
  ctx[10] !== "undefined" && create_if_block_18(ctx);
  const after_slot_template = (
    /*#slots*/
    ctx[69].after
  );
  const after_slot = create_slot(
    after_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_slot_context_1
  );
  const after_end_slot_template = (
    /*#slots*/
    ctx[69]["after-end"]
  );
  const after_end_slot = create_slot(
    after_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_end_slot_context_1
  );
  return {
    c() {
      div = element("div");
      if (after_start_slot) after_start_slot.c();
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      if (after_slot) after_slot.c();
      t3 = space();
      if (after_end_slot) after_end_slot.c();
      attr(div, "class", "item-after");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (after_start_slot) {
        after_start_slot.m(div, null);
      }
      append(div, t0);
      if (if_block0) if_block0.m(div, null);
      append(div, t1);
      if (if_block1) if_block1.m(div, null);
      append(div, t2);
      if (after_slot) {
        after_slot.m(div, null);
      }
      append(div, t3);
      if (after_end_slot) {
        after_end_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (after_start_slot) {
        if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_start_slot,
            after_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_start_slot_changes_1
            ),
            get_after_start_slot_context_1
          );
        }
      }
      if (typeof /*after*/
      ctx2[9] !== "undefined") {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_19(ctx2);
          if_block0.c();
          if_block0.m(div, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (typeof /*badge*/
      ctx2[10] !== "undefined") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*badge*/
          1024) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_18(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (after_slot) {
        if (after_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_slot,
            after_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_slot_changes_1
            ),
            get_after_slot_context_1
          );
        }
      }
      if (after_end_slot) {
        if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_end_slot,
            after_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_end_slot_changes_1
            ),
            get_after_end_slot_context_1
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(after_start_slot, local);
      transition_in(if_block1);
      transition_in(after_slot, local);
      transition_in(after_end_slot, local);
      current = true;
    },
    o(local) {
      transition_out(after_start_slot, local);
      transition_out(if_block1);
      transition_out(after_slot, local);
      transition_out(after_end_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (after_start_slot) after_start_slot.d(detaching);
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (after_slot) after_slot.d(detaching);
      if (after_end_slot) after_end_slot.d(detaching);
    }
  };
}
function create_if_block_19(ctx) {
  let span;
  let t_value = plainText(
    /*after*/
    ctx[9]
  ) + "";
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*after*/
      512 && t_value !== (t_value = plainText(
        /*after*/
        ctx2[9]
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_18(ctx) {
  let badge_1;
  let current;
  badge_1 = new Badge({
    props: {
      color: (
        /*badgeColor*/
        ctx[11]
      ),
      $$slots: { default: [create_default_slot_1$6] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(badge_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(badge_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const badge_1_changes = {};
      if (dirty[0] & /*badgeColor*/
      2048) badge_1_changes.color = /*badgeColor*/
      ctx2[11];
      if (dirty[0] & /*badge*/
      1024 | dirty[2] & /*$$scope*/
      2097152) {
        badge_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      badge_1.$set(badge_1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(badge_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(badge_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(badge_1, detaching);
    }
  };
}
function create_default_slot_1$6(ctx) {
  let t_value = plainText(
    /*badge*/
    ctx[10]
  ) + "";
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*badge*/
      1024 && t_value !== (t_value = plainText(
        /*badge*/
        ctx2[10]
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_16(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[69].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    null
  );
  return {
    c() {
      if (default_slot) default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function create_if_block_15(ctx) {
  let div;
  let t0_value = plainText(
    /*header*/
    ctx[5]
  ) + "";
  let t0;
  let t1;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[69].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_header_slot_context
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (header_slot) header_slot.c();
      attr(div, "class", "item-header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (header_slot) {
        header_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*header*/
      32) && t0_value !== (t0_value = plainText(
        /*header*/
        ctx2[5]
      ) + "")) set_data(t0, t0_value);
      if (header_slot) {
        if (header_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_header_slot_changes
            ),
            get_header_slot_context
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(header_slot, local);
      current = true;
    },
    o(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (header_slot) header_slot.d(detaching);
    }
  };
}
function create_if_block_14(ctx) {
  let div;
  let t0_value = plainText(
    /*title*/
    ctx[1]
  ) + "";
  let t0;
  let t1;
  let current;
  const title_slot_template = (
    /*#slots*/
    ctx[69].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_title_slot_context$1
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (title_slot) title_slot.c();
      attr(div, "class", "item-title");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (title_slot) {
        title_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*title*/
      2) && t0_value !== (t0_value = plainText(
        /*title*/
        ctx2[1]
      ) + "")) set_data(t0, t0_value);
      if (title_slot) {
        if (title_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_title_slot_changes$1
            ),
            get_title_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(title_slot, local);
      current = true;
    },
    o(local) {
      transition_out(title_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (title_slot) title_slot.d(detaching);
    }
  };
}
function create_if_block_11(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  let t3;
  let current;
  const after_start_slot_template = (
    /*#slots*/
    ctx[69]["after-start"]
  );
  const after_start_slot = create_slot(
    after_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_start_slot_context
  );
  let if_block0 = typeof /*after*/
  ctx[9] !== "undefined" && create_if_block_13(ctx);
  let if_block1 = typeof /*badge*/
  ctx[10] !== "undefined" && create_if_block_12(ctx);
  const after_slot_template = (
    /*#slots*/
    ctx[69].after
  );
  const after_slot = create_slot(
    after_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_slot_context
  );
  const after_end_slot_template = (
    /*#slots*/
    ctx[69]["after-end"]
  );
  const after_end_slot = create_slot(
    after_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_after_end_slot_context
  );
  return {
    c() {
      div = element("div");
      if (after_start_slot) after_start_slot.c();
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      if (after_slot) after_slot.c();
      t3 = space();
      if (after_end_slot) after_end_slot.c();
      attr(div, "class", "item-after");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (after_start_slot) {
        after_start_slot.m(div, null);
      }
      append(div, t0);
      if (if_block0) if_block0.m(div, null);
      append(div, t1);
      if (if_block1) if_block1.m(div, null);
      append(div, t2);
      if (after_slot) {
        after_slot.m(div, null);
      }
      append(div, t3);
      if (after_end_slot) {
        after_end_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (after_start_slot) {
        if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_start_slot,
            after_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_start_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_start_slot_changes
            ),
            get_after_start_slot_context
          );
        }
      }
      if (typeof /*after*/
      ctx2[9] !== "undefined") {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_13(ctx2);
          if_block0.c();
          if_block0.m(div, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (typeof /*badge*/
      ctx2[10] !== "undefined") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*badge*/
          1024) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_12(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (after_slot) {
        if (after_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_slot,
            after_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_slot_changes
            ),
            get_after_slot_context
          );
        }
      }
      if (after_end_slot) {
        if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            after_end_slot,
            after_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              after_end_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_after_end_slot_changes
            ),
            get_after_end_slot_context
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(after_start_slot, local);
      transition_in(if_block1);
      transition_in(after_slot, local);
      transition_in(after_end_slot, local);
      current = true;
    },
    o(local) {
      transition_out(after_start_slot, local);
      transition_out(if_block1);
      transition_out(after_slot, local);
      transition_out(after_end_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (after_start_slot) after_start_slot.d(detaching);
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (after_slot) after_slot.d(detaching);
      if (after_end_slot) after_end_slot.d(detaching);
    }
  };
}
function create_if_block_13(ctx) {
  let span;
  let t_value = plainText(
    /*after*/
    ctx[9]
  ) + "";
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*after*/
      512 && t_value !== (t_value = plainText(
        /*after*/
        ctx2[9]
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_12(ctx) {
  let badge_1;
  let current;
  badge_1 = new Badge({
    props: {
      color: (
        /*badgeColor*/
        ctx[11]
      ),
      $$slots: { default: [create_default_slot$8] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(badge_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(badge_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const badge_1_changes = {};
      if (dirty[0] & /*badgeColor*/
      2048) badge_1_changes.color = /*badgeColor*/
      ctx2[11];
      if (dirty[0] & /*badge*/
      1024 | dirty[2] & /*$$scope*/
      2097152) {
        badge_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      badge_1.$set(badge_1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(badge_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(badge_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(badge_1, detaching);
    }
  };
}
function create_default_slot$8(ctx) {
  let t_value = plainText(
    /*badge*/
    ctx[10]
  ) + "";
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*badge*/
      1024 && t_value !== (t_value = plainText(
        /*badge*/
        ctx2[10]
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_10(ctx) {
  let div;
  let t0_value = plainText(
    /*subtitle*/
    ctx[4]
  ) + "";
  let t0;
  let t1;
  let current;
  const subtitle_slot_template = (
    /*#slots*/
    ctx[69].subtitle
  );
  const subtitle_slot = create_slot(
    subtitle_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_subtitle_slot_context
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (subtitle_slot) subtitle_slot.c();
      attr(div, "class", "item-subtitle");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (subtitle_slot) {
        subtitle_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*subtitle*/
      16) && t0_value !== (t0_value = plainText(
        /*subtitle*/
        ctx2[4]
      ) + "")) set_data(t0, t0_value);
      if (subtitle_slot) {
        if (subtitle_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            subtitle_slot,
            subtitle_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              subtitle_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_subtitle_slot_changes
            ),
            get_subtitle_slot_context
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(subtitle_slot, local);
      current = true;
    },
    o(local) {
      transition_out(subtitle_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (subtitle_slot) subtitle_slot.d(detaching);
    }
  };
}
function create_if_block_9(ctx) {
  let div;
  let t0_value = plainText(
    /*text*/
    ctx[2]
  ) + "";
  let t0;
  let t1;
  let current;
  const text_slot_template = (
    /*#slots*/
    ctx[69].text
  );
  const text_slot = create_slot(
    text_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_text_slot_context
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (text_slot) text_slot.c();
      attr(div, "class", "item-text");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (text_slot) {
        text_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*text*/
      4) && t0_value !== (t0_value = plainText(
        /*text*/
        ctx2[2]
      ) + "")) set_data(t0, t0_value);
      if (text_slot) {
        if (text_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            text_slot,
            text_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              text_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_text_slot_changes
            ),
            get_text_slot_context
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(text_slot, local);
      current = true;
    },
    o(local) {
      transition_out(text_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (text_slot) text_slot.d(detaching);
    }
  };
}
function create_if_block_8(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[69].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    null
  );
  return {
    c() {
      if (default_slot) default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function create_if_block_7(ctx) {
  let div;
  let t0_value = plainText(
    /*footer*/
    ctx[6]
  ) + "";
  let t0;
  let t1;
  let current;
  const footer_slot_template = (
    /*#slots*/
    ctx[69].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    get_footer_slot_context
  );
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (footer_slot) footer_slot.c();
      attr(div, "class", "item-footer");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (footer_slot) {
        footer_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*footer*/
      64) && t0_value !== (t0_value = plainText(
        /*footer*/
        ctx2[6]
      ) + "")) set_data(t0, t0_value);
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              get_footer_slot_changes
            ),
            get_footer_slot_context
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(footer_slot, local);
      current = true;
    },
    o(local) {
      transition_out(footer_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (footer_slot) footer_slot.d(detaching);
    }
  };
}
function create_if_block_3$2(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "sortable-handler");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block_2$3(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[69].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[83],
    null
  );
  return {
    c() {
      if (default_slot) default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[83],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[83]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[83],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function fallback_block(ctx) {
  let t_value = plainText(
    /*title*/
    ctx[1]
  ) + "";
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*title*/
      2 && t_value !== (t_value = plainText(
        /*title*/
        ctx2[1]
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_fragment$g(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$8, create_if_block_1$4, create_else_block$2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*groupTitle*/
      ctx2[12]
    ) return 0;
    if (
      /*isSimple*/
      ctx2[42]
    ) return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance$h($$self, $$props, $$invalidate) {
  let isMedia;
  let isSortable;
  let isSortableOpposite;
  let isSimple;
  let liClasses;
  let contentClasses;
  let linkClasses;
  let linkAttrs;
  let isLink;
  let hasMedia;
  let hasTitle;
  let hasHeader;
  let hasFooter;
  let hasSubtitle;
  let hasText;
  let hasAfter;
  const omit_props_names = [
    "class",
    "title",
    "text",
    "media",
    "subtitle",
    "header",
    "footer",
    "tooltip",
    "tooltipTrigger",
    "link",
    "tabLink",
    "tabLinkActive",
    "selected",
    "href",
    "target",
    "after",
    "badge",
    "badgeColor",
    "mediaItem",
    "mediaList",
    "groupTitle",
    "swipeout",
    "swipeoutOpened",
    "sortable",
    "sortableOpposite",
    "accordionItem",
    "accordionItemOpened",
    "smartSelect",
    "smartSelectParams",
    "noChevron",
    "chevronCenter",
    "checkbox",
    "checkboxIcon",
    "radio",
    "radioIcon",
    "checked",
    "indeterminate",
    "name",
    "value",
    "readonly",
    "required",
    "disabled",
    "virtualListIndex",
    "routeProps",
    "smartSelectInstance"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { title = void 0 } = $$props;
  let { text: text2 = void 0 } = $$props;
  let { media = void 0 } = $$props;
  let { subtitle = void 0 } = $$props;
  let { header = void 0 } = $$props;
  let { footer = void 0 } = $$props;
  let { tooltip = void 0 } = $$props;
  let { tooltipTrigger = void 0 } = $$props;
  let { link = void 0 } = $$props;
  let { tabLink = void 0 } = $$props;
  let { tabLinkActive = false } = $$props;
  let { selected = false } = $$props;
  let { href = void 0 } = $$props;
  let { target = void 0 } = $$props;
  let { after = void 0 } = $$props;
  let { badge = void 0 } = $$props;
  let { badgeColor = void 0 } = $$props;
  let { mediaItem = false } = $$props;
  let { mediaList = false } = $$props;
  let { groupTitle = false } = $$props;
  let { swipeout = false } = $$props;
  let { swipeoutOpened = false } = $$props;
  let { sortable = void 0 } = $$props;
  let { sortableOpposite = void 0 } = $$props;
  let { accordionItem = false } = $$props;
  let { accordionItemOpened = false } = $$props;
  let { smartSelect = false } = $$props;
  let { smartSelectParams = void 0 } = $$props;
  let { noChevron = void 0 } = $$props;
  let { chevronCenter = void 0 } = $$props;
  let { checkbox = void 0 } = $$props;
  let { checkboxIcon = void 0 } = $$props;
  let { radio = void 0 } = $$props;
  let { radioIcon = void 0 } = $$props;
  let { checked = void 0 } = $$props;
  let { indeterminate = void 0 } = $$props;
  let { name = void 0 } = $$props;
  let { value: value2 = void 0 } = $$props;
  let { readonly = void 0 } = $$props;
  let { required = void 0 } = $$props;
  let { disabled = void 0 } = $$props;
  let { virtualListIndex = void 0 } = $$props;
  let { routeProps = void 0 } = $$props;
  let el;
  let linkEl;
  let innerEl;
  let inputEl;
  let f7SmartSelect;
  function smartSelectInstance() {
    return f7SmartSelect;
  }
  let ListContext = getReactiveContext("ListContext", (value3) => {
    $$invalidate(68, ListContext = value3 || {});
  }) || {};
  let initialWatchedOpened = false;
  function watchSwipeoutOpened(opened) {
    if (!initialWatchedOpened) {
      initialWatchedOpened = true;
      return;
    }
    if (!swipeout) return;
    if (opened) {
      app.f7.swipeout.open(el);
    } else {
      app.f7.swipeout.close(el);
    }
  }
  function onClick(event) {
    if (event.target.tagName.toLowerCase() !== "input") {
      emit("click", event);
    }
  }
  function onSwipeoutOverswipeEnter(eventEl) {
    if (eventEl !== el) return;
    emit("swipeoutOverswipeEnter");
  }
  function onSwipeoutOverswipeExit(eventEl) {
    if (eventEl !== el) return;
    emit("swipeoutOverswipeExit");
  }
  function onSwipeoutDeleted(eventEl) {
    if (eventEl !== el) return;
    emit("swipeoutDeleted");
  }
  function onSwipeoutDelete(eventEl) {
    if (eventEl !== el) return;
    emit("swipeoutDelete");
  }
  function onSwipeoutClose(eventEl) {
    if (eventEl !== el) return;
    emit("swipeoutClose");
  }
  function onSwipeoutClosed(eventEl) {
    if (eventEl !== el) return;
    emit("swipeoutClosed");
  }
  function onSwipeoutOpen(eventEl) {
    if (eventEl !== el) return;
    emit("swipeoutOpen");
  }
  function onSwipeoutOpened(eventEl) {
    if (eventEl !== el) return;
    emit("swipeoutOpened");
  }
  function onSwipeout(eventEl, progress) {
    if (eventEl !== el) return;
    emit("swipeout", progress);
  }
  function onAccBeforeClose(eventEl, prevent) {
    if (eventEl !== el) return;
    emit("accordionBeforeClose", [prevent]);
  }
  function onAccClose(eventEl) {
    if (eventEl !== el) return;
    emit("accordionClose");
  }
  function onAccClosed(eventEl) {
    if (eventEl !== el) return;
    emit("accordionClosed");
  }
  function onAccBeforeOpen(eventEl, prevent) {
    if (eventEl !== el) return;
    emit("accordionBeforeOpen", [prevent]);
  }
  function onAccOpen(eventEl) {
    if (eventEl !== el) return;
    emit("accordionOpen");
  }
  function onAccOpened(eventEl) {
    if (eventEl !== el) return;
    emit("accordionOpened");
  }
  function onChange(event) {
    emit("change", [event]);
    $$invalidate(0, checked = event.target.checked);
  }
  useSmartSelect(
    { smartSelect, smartSelectParams },
    (instance2) => {
      f7SmartSelect = instance2;
    },
    () => linkEl
  );
  onMount(() => {
    if (indeterminate && inputEl) {
      $$invalidate(29, inputEl.indeterminate = true, inputEl);
    }
    f7ready(() => {
      if (swipeout) {
        app.f7.on("swipeoutOpen", onSwipeoutOpen);
        app.f7.on("swipeoutOpened", onSwipeoutOpened);
        app.f7.on("swipeoutClose", onSwipeoutClose);
        app.f7.on("swipeoutClosed", onSwipeoutClosed);
        app.f7.on("swipeoutDelete", onSwipeoutDelete);
        app.f7.on("swipeoutDeleted", onSwipeoutDeleted);
        app.f7.on("swipeoutOverswipeEnter", onSwipeoutOverswipeEnter);
        app.f7.on("swipeoutOverswipeExit", onSwipeoutOverswipeExit);
        app.f7.on("swipeout", onSwipeout);
      }
      if (accordionItem) {
        app.f7.on("accordionBeforeOpen", onAccBeforeOpen);
        app.f7.on("accordionOpen", onAccOpen);
        app.f7.on("accordionOpened", onAccOpened);
        app.f7.on("accordionBeforeClose", onAccBeforeClose);
        app.f7.on("accordionClose", onAccClose);
        app.f7.on("accordionClosed", onAccClosed);
      }
      if (swipeoutOpened) {
        app.f7.swipeout.open(el);
      }
    });
  });
  afterUpdate(() => {
    if (inputEl) {
      $$invalidate(29, inputEl.indeterminate = indeterminate, inputEl);
    }
  });
  onDestroy(() => {
    if (!app.f7) return;
    if (swipeout) {
      app.f7.off("swipeoutOpen", onSwipeoutOpen);
      app.f7.off("swipeoutOpened", onSwipeoutOpened);
      app.f7.off("swipeoutClose", onSwipeoutClose);
      app.f7.off("swipeoutClosed", onSwipeoutClosed);
      app.f7.off("swipeoutDelete", onSwipeoutDelete);
      app.f7.off("swipeoutDeleted", onSwipeoutDeleted);
      app.f7.off("swipeoutOverswipeEnter", onSwipeoutOverswipeEnter);
      app.f7.off("swipeoutOverswipeExit", onSwipeoutOverswipeExit);
      app.f7.off("swipeout", onSwipeout);
    }
    if (accordionItem) {
      app.f7.off("accordionBeforeOpen", onAccBeforeOpen);
      app.f7.off("accordionOpen", onAccOpen);
      app.f7.off("accordionOpened", onAccOpened);
      app.f7.off("accordionBeforeClose", onAccBeforeClose);
      app.f7.off("accordionClose", onAccClose);
      app.f7.off("accordionClosed", onAccClosed);
    }
  });
  function li_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(26, el);
    });
  }
  function li_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(26, el);
    });
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      innerEl = $$value;
      $$invalidate(28, innerEl);
    });
  }
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      linkEl = $$value;
      $$invalidate(27, linkEl);
    });
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputEl = $$value;
      $$invalidate(29, inputEl);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      innerEl = $$value;
      $$invalidate(28, innerEl);
    });
  }
  function div0_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      innerEl = $$value;
      $$invalidate(28, innerEl);
    });
  }
  function div0_binding_2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      innerEl = $$value;
      $$invalidate(28, innerEl);
    });
  }
  function a_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      linkEl = $$value;
      $$invalidate(27, linkEl);
    });
  }
  function input_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputEl = $$value;
      $$invalidate(29, inputEl);
    });
  }
  function div_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      innerEl = $$value;
      $$invalidate(28, innerEl);
    });
  }
  function div0_binding_3($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      innerEl = $$value;
      $$invalidate(28, innerEl);
    });
  }
  function li_binding_2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(26, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(104, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(47, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props) $$invalidate(48, className = $$new_props.class);
    if ("title" in $$new_props) $$invalidate(1, title = $$new_props.title);
    if ("text" in $$new_props) $$invalidate(2, text2 = $$new_props.text);
    if ("media" in $$new_props) $$invalidate(3, media = $$new_props.media);
    if ("subtitle" in $$new_props) $$invalidate(4, subtitle = $$new_props.subtitle);
    if ("header" in $$new_props) $$invalidate(5, header = $$new_props.header);
    if ("footer" in $$new_props) $$invalidate(6, footer = $$new_props.footer);
    if ("tooltip" in $$new_props) $$invalidate(7, tooltip = $$new_props.tooltip);
    if ("tooltipTrigger" in $$new_props) $$invalidate(8, tooltipTrigger = $$new_props.tooltipTrigger);
    if ("link" in $$new_props) $$invalidate(49, link = $$new_props.link);
    if ("tabLink" in $$new_props) $$invalidate(50, tabLink = $$new_props.tabLink);
    if ("tabLinkActive" in $$new_props) $$invalidate(51, tabLinkActive = $$new_props.tabLinkActive);
    if ("selected" in $$new_props) $$invalidate(52, selected = $$new_props.selected);
    if ("href" in $$new_props) $$invalidate(53, href = $$new_props.href);
    if ("target" in $$new_props) $$invalidate(54, target = $$new_props.target);
    if ("after" in $$new_props) $$invalidate(9, after = $$new_props.after);
    if ("badge" in $$new_props) $$invalidate(10, badge = $$new_props.badge);
    if ("badgeColor" in $$new_props) $$invalidate(11, badgeColor = $$new_props.badgeColor);
    if ("mediaItem" in $$new_props) $$invalidate(55, mediaItem = $$new_props.mediaItem);
    if ("mediaList" in $$new_props) $$invalidate(56, mediaList = $$new_props.mediaList);
    if ("groupTitle" in $$new_props) $$invalidate(12, groupTitle = $$new_props.groupTitle);
    if ("swipeout" in $$new_props) $$invalidate(13, swipeout = $$new_props.swipeout);
    if ("swipeoutOpened" in $$new_props) $$invalidate(57, swipeoutOpened = $$new_props.swipeoutOpened);
    if ("sortable" in $$new_props) $$invalidate(14, sortable = $$new_props.sortable);
    if ("sortableOpposite" in $$new_props) $$invalidate(58, sortableOpposite = $$new_props.sortableOpposite);
    if ("accordionItem" in $$new_props) $$invalidate(15, accordionItem = $$new_props.accordionItem);
    if ("accordionItemOpened" in $$new_props) $$invalidate(59, accordionItemOpened = $$new_props.accordionItemOpened);
    if ("smartSelect" in $$new_props) $$invalidate(60, smartSelect = $$new_props.smartSelect);
    if ("smartSelectParams" in $$new_props) $$invalidate(61, smartSelectParams = $$new_props.smartSelectParams);
    if ("noChevron" in $$new_props) $$invalidate(62, noChevron = $$new_props.noChevron);
    if ("chevronCenter" in $$new_props) $$invalidate(63, chevronCenter = $$new_props.chevronCenter);
    if ("checkbox" in $$new_props) $$invalidate(16, checkbox = $$new_props.checkbox);
    if ("checkboxIcon" in $$new_props) $$invalidate(64, checkboxIcon = $$new_props.checkboxIcon);
    if ("radio" in $$new_props) $$invalidate(17, radio = $$new_props.radio);
    if ("radioIcon" in $$new_props) $$invalidate(65, radioIcon = $$new_props.radioIcon);
    if ("checked" in $$new_props) $$invalidate(0, checked = $$new_props.checked);
    if ("indeterminate" in $$new_props) $$invalidate(66, indeterminate = $$new_props.indeterminate);
    if ("name" in $$new_props) $$invalidate(18, name = $$new_props.name);
    if ("value" in $$new_props) $$invalidate(19, value2 = $$new_props.value);
    if ("readonly" in $$new_props) $$invalidate(20, readonly = $$new_props.readonly);
    if ("required" in $$new_props) $$invalidate(21, required = $$new_props.required);
    if ("disabled" in $$new_props) $$invalidate(22, disabled = $$new_props.disabled);
    if ("virtualListIndex" in $$new_props) $$invalidate(23, virtualListIndex = $$new_props.virtualListIndex);
    if ("routeProps" in $$new_props) $$invalidate(24, routeProps = $$new_props.routeProps);
    if ("$$scope" in $$new_props) $$invalidate(83, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[1] & /*mediaList, mediaItem*/
    50331648 | $$self.$$.dirty[2] & /*ListContext*/
    64) {
      $$invalidate(25, isMedia = mediaList || mediaItem || ListContext.listIsMedia);
    }
    if ($$self.$$.dirty[0] & /*sortable*/
    16384 | $$self.$$.dirty[2] & /*ListContext*/
    64) {
      $$invalidate(44, isSortable = sortable === true || sortable === false ? sortable : ListContext.listIsSortable);
    }
    if ($$self.$$.dirty[1] & /*sortableOpposite*/
    134217728 | $$self.$$.dirty[2] & /*ListContext*/
    64) {
      $$invalidate(43, isSortableOpposite = sortableOpposite || ListContext.listIsSortableOpposite);
    }
    if ($$self.$$.dirty[2] & /*ListContext*/
    64) {
      $$invalidate(42, isSimple = ListContext.listIsSimple);
    }
    $$invalidate(41, liClasses = classNames(
      className,
      {
        "list-group-title": groupTitle,
        "media-item": isMedia,
        swipeout,
        "accordion-item": accordionItem,
        "accordion-item-opened": accordionItemOpened,
        disabled: disabled && !(radio || checkbox),
        "no-chevron": noChevron,
        "chevron-center": chevronCenter,
        "disallow-sorting": sortable === false
      },
      colorClasses($$props)
    ));
    $$invalidate(40, contentClasses = classNames(
      className,
      "item-content",
      {
        "item-checkbox": checkbox,
        "item-radio": radio,
        "item-checkbox-icon-start": checkbox && checkboxIcon === "start",
        "item-checkbox-icon-end": checkbox && checkboxIcon === "end",
        "item-radio-icon-start": radio && radioIcon === "start",
        "item-radio-icon-end": radio && radioIcon === "end"
      },
      colorClasses($$props)
    ));
    $$invalidate(39, linkClasses = classNames(
      {
        "item-link": true,
        "smart-select": smartSelect,
        "tab-link": tabLink || tabLink === "",
        "tab-link-active": tabLinkActive,
        "item-selected": selected
      },
      routerClasses($$props),
      actionsClasses($$props)
    ));
    $$invalidate(38, linkAttrs = {
      href: href === false ? void 0 : link === true ? href || "" : link || href,
      target,
      "data-tab": isStringProp(tabLink) && tabLink || void 0,
      ...routerAttrs($$props),
      ...actionsAttrs($$props)
    });
    if ($$self.$$.dirty[0] & /*accordionItem*/
    32768 | $$self.$$.dirty[1] & /*link, href, smartSelect*/
    541327360) {
      $$invalidate(37, isLink = link || href || smartSelect || accordionItem);
    }
    if ($$self.$$.dirty[0] & /*media*/
    8) {
      $$invalidate(36, hasMedia = typeof media !== "undefined" || $$slots.media);
    }
    if ($$self.$$.dirty[0] & /*title*/
    2) {
      $$invalidate(35, hasTitle = typeof title !== "undefined" || $$slots.title);
    }
    if ($$self.$$.dirty[0] & /*header*/
    32) {
      $$invalidate(34, hasHeader = typeof header !== "undefined" || $$slots.header);
    }
    if ($$self.$$.dirty[0] & /*footer*/
    64) {
      $$invalidate(33, hasFooter = typeof footer !== "undefined" || $$slots.footer);
    }
    if ($$self.$$.dirty[0] & /*subtitle*/
    16) {
      $$invalidate(32, hasSubtitle = typeof subtitle !== "undefined" || $$slots.subtitle);
    }
    if ($$self.$$.dirty[0] & /*text*/
    4) {
      $$invalidate(31, hasText = typeof text2 !== "undefined" || $$slots.text);
    }
    if ($$self.$$.dirty[0] & /*after, badge*/
    1536) {
      $$invalidate(30, hasAfter = typeof after !== "undefined" || typeof badge !== "undefined" || $$slots.after);
    }
    if ($$self.$$.dirty[1] & /*swipeoutOpened*/
    67108864) {
      watchSwipeoutOpened(swipeoutOpened);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    checked,
    title,
    text2,
    media,
    subtitle,
    header,
    footer,
    tooltip,
    tooltipTrigger,
    after,
    badge,
    badgeColor,
    groupTitle,
    swipeout,
    sortable,
    accordionItem,
    checkbox,
    radio,
    name,
    value2,
    readonly,
    required,
    disabled,
    virtualListIndex,
    routeProps,
    isMedia,
    el,
    linkEl,
    innerEl,
    inputEl,
    hasAfter,
    hasText,
    hasSubtitle,
    hasFooter,
    hasHeader,
    hasTitle,
    hasMedia,
    isLink,
    linkAttrs,
    linkClasses,
    contentClasses,
    liClasses,
    isSimple,
    isSortableOpposite,
    isSortable,
    onClick,
    onChange,
    $$restProps,
    className,
    link,
    tabLink,
    tabLinkActive,
    selected,
    href,
    target,
    mediaItem,
    mediaList,
    swipeoutOpened,
    sortableOpposite,
    accordionItemOpened,
    smartSelect,
    smartSelectParams,
    noChevron,
    chevronCenter,
    checkboxIcon,
    radioIcon,
    indeterminate,
    smartSelectInstance,
    ListContext,
    slots,
    li_binding,
    li_binding_1,
    div0_binding,
    a_binding,
    input_binding,
    div_binding,
    div0_binding_1,
    div0_binding_2,
    a_binding_1,
    input_binding_1,
    div_binding_1,
    div0_binding_3,
    li_binding_2,
    $$scope
  ];
}
class List_item extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$h,
      create_fragment$g,
      safe_not_equal,
      {
        class: 48,
        title: 1,
        text: 2,
        media: 3,
        subtitle: 4,
        header: 5,
        footer: 6,
        tooltip: 7,
        tooltipTrigger: 8,
        link: 49,
        tabLink: 50,
        tabLinkActive: 51,
        selected: 52,
        href: 53,
        target: 54,
        after: 9,
        badge: 10,
        badgeColor: 11,
        mediaItem: 55,
        mediaList: 56,
        groupTitle: 12,
        swipeout: 13,
        swipeoutOpened: 57,
        sortable: 14,
        sortableOpposite: 58,
        accordionItem: 15,
        accordionItemOpened: 59,
        smartSelect: 60,
        smartSelectParams: 61,
        noChevron: 62,
        chevronCenter: 63,
        checkbox: 16,
        checkboxIcon: 64,
        radio: 17,
        radioIcon: 65,
        checked: 0,
        indeterminate: 66,
        name: 18,
        value: 19,
        readonly: 20,
        required: 21,
        disabled: 22,
        virtualListIndex: 23,
        routeProps: 24,
        smartSelectInstance: 67
      },
      null,
      [-1, -1, -1, -1]
    );
  }
  get smartSelectInstance() {
    return this.$$.ctx[67];
  }
}
const get_after_list_slot_changes_1 = (dirty) => ({});
const get_after_list_slot_context_1 = (ctx) => ({});
const get_list_slot_changes_1 = (dirty) => ({});
const get_list_slot_context_1 = (ctx) => ({});
const get_before_list_slot_changes_1 = (dirty) => ({});
const get_before_list_slot_context_1 = (ctx) => ({});
const get_after_list_slot_changes = (dirty) => ({});
const get_after_list_slot_context = (ctx) => ({});
const get_list_slot_changes = (dirty) => ({});
const get_list_slot_context = (ctx) => ({});
const get_before_list_slot_changes = (dirty) => ({});
const get_before_list_slot_context = (ctx) => ({});
function create_else_block_1(ctx) {
  let div;
  let t0;
  let current_block_type_index;
  let if_block;
  let t1;
  let div_data_sortable_move_elements_value;
  let current;
  const before_list_slot_template = (
    /*#slots*/
    ctx[56]["before-list"]
  );
  const before_list_slot = create_slot(
    before_list_slot_template,
    ctx,
    /*$$scope*/
    ctx[55],
    get_before_list_slot_context_1
  );
  const if_block_creators = [create_if_block_2$2, create_else_block_2];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*hasUlSlots*/
      ctx2[5] && /*ul*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const after_list_slot_template = (
    /*#slots*/
    ctx[56]["after-list"]
  );
  const after_list_slot = create_slot(
    after_list_slot_template,
    ctx,
    /*$$scope*/
    ctx[55],
    get_after_list_slot_context_1
  );
  let div_levels = [
    { class: (
      /*classes*/
      ctx[4]
    ) },
    {
      "data-sortable-move-elements": div_data_sortable_move_elements_value = typeof /*sortableMoveElements*/
      ctx[1] !== "undefined" ? (
        /*sortableMoveElements*/
        ctx[1].toString()
      ) : void 0
    },
    restProps(
      /*$$restProps*/
      ctx[7]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  return {
    c() {
      div = element("div");
      if (before_list_slot) before_list_slot.c();
      t0 = space();
      if_block.c();
      t1 = space();
      if (after_list_slot) after_list_slot.c();
      set_attributes(div, div_data);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (before_list_slot) {
        before_list_slot.m(div, null);
      }
      append(div, t0);
      if_blocks[current_block_type_index].m(div, null);
      append(div, t1);
      if (after_list_slot) {
        after_list_slot.m(div, null);
      }
      ctx[58](div);
      current = true;
    },
    p(ctx2, dirty) {
      if (before_list_slot) {
        if (before_list_slot.p && (!current || dirty[1] & /*$$scope*/
        16777216)) {
          update_slot_base(
            before_list_slot,
            before_list_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[55],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[55]
            ) : get_slot_changes(
              before_list_slot_template,
              /*$$scope*/
              ctx2[55],
              dirty,
              get_before_list_slot_changes_1
            ),
            get_before_list_slot_context_1
          );
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, t1);
      }
      if (after_list_slot) {
        if (after_list_slot.p && (!current || dirty[1] & /*$$scope*/
        16777216)) {
          update_slot_base(
            after_list_slot,
            after_list_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[55],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[55]
            ) : get_slot_changes(
              after_list_slot_template,
              /*$$scope*/
              ctx2[55],
              dirty,
              get_after_list_slot_changes_1
            ),
            get_after_list_slot_context_1
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty[0] & /*classes*/
        16) && { class: (
          /*classes*/
          ctx2[4]
        ) },
        (!current || dirty[0] & /*sortableMoveElements*/
        2 && div_data_sortable_move_elements_value !== (div_data_sortable_move_elements_value = typeof /*sortableMoveElements*/
        ctx2[1] !== "undefined" ? (
          /*sortableMoveElements*/
          ctx2[1].toString()
        ) : void 0)) && {
          "data-sortable-move-elements": div_data_sortable_move_elements_value
        },
        dirty[0] & /*$$restProps*/
        128 && restProps(
          /*$$restProps*/
          ctx2[7]
        )
      ]));
    },
    i(local) {
      if (current) return;
      transition_in(before_list_slot, local);
      transition_in(if_block);
      transition_in(after_list_slot, local);
      current = true;
    },
    o(local) {
      transition_out(before_list_slot, local);
      transition_out(if_block);
      transition_out(after_list_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (before_list_slot) before_list_slot.d(detaching);
      if_blocks[current_block_type_index].d();
      if (after_list_slot) after_list_slot.d(detaching);
      ctx[58](null);
    }
  };
}
function create_if_block$7(ctx) {
  let form_1;
  let t0;
  let current_block_type_index;
  let if_block;
  let t1;
  let form_1_data_sortable_move_elements_value;
  let current;
  let mounted;
  let dispose;
  const before_list_slot_template = (
    /*#slots*/
    ctx[56]["before-list"]
  );
  const before_list_slot = create_slot(
    before_list_slot_template,
    ctx,
    /*$$scope*/
    ctx[55],
    get_before_list_slot_context
  );
  const if_block_creators = [create_if_block_1$3, create_else_block$1];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*hasUlSlots*/
      ctx2[5] && /*ul*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const after_list_slot_template = (
    /*#slots*/
    ctx[56]["after-list"]
  );
  const after_list_slot = create_slot(
    after_list_slot_template,
    ctx,
    /*$$scope*/
    ctx[55],
    get_after_list_slot_context
  );
  let form_1_levels = [
    { class: (
      /*classes*/
      ctx[4]
    ) },
    {
      "data-sortable-move-elements": form_1_data_sortable_move_elements_value = typeof /*sortableMoveElements*/
      ctx[1] !== "undefined" ? (
        /*sortableMoveElements*/
        ctx[1].toString()
      ) : void 0
    },
    restProps(
      /*$$restProps*/
      ctx[7]
    )
  ];
  let form_data = {};
  for (let i = 0; i < form_1_levels.length; i += 1) {
    form_data = assign(form_data, form_1_levels[i]);
  }
  return {
    c() {
      form_1 = element("form");
      if (before_list_slot) before_list_slot.c();
      t0 = space();
      if_block.c();
      t1 = space();
      if (after_list_slot) after_list_slot.c();
      set_attributes(form_1, form_data);
    },
    m(target, anchor) {
      insert(target, form_1, anchor);
      if (before_list_slot) {
        before_list_slot.m(form_1, null);
      }
      append(form_1, t0);
      if_blocks[current_block_type_index].m(form_1, null);
      append(form_1, t1);
      if (after_list_slot) {
        after_list_slot.m(form_1, null);
      }
      ctx[57](form_1);
      current = true;
      if (!mounted) {
        dispose = listen(
          form_1,
          "submit",
          /*onSubmit*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (before_list_slot) {
        if (before_list_slot.p && (!current || dirty[1] & /*$$scope*/
        16777216)) {
          update_slot_base(
            before_list_slot,
            before_list_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[55],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[55]
            ) : get_slot_changes(
              before_list_slot_template,
              /*$$scope*/
              ctx2[55],
              dirty,
              get_before_list_slot_changes
            ),
            get_before_list_slot_context
          );
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(form_1, t1);
      }
      if (after_list_slot) {
        if (after_list_slot.p && (!current || dirty[1] & /*$$scope*/
        16777216)) {
          update_slot_base(
            after_list_slot,
            after_list_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[55],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[55]
            ) : get_slot_changes(
              after_list_slot_template,
              /*$$scope*/
              ctx2[55],
              dirty,
              get_after_list_slot_changes
            ),
            get_after_list_slot_context
          );
        }
      }
      set_attributes(form_1, form_data = get_spread_update(form_1_levels, [
        (!current || dirty[0] & /*classes*/
        16) && { class: (
          /*classes*/
          ctx2[4]
        ) },
        (!current || dirty[0] & /*sortableMoveElements*/
        2 && form_1_data_sortable_move_elements_value !== (form_1_data_sortable_move_elements_value = typeof /*sortableMoveElements*/
        ctx2[1] !== "undefined" ? (
          /*sortableMoveElements*/
          ctx2[1].toString()
        ) : void 0)) && {
          "data-sortable-move-elements": form_1_data_sortable_move_elements_value
        },
        dirty[0] & /*$$restProps*/
        128 && restProps(
          /*$$restProps*/
          ctx2[7]
        )
      ]));
    },
    i(local) {
      if (current) return;
      transition_in(before_list_slot, local);
      transition_in(if_block);
      transition_in(after_list_slot, local);
      current = true;
    },
    o(local) {
      transition_out(before_list_slot, local);
      transition_out(if_block);
      transition_out(after_list_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(form_1);
      }
      if (before_list_slot) before_list_slot.d(detaching);
      if_blocks[current_block_type_index].d();
      if (after_list_slot) after_list_slot.d(detaching);
      ctx[57](null);
      mounted = false;
      dispose();
    }
  };
}
function create_else_block_2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[56].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[55],
    null
  );
  return {
    c() {
      if (default_slot) default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        16777216)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[55],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[55]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[55],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function create_if_block_2$2(ctx) {
  let ul_1;
  let t2;
  let current;
  const list_slot_template = (
    /*#slots*/
    ctx[56].list
  );
  const list_slot = create_slot(
    list_slot_template,
    ctx,
    /*$$scope*/
    ctx[55],
    get_list_slot_context_1
  );
  const default_slot_template = (
    /*#slots*/
    ctx[56].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[55],
    null
  );
  return {
    c() {
      ul_1 = element("ul");
      if (list_slot) list_slot.c();
      t2 = space();
      if (default_slot) default_slot.c();
    },
    m(target, anchor) {
      insert(target, ul_1, anchor);
      if (list_slot) {
        list_slot.m(ul_1, null);
      }
      append(ul_1, t2);
      if (default_slot) {
        default_slot.m(ul_1, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (list_slot) {
        if (list_slot.p && (!current || dirty[1] & /*$$scope*/
        16777216)) {
          update_slot_base(
            list_slot,
            list_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[55],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[55]
            ) : get_slot_changes(
              list_slot_template,
              /*$$scope*/
              ctx2[55],
              dirty,
              get_list_slot_changes_1
            ),
            get_list_slot_context_1
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        16777216)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[55],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[55]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[55],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(list_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(list_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(ul_1);
      }
      if (list_slot) list_slot.d(detaching);
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function create_else_block$1(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[56].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[55],
    null
  );
  return {
    c() {
      if (default_slot) default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        16777216)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[55],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[55]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[55],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function create_if_block_1$3(ctx) {
  let ul_1;
  let t2;
  let current;
  const list_slot_template = (
    /*#slots*/
    ctx[56].list
  );
  const list_slot = create_slot(
    list_slot_template,
    ctx,
    /*$$scope*/
    ctx[55],
    get_list_slot_context
  );
  const default_slot_template = (
    /*#slots*/
    ctx[56].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[55],
    null
  );
  return {
    c() {
      ul_1 = element("ul");
      if (list_slot) list_slot.c();
      t2 = space();
      if (default_slot) default_slot.c();
    },
    m(target, anchor) {
      insert(target, ul_1, anchor);
      if (list_slot) {
        list_slot.m(ul_1, null);
      }
      append(ul_1, t2);
      if (default_slot) {
        default_slot.m(ul_1, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (list_slot) {
        if (list_slot.p && (!current || dirty[1] & /*$$scope*/
        16777216)) {
          update_slot_base(
            list_slot,
            list_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[55],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[55]
            ) : get_slot_changes(
              list_slot_template,
              /*$$scope*/
              ctx2[55],
              dirty,
              get_list_slot_changes
            ),
            get_list_slot_context
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        16777216)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[55],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[55]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[55],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(list_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(list_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(ul_1);
      }
      if (list_slot) list_slot.d(detaching);
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function create_fragment$f(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$7, create_else_block_1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*form*/
      ctx2[2]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance$g($$self, $$props, $$invalidate) {
  let hasUlSlots;
  let classes;
  const omit_props_names = [
    "class",
    "ul",
    "inset",
    "insetIos",
    "insetMd",
    "xsmallInset",
    "xsmallInsetIos",
    "xsmallInsetMd",
    "smallInset",
    "smallInsetIos",
    "smallInsetMd",
    "mediumInset",
    "mediumInsetIos",
    "mediumInsetMd",
    "largeInset",
    "largeInsetIos",
    "largeInsetMd",
    "xlargeInset",
    "xlargeInsetIos",
    "xlargeInsetMd",
    "strong",
    "strongIos",
    "strongMd",
    "outline",
    "outlineIos",
    "outlineMd",
    "dividers",
    "dividersIos",
    "dividersMd",
    "mediaList",
    "sortable",
    "sortableTapHold",
    "sortableEnabled",
    "sortableMoveElements",
    "sortableOpposite",
    "accordionList",
    "accordionOpposite",
    "contactsList",
    "simpleList",
    "linksList",
    "menuList",
    "noChevron",
    "chevronCenter",
    "tab",
    "tabActive",
    "form",
    "formStoreData",
    "virtualList",
    "virtualListParams",
    "virtualListInstance"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { ul = true } = $$props;
  let { inset = false } = $$props;
  let { insetIos = false } = $$props;
  let { insetMd = false } = $$props;
  let { xsmallInset = false } = $$props;
  let { xsmallInsetIos = false } = $$props;
  let { xsmallInsetMd = false } = $$props;
  let { smallInset = false } = $$props;
  let { smallInsetIos = false } = $$props;
  let { smallInsetMd = false } = $$props;
  let { mediumInset = false } = $$props;
  let { mediumInsetIos = false } = $$props;
  let { mediumInsetMd = false } = $$props;
  let { largeInset = false } = $$props;
  let { largeInsetIos = false } = $$props;
  let { largeInsetMd = false } = $$props;
  let { xlargeInset = false } = $$props;
  let { xlargeInsetIos = false } = $$props;
  let { xlargeInsetMd = false } = $$props;
  let { strong = false } = $$props;
  let { strongIos = false } = $$props;
  let { strongMd = false } = $$props;
  let { outline = false } = $$props;
  let { outlineIos = false } = $$props;
  let { outlineMd = false } = $$props;
  let { dividers = false } = $$props;
  let { dividersIos = false } = $$props;
  let { dividersMd = false } = $$props;
  let { mediaList = false } = $$props;
  let { sortable = false } = $$props;
  let { sortableTapHold = false } = $$props;
  let { sortableEnabled = false } = $$props;
  let { sortableMoveElements = void 0 } = $$props;
  let { sortableOpposite = false } = $$props;
  let { accordionList = false } = $$props;
  let { accordionOpposite = false } = $$props;
  let { contactsList = false } = $$props;
  let { simpleList = false } = $$props;
  let { linksList = false } = $$props;
  let { menuList = false } = $$props;
  let { noChevron = false } = $$props;
  let { chevronCenter = false } = $$props;
  let { tab = false } = $$props;
  let { tabActive = false } = $$props;
  let { form = false } = $$props;
  let { formStoreData = false } = $$props;
  let { virtualList = false } = $$props;
  let { virtualListParams = void 0 } = $$props;
  let el;
  let f7VirtualList;
  function virtualListInstance() {
    return f7VirtualList;
  }
  setReactiveContext("ListContext", () => ({
    listIsMedia: mediaList,
    listIsSimple: simpleList,
    listIsSortable: sortable,
    listIsSortableOpposite: sortableOpposite
  }));
  function onSubmit(event) {
    emit("submit", [event]);
  }
  function onSortableEnable(sortableEl) {
    if (sortableEl !== el) return;
    emit("sortableEnable");
  }
  function onSortableDisable(sortableEl) {
    if (sortableEl !== el) return;
    emit("sortableDisable");
  }
  function onSortableSort(listItemEl, sortData, listEl) {
    if (listEl !== el) return;
    emit("sortableSort", [sortData]);
  }
  function onSortableMove(listItemEl, listEl) {
    if (listEl !== el) return;
    emit("sortableMove", [listItemEl, listEl]);
  }
  useTab(() => el, emit);
  onMount(() => {
    f7ready(() => {
      app.f7.on("sortableEnable", onSortableEnable);
      app.f7.on("sortableDisable", onSortableDisable);
      app.f7.on("sortableSort", onSortableSort);
      app.f7.on("sortableMove", onSortableMove);
      if (!virtualList) return;
      const vlParams = virtualListParams || {};
      if (!vlParams.renderItem && !vlParams.renderExternal) return;
      f7VirtualList = app.f7.virtualList.create(extend(
        {
          el,
          on: {
            itemBeforeInsert(itemEl, item) {
              const vl = this;
              emit("virtualItemBeforeInsert", [vl, itemEl, item]);
            },
            beforeClear(fragment) {
              const vl = this;
              emit("virtualBeforeClear", [vl, fragment]);
            },
            itemsBeforeInsert(fragment) {
              const vl = this;
              emit("virtualItemsBeforeInsert", [vl, fragment]);
            },
            itemsAfterInsert(fragment) {
              const vl = this;
              emit("virtualItemsAfterInsert", [vl, fragment]);
            }
          }
        },
        vlParams
      ));
    });
  });
  onDestroy(() => {
    if (!app.f7) return;
    app.f7.off("sortableEnable", onSortableEnable);
    app.f7.off("sortableDisable", onSortableDisable);
    app.f7.off("sortableSort", onSortableSort);
    app.f7.off("sortableMove", onSortableMove);
    if (f7VirtualList && f7VirtualList.destroy) {
      f7VirtualList.destroy();
      f7VirtualList = null;
    }
  });
  function form_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(3, el);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(3, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(65, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props) $$invalidate(8, className = $$new_props.class);
    if ("ul" in $$new_props) $$invalidate(0, ul = $$new_props.ul);
    if ("inset" in $$new_props) $$invalidate(9, inset = $$new_props.inset);
    if ("insetIos" in $$new_props) $$invalidate(10, insetIos = $$new_props.insetIos);
    if ("insetMd" in $$new_props) $$invalidate(11, insetMd = $$new_props.insetMd);
    if ("xsmallInset" in $$new_props) $$invalidate(12, xsmallInset = $$new_props.xsmallInset);
    if ("xsmallInsetIos" in $$new_props) $$invalidate(13, xsmallInsetIos = $$new_props.xsmallInsetIos);
    if ("xsmallInsetMd" in $$new_props) $$invalidate(14, xsmallInsetMd = $$new_props.xsmallInsetMd);
    if ("smallInset" in $$new_props) $$invalidate(15, smallInset = $$new_props.smallInset);
    if ("smallInsetIos" in $$new_props) $$invalidate(16, smallInsetIos = $$new_props.smallInsetIos);
    if ("smallInsetMd" in $$new_props) $$invalidate(17, smallInsetMd = $$new_props.smallInsetMd);
    if ("mediumInset" in $$new_props) $$invalidate(18, mediumInset = $$new_props.mediumInset);
    if ("mediumInsetIos" in $$new_props) $$invalidate(19, mediumInsetIos = $$new_props.mediumInsetIos);
    if ("mediumInsetMd" in $$new_props) $$invalidate(20, mediumInsetMd = $$new_props.mediumInsetMd);
    if ("largeInset" in $$new_props) $$invalidate(21, largeInset = $$new_props.largeInset);
    if ("largeInsetIos" in $$new_props) $$invalidate(22, largeInsetIos = $$new_props.largeInsetIos);
    if ("largeInsetMd" in $$new_props) $$invalidate(23, largeInsetMd = $$new_props.largeInsetMd);
    if ("xlargeInset" in $$new_props) $$invalidate(24, xlargeInset = $$new_props.xlargeInset);
    if ("xlargeInsetIos" in $$new_props) $$invalidate(25, xlargeInsetIos = $$new_props.xlargeInsetIos);
    if ("xlargeInsetMd" in $$new_props) $$invalidate(26, xlargeInsetMd = $$new_props.xlargeInsetMd);
    if ("strong" in $$new_props) $$invalidate(27, strong = $$new_props.strong);
    if ("strongIos" in $$new_props) $$invalidate(28, strongIos = $$new_props.strongIos);
    if ("strongMd" in $$new_props) $$invalidate(29, strongMd = $$new_props.strongMd);
    if ("outline" in $$new_props) $$invalidate(30, outline = $$new_props.outline);
    if ("outlineIos" in $$new_props) $$invalidate(31, outlineIos = $$new_props.outlineIos);
    if ("outlineMd" in $$new_props) $$invalidate(32, outlineMd = $$new_props.outlineMd);
    if ("dividers" in $$new_props) $$invalidate(33, dividers = $$new_props.dividers);
    if ("dividersIos" in $$new_props) $$invalidate(34, dividersIos = $$new_props.dividersIos);
    if ("dividersMd" in $$new_props) $$invalidate(35, dividersMd = $$new_props.dividersMd);
    if ("mediaList" in $$new_props) $$invalidate(36, mediaList = $$new_props.mediaList);
    if ("sortable" in $$new_props) $$invalidate(37, sortable = $$new_props.sortable);
    if ("sortableTapHold" in $$new_props) $$invalidate(38, sortableTapHold = $$new_props.sortableTapHold);
    if ("sortableEnabled" in $$new_props) $$invalidate(39, sortableEnabled = $$new_props.sortableEnabled);
    if ("sortableMoveElements" in $$new_props) $$invalidate(1, sortableMoveElements = $$new_props.sortableMoveElements);
    if ("sortableOpposite" in $$new_props) $$invalidate(40, sortableOpposite = $$new_props.sortableOpposite);
    if ("accordionList" in $$new_props) $$invalidate(41, accordionList = $$new_props.accordionList);
    if ("accordionOpposite" in $$new_props) $$invalidate(42, accordionOpposite = $$new_props.accordionOpposite);
    if ("contactsList" in $$new_props) $$invalidate(43, contactsList = $$new_props.contactsList);
    if ("simpleList" in $$new_props) $$invalidate(44, simpleList = $$new_props.simpleList);
    if ("linksList" in $$new_props) $$invalidate(45, linksList = $$new_props.linksList);
    if ("menuList" in $$new_props) $$invalidate(46, menuList = $$new_props.menuList);
    if ("noChevron" in $$new_props) $$invalidate(47, noChevron = $$new_props.noChevron);
    if ("chevronCenter" in $$new_props) $$invalidate(48, chevronCenter = $$new_props.chevronCenter);
    if ("tab" in $$new_props) $$invalidate(49, tab = $$new_props.tab);
    if ("tabActive" in $$new_props) $$invalidate(50, tabActive = $$new_props.tabActive);
    if ("form" in $$new_props) $$invalidate(2, form = $$new_props.form);
    if ("formStoreData" in $$new_props) $$invalidate(51, formStoreData = $$new_props.formStoreData);
    if ("virtualList" in $$new_props) $$invalidate(52, virtualList = $$new_props.virtualList);
    if ("virtualListParams" in $$new_props) $$invalidate(53, virtualListParams = $$new_props.virtualListParams);
    if ("$$scope" in $$new_props) $$invalidate(55, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(4, classes = classNames(
      className,
      "list",
      {
        inset,
        "inset-ios": insetIos,
        "inset-md": insetMd,
        "xsmall-inset": xsmallInset,
        "xsmall-inset-ios": xsmallInsetIos,
        "xsmall-inset-md": xsmallInsetMd,
        "small-inset": smallInset,
        "small-inset-ios": smallInsetIos,
        "small-inset-md": smallInsetMd,
        "medium-inset": mediumInset,
        "medium-inset-ios": mediumInsetIos,
        "medium-inset-md": mediumInsetMd,
        "large-inset": largeInset,
        "large-inset-ios": largeInsetIos,
        "large-inset-md": largeInsetMd,
        "xlarge-inset": xlargeInset,
        "xlarge-inset-ios": xlargeInsetIos,
        "xlarge-inset-md": xlargeInsetMd,
        "list-strong": strong,
        "list-strong-ios": strongIos,
        "list-strong-md": strongMd,
        "list-outline": outline,
        "list-outline-ios": outlineIos,
        "list-outline-md": outlineMd,
        "list-dividers": dividers,
        "list-dividers-ios": dividersIos,
        "list-dividers-md": dividersMd,
        "media-list": mediaList,
        "simple-list": simpleList,
        "links-list": linksList,
        "menu-list": menuList,
        sortable,
        "sortable-tap-hold": sortableTapHold,
        "sortable-enabled": sortableEnabled,
        "sortable-opposite": sortableOpposite,
        "accordion-list": accordionList,
        "accordion-opposite": accordionOpposite,
        "contacts-list": contactsList,
        "virtual-list": virtualList,
        tab,
        "tab-active": tabActive,
        "form-store-data": formStoreData,
        "no-chevron": noChevron,
        "chevron-center": chevronCenter
      },
      colorClasses($$props)
    ));
  };
  $$invalidate(5, hasUlSlots = $$slots.default || $$slots.list);
  $$props = exclude_internal_props($$props);
  return [
    ul,
    sortableMoveElements,
    form,
    el,
    classes,
    hasUlSlots,
    onSubmit,
    $$restProps,
    className,
    inset,
    insetIos,
    insetMd,
    xsmallInset,
    xsmallInsetIos,
    xsmallInsetMd,
    smallInset,
    smallInsetIos,
    smallInsetMd,
    mediumInset,
    mediumInsetIos,
    mediumInsetMd,
    largeInset,
    largeInsetIos,
    largeInsetMd,
    xlargeInset,
    xlargeInsetIos,
    xlargeInsetMd,
    strong,
    strongIos,
    strongMd,
    outline,
    outlineIos,
    outlineMd,
    dividers,
    dividersIos,
    dividersMd,
    mediaList,
    sortable,
    sortableTapHold,
    sortableEnabled,
    sortableOpposite,
    accordionList,
    accordionOpposite,
    contactsList,
    simpleList,
    linksList,
    menuList,
    noChevron,
    chevronCenter,
    tab,
    tabActive,
    formStoreData,
    virtualList,
    virtualListParams,
    virtualListInstance,
    $$scope,
    slots,
    form_1_binding,
    div_binding
  ];
}
class List extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$g,
      create_fragment$f,
      safe_not_equal,
      {
        class: 8,
        ul: 0,
        inset: 9,
        insetIos: 10,
        insetMd: 11,
        xsmallInset: 12,
        xsmallInsetIos: 13,
        xsmallInsetMd: 14,
        smallInset: 15,
        smallInsetIos: 16,
        smallInsetMd: 17,
        mediumInset: 18,
        mediumInsetIos: 19,
        mediumInsetMd: 20,
        largeInset: 21,
        largeInsetIos: 22,
        largeInsetMd: 23,
        xlargeInset: 24,
        xlargeInsetIos: 25,
        xlargeInsetMd: 26,
        strong: 27,
        strongIos: 28,
        strongMd: 29,
        outline: 30,
        outlineIos: 31,
        outlineMd: 32,
        dividers: 33,
        dividersIos: 34,
        dividersMd: 35,
        mediaList: 36,
        sortable: 37,
        sortableTapHold: 38,
        sortableEnabled: 39,
        sortableMoveElements: 1,
        sortableOpposite: 40,
        accordionList: 41,
        accordionOpposite: 42,
        contactsList: 43,
        simpleList: 44,
        linksList: 45,
        menuList: 46,
        noChevron: 47,
        chevronCenter: 48,
        tab: 49,
        tabActive: 50,
        form: 2,
        formStoreData: 51,
        virtualList: 52,
        virtualListParams: 53,
        virtualListInstance: 54
      },
      null,
      [-1, -1, -1]
    );
  }
  get virtualListInstance() {
    return this.$$.ctx[54];
  }
}
function create_if_block$6(ctx) {
  let link;
  let current;
  link = new Link({
    props: {
      href: (
        /*backLinkUrl*/
        ctx[1] || "#"
      ),
      back: true,
      icon: "icon-back",
      force: (
        /*backLinkForce*/
        ctx[2] || void 0
      ),
      class: !/*backLinkText*/
      ctx[3] ? "icon-only" : void 0,
      text: (
        /*backLinkText*/
        ctx[3]
      ),
      onClick: (
        /*onBackClick*/
        ctx[5]
      )
    }
  });
  return {
    c() {
      create_component(link.$$.fragment);
    },
    m(target, anchor) {
      mount_component(link, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const link_changes = {};
      if (dirty & /*backLinkUrl*/
      2) link_changes.href = /*backLinkUrl*/
      ctx2[1] || "#";
      if (dirty & /*backLinkForce*/
      4) link_changes.force = /*backLinkForce*/
      ctx2[2] || void 0;
      if (dirty & /*backLinkText*/
      8) link_changes.class = !/*backLinkText*/
      ctx2[3] ? "icon-only" : void 0;
      if (dirty & /*backLinkText*/
      8) link_changes.text = /*backLinkText*/
      ctx2[3];
      link.$set(link_changes);
    },
    i(local) {
      if (current) return;
      transition_in(link.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(link.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(link, detaching);
    }
  };
}
function create_fragment$e(ctx) {
  let div;
  let t2;
  let current;
  let if_block = (
    /*backLink*/
    ctx[0] && create_if_block$6(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    null
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[4]
  ) }, restProps(
    /*$$restProps*/
    ctx[6]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  return {
    c() {
      div = element("div");
      if (if_block) if_block.c();
      t2 = space();
      if (default_slot) default_slot.c();
      set_attributes(div, div_data);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block) if_block.m(div, null);
      append(div, t2);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*backLink*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*backLink*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$6(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, t2);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        16) && { class: (
          /*classes*/
          ctx2[4]
        ) },
        dirty & /*$$restProps*/
        64 && restProps(
          /*$$restProps*/
          ctx2[6]
        )
      ]));
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block) if_block.d();
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function instance$f($$self, $$props, $$invalidate) {
  let classes;
  let needBackLinkText;
  let backLinkText;
  const omit_props_names = ["class", "backLink", "backLinkUrl", "backLinkForce", "backLinkShowText", "sliding"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { backLink = void 0 } = $$props;
  let { backLinkUrl = void 0 } = $$props;
  let { backLinkForce = void 0 } = $$props;
  let { backLinkShowText = void 0 } = $$props;
  let { sliding = void 0 } = $$props;
  let theme = useTheme((t2) => {
    $$invalidate(10, theme = t2);
  });
  function onBackClick() {
    emit("clickBack");
    emit("backClick");
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(15, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props) $$invalidate(7, className = $$new_props.class);
    if ("backLink" in $$new_props) $$invalidate(0, backLink = $$new_props.backLink);
    if ("backLinkUrl" in $$new_props) $$invalidate(1, backLinkUrl = $$new_props.backLinkUrl);
    if ("backLinkForce" in $$new_props) $$invalidate(2, backLinkForce = $$new_props.backLinkForce);
    if ("backLinkShowText" in $$new_props) $$invalidate(8, backLinkShowText = $$new_props.backLinkShowText);
    if ("sliding" in $$new_props) $$invalidate(9, sliding = $$new_props.sliding);
    if ("$$scope" in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(4, classes = classNames(className, "left", { sliding }, colorClasses($$props)));
    if ($$self.$$.dirty & /*backLinkShowText*/
    256) {
      $$invalidate(11, needBackLinkText = backLinkShowText);
    }
    if ($$self.$$.dirty & /*needBackLinkText, theme*/
    3072) {
      if (typeof needBackLinkText === "undefined") $$invalidate(11, needBackLinkText = theme && !theme.md);
    }
    if ($$self.$$.dirty & /*backLink, needBackLinkText*/
    2049) {
      $$invalidate(3, backLinkText = backLink !== true && needBackLinkText ? backLink : void 0);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    backLink,
    backLinkUrl,
    backLinkForce,
    backLinkText,
    classes,
    onBackClick,
    $$restProps,
    className,
    backLinkShowText,
    sliding,
    theme,
    needBackLinkText,
    $$scope,
    slots
  ];
}
class Nav_left extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$f, create_fragment$e, safe_not_equal, {
      class: 7,
      backLink: 0,
      backLinkUrl: 1,
      backLinkForce: 2,
      backLinkShowText: 8,
      sliding: 9
    });
  }
}
function create_fragment$d(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[0]
  ) }, restProps(
    /*$$restProps*/
    ctx[1]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  return {
    c() {
      div = element("div");
      if (default_slot) default_slot.c();
      set_attributes(div, div_data);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        2 && restProps(
          /*$$restProps*/
          ctx2[1]
        )
      ]));
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function instance$e($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "sliding"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { class: className = void 0 } = $$props;
  let { sliding = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
    if ("sliding" in $$new_props) $$invalidate(3, sliding = $$new_props.sliding);
    if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(0, classes = classNames(className, "right", { sliding }, colorClasses($$props)));
  };
  $$props = exclude_internal_props($$props);
  return [classes, $$restProps, className, sliding, $$scope, slots];
}
class Nav_right extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$e, create_fragment$d, safe_not_equal, { class: 2, sliding: 3 });
  }
}
function create_if_block_1$2(ctx) {
  let t_value = plainText(
    /*title*/
    ctx[0]
  ) + "";
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*title*/
      1 && t_value !== (t_value = plainText(
        /*title*/
        ctx2[0]
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block$5(ctx) {
  let span;
  let t_value = plainText(
    /*subtitle*/
    ctx[1]
  ) + "";
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
      attr(span, "class", "subtitle");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*subtitle*/
      2 && t_value !== (t_value = plainText(
        /*subtitle*/
        ctx2[1]
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment$c(ctx) {
  let div;
  let t0;
  let t1;
  let current;
  let if_block0 = typeof /*title*/
  ctx[0] !== "undefined" && create_if_block_1$2(ctx);
  let if_block1 = typeof /*subtitle*/
  ctx[1] !== "undefined" && create_if_block$5(ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  let div_levels = [{ class: (
    /*classes*/
    ctx[2]
  ) }, restProps(
    /*$$restProps*/
    ctx[3]
  )];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  return {
    c() {
      div = element("div");
      if (if_block0) if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      if (default_slot) default_slot.c();
      set_attributes(div, div_data);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0) if_block0.m(div, null);
      append(div, t0);
      if (if_block1) if_block1.m(div, null);
      append(div, t1);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (typeof /*title*/
      ctx2[0] !== "undefined") {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1$2(ctx2);
          if_block0.c();
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (typeof /*subtitle*/
      ctx2[1] !== "undefined") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$5(ctx2);
          if_block1.c();
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        4) && { class: (
          /*classes*/
          ctx2[2]
        ) },
        dirty & /*$$restProps*/
        8 && restProps(
          /*$$restProps*/
          ctx2[3]
        )
      ]));
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function instance$d($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "title", "subtitle", "sliding"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { class: className = void 0 } = $$props;
  let { title = void 0 } = $$props;
  let { subtitle = void 0 } = $$props;
  let { sliding = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props) $$invalidate(4, className = $$new_props.class);
    if ("title" in $$new_props) $$invalidate(0, title = $$new_props.title);
    if ("subtitle" in $$new_props) $$invalidate(1, subtitle = $$new_props.subtitle);
    if ("sliding" in $$new_props) $$invalidate(5, sliding = $$new_props.sliding);
    if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(2, classes = classNames(className, "title", { sliding }, colorClasses($$props)));
  };
  $$props = exclude_internal_props($$props);
  return [title, subtitle, classes, $$restProps, className, sliding, $$scope, slots];
}
class Nav_title extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$d, create_fragment$c, safe_not_equal, {
      class: 4,
      title: 0,
      subtitle: 1,
      sliding: 5
    });
  }
}
const get_after_inner_slot_changes = (dirty) => ({});
const get_after_inner_slot_context = (ctx) => ({});
const get_title_large_slot_changes = (dirty) => ({});
const get_title_large_slot_context = (ctx) => ({});
const get_right_slot_changes = (dirty) => ({});
const get_right_slot_context = (ctx) => ({});
const get_nav_right_slot_changes = (dirty) => ({});
const get_nav_right_slot_context = (ctx) => ({});
const get_title_slot_changes = (dirty) => ({});
const get_title_slot_context = (ctx) => ({});
const get_left_slot_changes = (dirty) => ({});
const get_left_slot_context = (ctx) => ({});
const get_nav_left_slot_changes = (dirty) => ({});
const get_nav_left_slot_context = (ctx) => ({});
const get_before_inner_slot_changes = (dirty) => ({});
const get_before_inner_slot_context = (ctx) => ({});
function create_if_block_3$1(ctx) {
  let navleft;
  let current;
  navleft = new Nav_left({
    props: {
      backLink: (
        /*backLink*/
        ctx[0]
      ),
      backLinkUrl: (
        /*backLinkUrl*/
        ctx[1]
      ),
      backLinkForce: (
        /*backLinkForce*/
        ctx[2]
      ),
      backLinkShowText: (
        /*backLinkShowText*/
        ctx[3]
      ),
      onBackClick: (
        /*onBackClick*/
        ctx[15]
      ),
      $$slots: { default: [create_default_slot_2$4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(navleft.$$.fragment);
    },
    m(target, anchor) {
      mount_component(navleft, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const navleft_changes = {};
      if (dirty[0] & /*backLink*/
      1) navleft_changes.backLink = /*backLink*/
      ctx2[0];
      if (dirty[0] & /*backLinkUrl*/
      2) navleft_changes.backLinkUrl = /*backLinkUrl*/
      ctx2[1];
      if (dirty[0] & /*backLinkForce*/
      4) navleft_changes.backLinkForce = /*backLinkForce*/
      ctx2[2];
      if (dirty[0] & /*backLinkShowText*/
      8) navleft_changes.backLinkShowText = /*backLinkShowText*/
      ctx2[3];
      if (dirty[1] & /*$$scope*/
      8192) {
        navleft_changes.$$scope = { dirty, ctx: ctx2 };
      }
      navleft.$set(navleft_changes);
    },
    i(local) {
      if (current) return;
      transition_in(navleft.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(navleft.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(navleft, detaching);
    }
  };
}
function create_default_slot_2$4(ctx) {
  let t2;
  let current;
  const nav_left_slot_template = (
    /*#slots*/
    ctx[42]["nav-left"]
  );
  const nav_left_slot = create_slot(
    nav_left_slot_template,
    ctx,
    /*$$scope*/
    ctx[44],
    get_nav_left_slot_context
  );
  const left_slot_template = (
    /*#slots*/
    ctx[42].left
  );
  const left_slot = create_slot(
    left_slot_template,
    ctx,
    /*$$scope*/
    ctx[44],
    get_left_slot_context
  );
  return {
    c() {
      if (nav_left_slot) nav_left_slot.c();
      t2 = space();
      if (left_slot) left_slot.c();
    },
    m(target, anchor) {
      if (nav_left_slot) {
        nav_left_slot.m(target, anchor);
      }
      insert(target, t2, anchor);
      if (left_slot) {
        left_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (nav_left_slot) {
        if (nav_left_slot.p && (!current || dirty[1] & /*$$scope*/
        8192)) {
          update_slot_base(
            nav_left_slot,
            nav_left_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[44],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[44]
            ) : get_slot_changes(
              nav_left_slot_template,
              /*$$scope*/
              ctx2[44],
              dirty,
              get_nav_left_slot_changes
            ),
            get_nav_left_slot_context
          );
        }
      }
      if (left_slot) {
        if (left_slot.p && (!current || dirty[1] & /*$$scope*/
        8192)) {
          update_slot_base(
            left_slot,
            left_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[44],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[44]
            ) : get_slot_changes(
              left_slot_template,
              /*$$scope*/
              ctx2[44],
              dirty,
              get_left_slot_changes
            ),
            get_left_slot_context
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(nav_left_slot, local);
      transition_in(left_slot, local);
      current = true;
    },
    o(local) {
      transition_out(nav_left_slot, local);
      transition_out(left_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      if (nav_left_slot) nav_left_slot.d(detaching);
      if (left_slot) left_slot.d(detaching);
    }
  };
}
function create_if_block_2$1(ctx) {
  let navtitle;
  let current;
  navtitle = new Nav_title({
    props: {
      title: (
        /*title*/
        ctx[4]
      ),
      subtitle: (
        /*subtitle*/
        ctx[5]
      ),
      $$slots: { default: [create_default_slot_1$5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(navtitle.$$.fragment);
    },
    m(target, anchor) {
      mount_component(navtitle, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const navtitle_changes = {};
      if (dirty[0] & /*title*/
      16) navtitle_changes.title = /*title*/
      ctx2[4];
      if (dirty[0] & /*subtitle*/
      32) navtitle_changes.subtitle = /*subtitle*/
      ctx2[5];
      if (dirty[1] & /*$$scope*/
      8192) {
        navtitle_changes.$$scope = { dirty, ctx: ctx2 };
      }
      navtitle.$set(navtitle_changes);
    },
    i(local) {
      if (current) return;
      transition_in(navtitle.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(navtitle.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(navtitle, detaching);
    }
  };
}
function create_default_slot_1$5(ctx) {
  let current;
  const title_slot_template = (
    /*#slots*/
    ctx[42].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[44],
    get_title_slot_context
  );
  return {
    c() {
      if (title_slot) title_slot.c();
    },
    m(target, anchor) {
      if (title_slot) {
        title_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (title_slot) {
        if (title_slot.p && (!current || dirty[1] & /*$$scope*/
        8192)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[44],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[44]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[44],
              dirty,
              get_title_slot_changes
            ),
            get_title_slot_context
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(title_slot, local);
      current = true;
    },
    o(local) {
      transition_out(title_slot, local);
      current = false;
    },
    d(detaching) {
      if (title_slot) title_slot.d(detaching);
    }
  };
}
function create_if_block_1$1(ctx) {
  let navright;
  let current;
  navright = new Nav_right({
    props: {
      $$slots: { default: [create_default_slot$7] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(navright.$$.fragment);
    },
    m(target, anchor) {
      mount_component(navright, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const navright_changes = {};
      if (dirty[1] & /*$$scope*/
      8192) {
        navright_changes.$$scope = { dirty, ctx: ctx2 };
      }
      navright.$set(navright_changes);
    },
    i(local) {
      if (current) return;
      transition_in(navright.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(navright.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(navright, detaching);
    }
  };
}
function create_default_slot$7(ctx) {
  let t2;
  let current;
  const nav_right_slot_template = (
    /*#slots*/
    ctx[42]["nav-right"]
  );
  const nav_right_slot = create_slot(
    nav_right_slot_template,
    ctx,
    /*$$scope*/
    ctx[44],
    get_nav_right_slot_context
  );
  const right_slot_template = (
    /*#slots*/
    ctx[42].right
  );
  const right_slot = create_slot(
    right_slot_template,
    ctx,
    /*$$scope*/
    ctx[44],
    get_right_slot_context
  );
  return {
    c() {
      if (nav_right_slot) nav_right_slot.c();
      t2 = space();
      if (right_slot) right_slot.c();
    },
    m(target, anchor) {
      if (nav_right_slot) {
        nav_right_slot.m(target, anchor);
      }
      insert(target, t2, anchor);
      if (right_slot) {
        right_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (nav_right_slot) {
        if (nav_right_slot.p && (!current || dirty[1] & /*$$scope*/
        8192)) {
          update_slot_base(
            nav_right_slot,
            nav_right_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[44],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[44]
            ) : get_slot_changes(
              nav_right_slot_template,
              /*$$scope*/
              ctx2[44],
              dirty,
              get_nav_right_slot_changes
            ),
            get_nav_right_slot_context
          );
        }
      }
      if (right_slot) {
        if (right_slot.p && (!current || dirty[1] & /*$$scope*/
        8192)) {
          update_slot_base(
            right_slot,
            right_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[44],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[44]
            ) : get_slot_changes(
              right_slot_template,
              /*$$scope*/
              ctx2[44],
              dirty,
              get_right_slot_changes
            ),
            get_right_slot_context
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(nav_right_slot, local);
      transition_in(right_slot, local);
      current = true;
    },
    o(local) {
      transition_out(nav_right_slot, local);
      transition_out(right_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      if (nav_right_slot) nav_right_slot.d(detaching);
      if (right_slot) right_slot.d(detaching);
    }
  };
}
function create_if_block$4(ctx) {
  let div1;
  let div0;
  let t0_value = plainText(
    /*largeTitle*/
    ctx[11]
  ) + "";
  let t0;
  let t1;
  let current;
  const title_large_slot_template = (
    /*#slots*/
    ctx[42]["title-large"]
  );
  const title_large_slot = create_slot(
    title_large_slot_template,
    ctx,
    /*$$scope*/
    ctx[44],
    get_title_large_slot_context
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (title_large_slot) title_large_slot.c();
      attr(div0, "class", "title-large-text");
      attr(div1, "class", "title-large");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, t0);
      append(div0, t1);
      if (title_large_slot) {
        title_large_slot.m(div0, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*largeTitle*/
      2048) && t0_value !== (t0_value = plainText(
        /*largeTitle*/
        ctx2[11]
      ) + "")) set_data(t0, t0_value);
      if (title_large_slot) {
        if (title_large_slot.p && (!current || dirty[1] & /*$$scope*/
        8192)) {
          update_slot_base(
            title_large_slot,
            title_large_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[44],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[44]
            ) : get_slot_changes(
              title_large_slot_template,
              /*$$scope*/
              ctx2[44],
              dirty,
              get_title_large_slot_changes
            ),
            get_title_large_slot_context
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(title_large_slot, local);
      current = true;
    },
    o(local) {
      transition_out(title_large_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (title_large_slot) title_large_slot.d(detaching);
    }
  };
}
function create_fragment$b(ctx) {
  let div2;
  let div0;
  let t0;
  let t1;
  let div1;
  let t2;
  let t3;
  let t4;
  let t5;
  let t6;
  let current;
  const before_inner_slot_template = (
    /*#slots*/
    ctx[42]["before-inner"]
  );
  const before_inner_slot = create_slot(
    before_inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[44],
    get_before_inner_slot_context
  );
  let if_block0 = (
    /*backLink*/
    (ctx[0] || /*hasLeftSlots*/
    ctx[14]) && create_if_block_3$1(ctx)
  );
  let if_block1 = (
    /*title*/
    (ctx[4] || /*subtitle*/
    ctx[5] || /*hasTitleSlots*/
    ctx[12]) && create_if_block_2$1(ctx)
  );
  let if_block2 = (
    /*hasRightSlots*/
    ctx[13] && create_if_block_1$1(ctx)
  );
  let if_block3 = (
    /*largeTitle*/
    (ctx[11] || /*hasTitleLargeSlots*/
    ctx[10]) && create_if_block$4(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[42].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[44],
    null
  );
  const after_inner_slot_template = (
    /*#slots*/
    ctx[42]["after-inner"]
  );
  const after_inner_slot = create_slot(
    after_inner_slot_template,
    ctx,
    /*$$scope*/
    ctx[44],
    get_after_inner_slot_context
  );
  let div2_levels = [
    { class: (
      /*classes*/
      ctx[9]
    ) },
    { "data-f7-slot": (
      /*f7Slot*/
      ctx[6]
    ) },
    restProps(
      /*$$restProps*/
      ctx[16]
    )
  ];
  let div_data_2 = {};
  for (let i = 0; i < div2_levels.length; i += 1) {
    div_data_2 = assign(div_data_2, div2_levels[i]);
  }
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t0 = space();
      if (before_inner_slot) before_inner_slot.c();
      t1 = space();
      div1 = element("div");
      if (if_block0) if_block0.c();
      t2 = space();
      if (if_block1) if_block1.c();
      t3 = space();
      if (if_block2) if_block2.c();
      t4 = space();
      if (if_block3) if_block3.c();
      t5 = space();
      if (default_slot) default_slot.c();
      t6 = space();
      if (after_inner_slot) after_inner_slot.c();
      attr(div0, "class", "navbar-bg");
      attr(
        div1,
        "class",
        /*innerClasses*/
        ctx[8]
      );
      set_attributes(div2, div_data_2);
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div2, t0);
      if (before_inner_slot) {
        before_inner_slot.m(div2, null);
      }
      append(div2, t1);
      append(div2, div1);
      if (if_block0) if_block0.m(div1, null);
      append(div1, t2);
      if (if_block1) if_block1.m(div1, null);
      append(div1, t3);
      if (if_block2) if_block2.m(div1, null);
      append(div1, t4);
      if (if_block3) if_block3.m(div1, null);
      append(div1, t5);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      append(div2, t6);
      if (after_inner_slot) {
        after_inner_slot.m(div2, null);
      }
      ctx[43](div2);
      current = true;
    },
    p(ctx2, dirty) {
      if (before_inner_slot) {
        if (before_inner_slot.p && (!current || dirty[1] & /*$$scope*/
        8192)) {
          update_slot_base(
            before_inner_slot,
            before_inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[44],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[44]
            ) : get_slot_changes(
              before_inner_slot_template,
              /*$$scope*/
              ctx2[44],
              dirty,
              get_before_inner_slot_changes
            ),
            get_before_inner_slot_context
          );
        }
      }
      if (
        /*backLink*/
        ctx2[0] || /*hasLeftSlots*/
        ctx2[14]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*backLink, hasLeftSlots*/
          16385) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3$1(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, t2);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*title*/
        ctx2[4] || /*subtitle*/
        ctx2[5] || /*hasTitleSlots*/
        ctx2[12]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*title, subtitle, hasTitleSlots*/
          4144) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2$1(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*hasRightSlots*/
        ctx2[13]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*hasRightSlots*/
          8192) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_1$1(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div1, t4);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*largeTitle*/
        ctx2[11] || /*hasTitleLargeSlots*/
        ctx2[10]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & /*largeTitle, hasTitleLargeSlots*/
          3072) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block$4(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div1, t5);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[44],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[44]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[44],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*innerClasses*/
      256) {
        attr(
          div1,
          "class",
          /*innerClasses*/
          ctx2[8]
        );
      }
      if (after_inner_slot) {
        if (after_inner_slot.p && (!current || dirty[1] & /*$$scope*/
        8192)) {
          update_slot_base(
            after_inner_slot,
            after_inner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[44],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[44]
            ) : get_slot_changes(
              after_inner_slot_template,
              /*$$scope*/
              ctx2[44],
              dirty,
              get_after_inner_slot_changes
            ),
            get_after_inner_slot_context
          );
        }
      }
      set_attributes(div2, div_data_2 = get_spread_update(div2_levels, [
        (!current || dirty[0] & /*classes*/
        512) && { class: (
          /*classes*/
          ctx2[9]
        ) },
        (!current || dirty[0] & /*f7Slot*/
        64) && { "data-f7-slot": (
          /*f7Slot*/
          ctx2[6]
        ) },
        dirty[0] & /*$$restProps*/
        65536 && restProps(
          /*$$restProps*/
          ctx2[16]
        )
      ]));
    },
    i(local) {
      if (current) return;
      transition_in(before_inner_slot, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(default_slot, local);
      transition_in(after_inner_slot, local);
      current = true;
    },
    o(local) {
      transition_out(before_inner_slot, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(default_slot, local);
      transition_out(after_inner_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (before_inner_slot) before_inner_slot.d(detaching);
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (if_block2) if_block2.d();
      if (if_block3) if_block3.d();
      if (default_slot) default_slot.d(detaching);
      if (after_inner_slot) after_inner_slot.d(detaching);
      ctx[43](null);
    }
  };
}
function instance$c($$self, $$props, $$invalidate) {
  let hasLeftSlots;
  let hasRightSlots;
  let hasTitleSlots;
  let largeTitle;
  let hasTitleLargeSlots;
  let addLeftTitleClass;
  let addCenterTitleClass;
  let isLarge;
  let isTransparent;
  let isTransparentVisible;
  let classes;
  let innerClasses;
  const omit_props_names = [
    "class",
    "backLink",
    "backLinkUrl",
    "backLinkForce",
    "backLinkShowText",
    "sliding",
    "title",
    "subtitle",
    "hidden",
    "outline",
    "innerClass",
    "innerClassName",
    "large",
    "largeTransparent",
    "transparent",
    "titleLarge",
    "f7Slot",
    "hide",
    "show",
    "size"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  const emit = createEmitter(createEventDispatcher, $$props);
  let { class: className = void 0 } = $$props;
  let { backLink = void 0 } = $$props;
  let { backLinkUrl = void 0 } = $$props;
  let { backLinkForce = false } = $$props;
  let { backLinkShowText = void 0 } = $$props;
  let { sliding = true } = $$props;
  let { title = void 0 } = $$props;
  let { subtitle = void 0 } = $$props;
  let { hidden = false } = $$props;
  let { outline = true } = $$props;
  let { innerClass = void 0 } = $$props;
  let { innerClassName = void 0 } = $$props;
  let { large = false } = $$props;
  let { largeTransparent = false } = $$props;
  let { transparent = false } = $$props;
  let { titleLarge = void 0 } = $$props;
  let { f7Slot = "fixed" } = $$props;
  let el;
  let theme = useTheme((t2) => {
    $$invalidate(30, theme = t2);
  });
  let routerPositionClass = "";
  let largeCollapsed = false;
  let routerNavbarRole = null;
  let routerNavbarRoleDetailRoot = false;
  let routerNavbarMasterStack = false;
  let transparentVisible = false;
  function hide2(animate2) {
    app.f7.navbar.hide(el, animate2);
  }
  function show2(animate2) {
    app.f7.navbar.show(el, animate2);
  }
  function size() {
    app.f7.navbar.size(el);
  }
  function onHide(navbarEl) {
    if (el !== navbarEl) return;
    emit("navbarHide");
  }
  function onShow(navbarEl) {
    if (el !== navbarEl) return;
    emit("navbarShow");
  }
  function onNavbarTransparentShow(navbarEl) {
    if (el !== navbarEl) return;
    $$invalidate(36, transparentVisible = true);
    emit("navbarTransparentShow");
  }
  function onNavbarTransparentHide(navbarEl) {
    if (el !== navbarEl) return;
    $$invalidate(36, transparentVisible = false);
    emit("navbarTransparentHide");
  }
  function onExpand(navbarEl) {
    if (el !== navbarEl) return;
    $$invalidate(32, largeCollapsed = false);
    emit("navbarExpand");
  }
  function onCollapse(navbarEl) {
    if (el !== navbarEl) return;
    $$invalidate(32, largeCollapsed = true);
    emit("navbarCollapse");
  }
  function onNavbarPosition(navbarEl, position) {
    if (el !== navbarEl) return;
    $$invalidate(31, routerPositionClass = position ? `navbar-${position}` : position);
  }
  function onNavbarRole(navbarEl, rolesData) {
    if (el !== navbarEl) return;
    $$invalidate(33, routerNavbarRole = rolesData.role);
    $$invalidate(34, routerNavbarRoleDetailRoot = rolesData.detailRoot);
  }
  function onNavbarMasterStack(navbarEl) {
    if (el !== navbarEl) return;
    $$invalidate(35, routerNavbarMasterStack = true);
  }
  function onNavbarMasterUnstack(navbarEl) {
    if (el !== navbarEl) return;
    $$invalidate(35, routerNavbarMasterStack = false);
  }
  function onBackClick() {
    emit("clickBack");
  }
  function mountNavbar() {
    app.f7.on("navbarShow", onShow);
    app.f7.on("navbarHide", onHide);
    app.f7.on("navbarCollapse", onCollapse);
    app.f7.on("navbarExpand", onExpand);
    app.f7.on("navbarPosition", onNavbarPosition);
    app.f7.on("navbarRole", onNavbarRole);
    app.f7.on("navbarMasterStack", onNavbarMasterStack);
    app.f7.on("navbarMasterUnstack", onNavbarMasterUnstack);
    app.f7.on("navbarTransparentShow", onNavbarTransparentShow);
    app.f7.on("navbarTransparentHide", onNavbarTransparentHide);
  }
  function destroyNavbar() {
    app.f7.off("navbarShow", onShow);
    app.f7.off("navbarHide", onHide);
    app.f7.off("navbarCollapse", onCollapse);
    app.f7.off("navbarExpand", onExpand);
    app.f7.off("navbarPosition", onNavbarPosition);
    app.f7.off("navbarRole", onNavbarRole);
    app.f7.off("navbarMasterStack", onNavbarMasterStack);
    app.f7.off("navbarMasterUnstack", onNavbarMasterUnstack);
    app.f7.off("navbarTransparentShow", onNavbarTransparentShow);
    app.f7.off("navbarTransparentHide", onNavbarTransparentHide);
  }
  onMount(() => {
    f7ready(() => {
      mountNavbar();
    });
  });
  afterUpdate(() => {
    if (!app.f7) return;
    app.f7.navbar.size(el);
  });
  onDestroy(() => {
    if (!app.f7) return;
    destroyNavbar();
  });
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(7, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(58, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(16, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props) $$invalidate(17, className = $$new_props.class);
    if ("backLink" in $$new_props) $$invalidate(0, backLink = $$new_props.backLink);
    if ("backLinkUrl" in $$new_props) $$invalidate(1, backLinkUrl = $$new_props.backLinkUrl);
    if ("backLinkForce" in $$new_props) $$invalidate(2, backLinkForce = $$new_props.backLinkForce);
    if ("backLinkShowText" in $$new_props) $$invalidate(3, backLinkShowText = $$new_props.backLinkShowText);
    if ("sliding" in $$new_props) $$invalidate(18, sliding = $$new_props.sliding);
    if ("title" in $$new_props) $$invalidate(4, title = $$new_props.title);
    if ("subtitle" in $$new_props) $$invalidate(5, subtitle = $$new_props.subtitle);
    if ("hidden" in $$new_props) $$invalidate(19, hidden = $$new_props.hidden);
    if ("outline" in $$new_props) $$invalidate(20, outline = $$new_props.outline);
    if ("innerClass" in $$new_props) $$invalidate(21, innerClass = $$new_props.innerClass);
    if ("innerClassName" in $$new_props) $$invalidate(22, innerClassName = $$new_props.innerClassName);
    if ("large" in $$new_props) $$invalidate(23, large = $$new_props.large);
    if ("largeTransparent" in $$new_props) $$invalidate(24, largeTransparent = $$new_props.largeTransparent);
    if ("transparent" in $$new_props) $$invalidate(25, transparent = $$new_props.transparent);
    if ("titleLarge" in $$new_props) $$invalidate(26, titleLarge = $$new_props.titleLarge);
    if ("f7Slot" in $$new_props) $$invalidate(6, f7Slot = $$new_props.f7Slot);
    if ("$$scope" in $$new_props) $$invalidate(44, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*titleLarge, large, title*/
    75497488) {
      $$invalidate(11, largeTitle = titleLarge || large && title);
    }
    if ($$self.$$.dirty[0] & /*theme*/
    1073741824) {
      $$invalidate(38, addLeftTitleClass = theme && theme.ios && app.f7 && !app.f7.params.navbar.iosCenterTitle);
    }
    if ($$self.$$.dirty[0] & /*theme*/
    1073741824) {
      $$invalidate(37, addCenterTitleClass = theme && theme.md && app.f7 && app.f7.params.navbar.mdCenterTitle);
    }
    if ($$self.$$.dirty[0] & /*large, largeTransparent*/
    25165824) {
      $$invalidate(41, isLarge = large || largeTransparent);
    }
    if ($$self.$$.dirty[0] & /*transparent, largeTransparent*/
    50331648 | $$self.$$.dirty[1] & /*isLarge*/
    1024) {
      $$invalidate(40, isTransparent = transparent || isLarge && largeTransparent);
    }
    if ($$self.$$.dirty[1] & /*isTransparent, transparentVisible*/
    544) {
      $$invalidate(39, isTransparentVisible = isTransparent && transparentVisible);
    }
    $$invalidate(9, classes = classNames(
      className,
      "navbar",
      routerPositionClass,
      {
        "navbar-hidden": hidden,
        "navbar-large": isLarge,
        "navbar-large-collapsed": isLarge && largeCollapsed,
        "navbar-transparent": isTransparent,
        "navbar-transparent-visible": isTransparentVisible,
        "navbar-master": routerNavbarRole === "master",
        "navbar-master-detail": routerNavbarRole === "detail",
        "navbar-master-detail-root": routerNavbarRoleDetailRoot === true,
        "navbar-master-stacked": routerNavbarMasterStack === true,
        "no-outline": !outline
      },
      colorClasses($$props)
    ));
    if ($$self.$$.dirty[0] & /*innerClass, innerClassName, sliding*/
    6553600 | $$self.$$.dirty[1] & /*addLeftTitleClass, addCenterTitleClass*/
    192) {
      $$invalidate(8, innerClasses = classNames("navbar-inner", innerClass, innerClassName, {
        sliding,
        "navbar-inner-left-title": addLeftTitleClass,
        "navbar-inner-centered-title": addCenterTitleClass
      }));
    }
  };
  $$invalidate(14, hasLeftSlots = $$slots["nav-left"] || $$slots["left"]);
  $$invalidate(13, hasRightSlots = $$slots["nav-right"] || $$slots["right"]);
  $$invalidate(12, hasTitleSlots = $$slots["title"]);
  $$invalidate(10, hasTitleLargeSlots = $$slots["title-large"]);
  $$props = exclude_internal_props($$props);
  return [
    backLink,
    backLinkUrl,
    backLinkForce,
    backLinkShowText,
    title,
    subtitle,
    f7Slot,
    el,
    innerClasses,
    classes,
    hasTitleLargeSlots,
    largeTitle,
    hasTitleSlots,
    hasRightSlots,
    hasLeftSlots,
    onBackClick,
    $$restProps,
    className,
    sliding,
    hidden,
    outline,
    innerClass,
    innerClassName,
    large,
    largeTransparent,
    transparent,
    titleLarge,
    hide2,
    show2,
    size,
    theme,
    routerPositionClass,
    largeCollapsed,
    routerNavbarRole,
    routerNavbarRoleDetailRoot,
    routerNavbarMasterStack,
    transparentVisible,
    addCenterTitleClass,
    addLeftTitleClass,
    isTransparentVisible,
    isTransparent,
    isLarge,
    slots,
    div2_binding,
    $$scope
  ];
}
class Navbar extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$c,
      create_fragment$b,
      safe_not_equal,
      {
        class: 17,
        backLink: 0,
        backLinkUrl: 1,
        backLinkForce: 2,
        backLinkShowText: 3,
        sliding: 18,
        title: 4,
        subtitle: 5,
        hidden: 19,
        outline: 20,
        innerClass: 21,
        innerClassName: 22,
        large: 23,
        largeTransparent: 24,
        transparent: 25,
        titleLarge: 26,
        f7Slot: 6,
        hide: 27,
        show: 28,
        size: 29
      },
      null,
      [-1, -1]
    );
  }
  get hide() {
    return this.$$.ctx[27];
  }
  get show() {
    return this.$$.ctx[28];
  }
  get size() {
    return this.$$.ctx[29];
  }
}
function create_if_block_3(ctx) {
  let div1;
  let preloader;
  let t2;
  let div0;
  let current;
  preloader = new Preloader({});
  return {
    c() {
      div1 = element("div");
      create_component(preloader.$$.fragment);
      t2 = space();
      div0 = element("div");
      attr(div0, "class", "ptr-arrow");
      attr(div1, "class", "ptr-preloader");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      mount_component(preloader, div1, null);
      append(div1, t2);
      append(div1, div0);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(preloader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(preloader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(preloader);
    }
  };
}
function create_if_block_2(ctx) {
  let preloader;
  let current;
  preloader = new Preloader({
    props: { class: "infinite-scroll-preloader" }
  });
  return {
    c() {
      create_component(preloader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(preloader, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(preloader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(preloader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(preloader, detaching);
    }
  };
}
function create_if_block_1(ctx) {
  let preloader;
  let current;
  preloader = new Preloader({
    props: { class: "infinite-scroll-preloader" }
  });
  return {
    c() {
      create_component(preloader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(preloader, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(preloader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(preloader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(preloader, detaching);
    }
  };
}
function create_if_block$3(ctx) {
  let div1;
  let preloader;
  let t2;
  let div0;
  let current;
  preloader = new Preloader({});
  return {
    c() {
      div1 = element("div");
      create_component(preloader.$$.fragment);
      t2 = space();
      div0 = element("div");
      attr(div0, "class", "ptr-arrow");
      attr(div1, "class", "ptr-preloader");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      mount_component(preloader, div1, null);
      append(div1, t2);
      append(div1, div0);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(preloader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(preloader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(preloader);
    }
  };
}
function create_fragment$a(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  let t3;
  let div_data_ptr_mousewheel_value;
  let div_data_infinite_distance_value;
  let current;
  let if_block0 = (
    /*ptr*/
    ctx[0] && /*ptrPreloader*/
    ctx[2] && !/*ptrBottom*/
    ctx[3] && create_if_block_3()
  );
  let if_block1 = (
    /*infinite*/
    ctx[5] && /*infiniteTop*/
    ctx[6] && /*infinitePreloader*/
    ctx[8] && create_if_block_2()
  );
  const default_slot_template = (
    /*#slots*/
    ctx[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    null
  );
  let if_block2 = (
    /*infinite*/
    ctx[5] && !/*infiniteTop*/
    ctx[6] && /*infinitePreloader*/
    ctx[8] && create_if_block_1()
  );
  let if_block3 = (
    /*ptr*/
    ctx[0] && /*ptrPreloader*/
    ctx[2] && /*ptrBottom*/
    ctx[3] && create_if_block$3()
  );
  let div_levels = [
    { class: (
      /*pageContentClasses*/
      ctx[10]
    ) },
    {
      "data-ptr-distance": (
        /*ptrDistance*/
        ctx[1]
      )
    },
    {
      "data-ptr-mousewheel": div_data_ptr_mousewheel_value = /*ptrMousewheel*/
      ctx[4] || void 0
    },
    {
      "data-infinite-distance": div_data_infinite_distance_value = /*infiniteDistance*/
      ctx[7] || void 0
    },
    restProps(
      /*$$restProps*/
      ctx[11]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  return {
    c() {
      div = element("div");
      if (if_block0) if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      if (default_slot) default_slot.c();
      t2 = space();
      if (if_block2) if_block2.c();
      t3 = space();
      if (if_block3) if_block3.c();
      set_attributes(div, div_data);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0) if_block0.m(div, null);
      append(div, t0);
      if (if_block1) if_block1.m(div, null);
      append(div, t1);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append(div, t2);
      if (if_block2) if_block2.m(div, null);
      append(div, t3);
      if (if_block3) if_block3.m(div, null);
      ctx[22](div);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*ptr*/
        ctx2[0] && /*ptrPreloader*/
        ctx2[2] && !/*ptrBottom*/
        ctx2[3]
      ) {
        if (if_block0) {
          if (dirty[0] & /*ptr, ptrPreloader, ptrBottom*/
          13) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3();
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*infinite*/
        ctx2[5] && /*infiniteTop*/
        ctx2[6] && /*infinitePreloader*/
        ctx2[8]
      ) {
        if (if_block1) {
          if (dirty[0] & /*infinite, infiniteTop, infinitePreloader*/
          352) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2();
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        1048576)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*infinite*/
        ctx2[5] && !/*infiniteTop*/
        ctx2[6] && /*infinitePreloader*/
        ctx2[8]
      ) {
        if (if_block2) {
          if (dirty[0] & /*infinite, infiniteTop, infinitePreloader*/
          352) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_1();
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, t3);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*ptr*/
        ctx2[0] && /*ptrPreloader*/
        ctx2[2] && /*ptrBottom*/
        ctx2[3]
      ) {
        if (if_block3) {
          if (dirty[0] & /*ptr, ptrPreloader, ptrBottom*/
          13) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block$3();
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div, null);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty[0] & /*pageContentClasses*/
        1024) && { class: (
          /*pageContentClasses*/
          ctx2[10]
        ) },
        (!current || dirty[0] & /*ptrDistance*/
        2) && {
          "data-ptr-distance": (
            /*ptrDistance*/
            ctx2[1]
          )
        },
        (!current || dirty[0] & /*ptrMousewheel*/
        16 && div_data_ptr_mousewheel_value !== (div_data_ptr_mousewheel_value = /*ptrMousewheel*/
        ctx2[4] || void 0)) && {
          "data-ptr-mousewheel": div_data_ptr_mousewheel_value
        },
        (!current || dirty[0] & /*infiniteDistance*/
        128 && div_data_infinite_distance_value !== (div_data_infinite_distance_value = /*infiniteDistance*/
        ctx2[7] || void 0)) && {
          "data-infinite-distance": div_data_infinite_distance_value
        },
        dirty[0] & /*$$restProps*/
        2048 && restProps(
          /*$$restProps*/
          ctx2[11]
        )
      ]));
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(default_slot, local);
      transition_in(if_block2);
      transition_in(if_block3);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(default_slot, local);
      transition_out(if_block2);
      transition_out(if_block3);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (default_slot) default_slot.d(detaching);
      if (if_block2) if_block2.d();
      if (if_block3) if_block3.d();
      ctx[22](null);
    }
  };
}
function instance$b($$self, $$props, $$invalidate) {
  let pageContentClasses;
  const omit_props_names = [
    "tab",
    "tabActive",
    "ptr",
    "ptrDistance",
    "ptrPreloader",
    "ptrBottom",
    "ptrMousewheel",
    "infinite",
    "infiniteTop",
    "infiniteDistance",
    "infinitePreloader",
    "hideBarsOnScroll",
    "hideNavbarOnScroll",
    "hideToolbarOnScroll",
    "messagesContent",
    "loginScreen",
    "class"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  const emit = createEmitter(createEventDispatcher, $$props);
  let { tab = false } = $$props;
  let { tabActive = false } = $$props;
  let { ptr = false } = $$props;
  let { ptrDistance = void 0 } = $$props;
  let { ptrPreloader = true } = $$props;
  let { ptrBottom = false } = $$props;
  let { ptrMousewheel = false } = $$props;
  let { infinite = false } = $$props;
  let { infiniteTop = false } = $$props;
  let { infiniteDistance = void 0 } = $$props;
  let { infinitePreloader = true } = $$props;
  let { hideBarsOnScroll = false } = $$props;
  let { hideNavbarOnScroll = false } = $$props;
  let { hideToolbarOnScroll = false } = $$props;
  let { messagesContent = false } = $$props;
  let { loginScreen = false } = $$props;
  let { class: className = void 0 } = $$props;
  let pageContentEl;
  function onPtrPullStart(ptrEl) {
    if (ptrEl !== pageContentEl) return;
    emit("ptrPullStart");
  }
  function onPtrPullMove(ptrEl) {
    if (ptrEl !== pageContentEl) return;
    emit("ptrPullMove");
  }
  function onPtrPullEnd(ptrEl) {
    if (ptrEl !== pageContentEl) return;
    emit("ptrPullEnd");
  }
  function onPtrRefresh(ptrEl, done) {
    if (ptrEl !== pageContentEl) return;
    emit("ptrRefresh", [done]);
  }
  function onPtrDone(ptrEl) {
    if (ptrEl !== pageContentEl) return;
    emit("ptrDone");
  }
  function onInfinite(infEl) {
    if (infEl !== pageContentEl) return;
    emit("infinite");
  }
  function mountPageContent() {
    if (ptr) {
      app.f7.on("ptrPullStart", onPtrPullStart);
      app.f7.on("ptrPullMove", onPtrPullMove);
      app.f7.on("ptrPullEnd", onPtrPullEnd);
      app.f7.on("ptrRefresh", onPtrRefresh);
      app.f7.on("ptrDone", onPtrDone);
    }
    if (infinite) {
      app.f7.on("infinite", onInfinite);
    }
  }
  function destroyPageContent() {
    if (ptr) {
      app.f7.off("ptrPullStart", onPtrPullStart);
      app.f7.off("ptrPullMove", onPtrPullMove);
      app.f7.off("ptrPullEnd", onPtrPullEnd);
      app.f7.off("ptrRefresh", onPtrRefresh);
      app.f7.off("ptrDone", onPtrDone);
    }
    if (infinite) {
      app.f7.off("infinite", onInfinite);
    }
  }
  useTab(() => pageContentEl, emit);
  onMount(() => {
    f7ready(() => {
      mountPageContent();
    });
  });
  onDestroy(() => {
    if (!app.f7) return;
    destroyPageContent();
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      pageContentEl = $$value;
      $$invalidate(9, pageContentEl);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(32, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("tab" in $$new_props) $$invalidate(12, tab = $$new_props.tab);
    if ("tabActive" in $$new_props) $$invalidate(13, tabActive = $$new_props.tabActive);
    if ("ptr" in $$new_props) $$invalidate(0, ptr = $$new_props.ptr);
    if ("ptrDistance" in $$new_props) $$invalidate(1, ptrDistance = $$new_props.ptrDistance);
    if ("ptrPreloader" in $$new_props) $$invalidate(2, ptrPreloader = $$new_props.ptrPreloader);
    if ("ptrBottom" in $$new_props) $$invalidate(3, ptrBottom = $$new_props.ptrBottom);
    if ("ptrMousewheel" in $$new_props) $$invalidate(4, ptrMousewheel = $$new_props.ptrMousewheel);
    if ("infinite" in $$new_props) $$invalidate(5, infinite = $$new_props.infinite);
    if ("infiniteTop" in $$new_props) $$invalidate(6, infiniteTop = $$new_props.infiniteTop);
    if ("infiniteDistance" in $$new_props) $$invalidate(7, infiniteDistance = $$new_props.infiniteDistance);
    if ("infinitePreloader" in $$new_props) $$invalidate(8, infinitePreloader = $$new_props.infinitePreloader);
    if ("hideBarsOnScroll" in $$new_props) $$invalidate(14, hideBarsOnScroll = $$new_props.hideBarsOnScroll);
    if ("hideNavbarOnScroll" in $$new_props) $$invalidate(15, hideNavbarOnScroll = $$new_props.hideNavbarOnScroll);
    if ("hideToolbarOnScroll" in $$new_props) $$invalidate(16, hideToolbarOnScroll = $$new_props.hideToolbarOnScroll);
    if ("messagesContent" in $$new_props) $$invalidate(17, messagesContent = $$new_props.messagesContent);
    if ("loginScreen" in $$new_props) $$invalidate(18, loginScreen = $$new_props.loginScreen);
    if ("class" in $$new_props) $$invalidate(19, className = $$new_props.class);
    if ("$$scope" in $$new_props) $$invalidate(20, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(10, pageContentClasses = classNames(
      className,
      "page-content",
      {
        tab,
        "tab-active": tabActive,
        "ptr-content": ptr,
        "ptr-bottom": ptrBottom,
        "infinite-scroll-content": infinite,
        "infinite-scroll-top": infiniteTop,
        "hide-bars-on-scroll": hideBarsOnScroll,
        "hide-navbar-on-scroll": hideNavbarOnScroll,
        "hide-toolbar-on-scroll": hideToolbarOnScroll,
        "messages-content": messagesContent,
        "login-screen-content": loginScreen
      },
      colorClasses($$props)
    ));
  };
  $$props = exclude_internal_props($$props);
  return [
    ptr,
    ptrDistance,
    ptrPreloader,
    ptrBottom,
    ptrMousewheel,
    infinite,
    infiniteTop,
    infiniteDistance,
    infinitePreloader,
    pageContentEl,
    pageContentClasses,
    $$restProps,
    tab,
    tabActive,
    hideBarsOnScroll,
    hideNavbarOnScroll,
    hideToolbarOnScroll,
    messagesContent,
    loginScreen,
    className,
    $$scope,
    slots,
    div_binding
  ];
}
class Page_content extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$b,
      create_fragment$a,
      safe_not_equal,
      {
        tab: 12,
        tabActive: 13,
        ptr: 0,
        ptrDistance: 1,
        ptrPreloader: 2,
        ptrBottom: 3,
        ptrMousewheel: 4,
        infinite: 5,
        infiniteTop: 6,
        infiniteDistance: 7,
        infinitePreloader: 8,
        hideBarsOnScroll: 14,
        hideNavbarOnScroll: 15,
        hideToolbarOnScroll: 16,
        messagesContent: 17,
        loginScreen: 18,
        class: 19
      },
      null,
      [-1, -1]
    );
  }
}
const get_static_slot_changes_1 = (dirty) => ({});
const get_static_slot_context_1 = (ctx) => ({});
const get_static_slot_changes = (dirty) => ({});
const get_static_slot_context = (ctx) => ({});
const get_fixed_slot_changes = (dirty) => ({});
const get_fixed_slot_context = (ctx) => ({});
function create_else_block(ctx) {
  let t2;
  let current;
  const static_slot_template = (
    /*#slots*/
    ctx[44].static
  );
  const static_slot = create_slot(
    static_slot_template,
    ctx,
    /*$$scope*/
    ctx[46],
    get_static_slot_context_1
  );
  const default_slot_template = (
    /*#slots*/
    ctx[44].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[46],
    null
  );
  return {
    c() {
      if (static_slot) static_slot.c();
      t2 = space();
      if (default_slot) default_slot.c();
    },
    m(target, anchor) {
      if (static_slot) {
        static_slot.m(target, anchor);
      }
      insert(target, t2, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (static_slot) {
        if (static_slot.p && (!current || dirty[1] & /*$$scope*/
        32768)) {
          update_slot_base(
            static_slot,
            static_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[46],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[46]
            ) : get_slot_changes(
              static_slot_template,
              /*$$scope*/
              ctx2[46],
              dirty,
              get_static_slot_changes_1
            ),
            get_static_slot_context_1
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[46],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[46]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[46],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(static_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(static_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      if (static_slot) static_slot.d(detaching);
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function create_if_block$2(ctx) {
  let pagecontent;
  let current;
  pagecontent = new Page_content({
    props: {
      ptr: (
        /*ptr*/
        ctx[2]
      ),
      ptrDistance: (
        /*ptrDistance*/
        ctx[3]
      ),
      ptrPreloader: (
        /*ptrPreloader*/
        ctx[4]
      ),
      ptrBottom: (
        /*ptrBottom*/
        ctx[5]
      ),
      ptrMousewheel: (
        /*ptrMousewheel*/
        ctx[6]
      ),
      infinite: (
        /*infinite*/
        ctx[7]
      ),
      infiniteTop: (
        /*infiniteTop*/
        ctx[8]
      ),
      infiniteDistance: (
        /*infiniteDistance*/
        ctx[9]
      ),
      infinitePreloader: (
        /*infinitePreloader*/
        ctx[10]
      ),
      hideBarsOnScroll: (
        /*hideBarsOnScroll*/
        ctx[11]
      ),
      hideNavbarOnScroll: (
        /*hideNavbarOnScroll*/
        ctx[12]
      ),
      hideToolbarOnScroll: (
        /*hideToolbarOnScroll*/
        ctx[13]
      ),
      messagesContent: (
        /*messagesContent*/
        ctx[14]
      ),
      loginScreen: (
        /*loginScreen*/
        ctx[15]
      ),
      onPtrPullStart: (
        /*onPtrPullStart*/
        ctx[18]
      ),
      onPtrPullMove: (
        /*onPtrPullMove*/
        ctx[19]
      ),
      onPtrPullEnd: (
        /*onPtrPullEnd*/
        ctx[20]
      ),
      onPtrRefresh: (
        /*onPtrRefresh*/
        ctx[21]
      ),
      onPtrDone: (
        /*onPtrDone*/
        ctx[22]
      ),
      onInfinite: (
        /*onInfinite*/
        ctx[23]
      ),
      $$slots: { default: [create_default_slot$6] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(pagecontent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pagecontent, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const pagecontent_changes = {};
      if (dirty[0] & /*ptr*/
      4) pagecontent_changes.ptr = /*ptr*/
      ctx2[2];
      if (dirty[0] & /*ptrDistance*/
      8) pagecontent_changes.ptrDistance = /*ptrDistance*/
      ctx2[3];
      if (dirty[0] & /*ptrPreloader*/
      16) pagecontent_changes.ptrPreloader = /*ptrPreloader*/
      ctx2[4];
      if (dirty[0] & /*ptrBottom*/
      32) pagecontent_changes.ptrBottom = /*ptrBottom*/
      ctx2[5];
      if (dirty[0] & /*ptrMousewheel*/
      64) pagecontent_changes.ptrMousewheel = /*ptrMousewheel*/
      ctx2[6];
      if (dirty[0] & /*infinite*/
      128) pagecontent_changes.infinite = /*infinite*/
      ctx2[7];
      if (dirty[0] & /*infiniteTop*/
      256) pagecontent_changes.infiniteTop = /*infiniteTop*/
      ctx2[8];
      if (dirty[0] & /*infiniteDistance*/
      512) pagecontent_changes.infiniteDistance = /*infiniteDistance*/
      ctx2[9];
      if (dirty[0] & /*infinitePreloader*/
      1024) pagecontent_changes.infinitePreloader = /*infinitePreloader*/
      ctx2[10];
      if (dirty[0] & /*hideBarsOnScroll*/
      2048) pagecontent_changes.hideBarsOnScroll = /*hideBarsOnScroll*/
      ctx2[11];
      if (dirty[0] & /*hideNavbarOnScroll*/
      4096) pagecontent_changes.hideNavbarOnScroll = /*hideNavbarOnScroll*/
      ctx2[12];
      if (dirty[0] & /*hideToolbarOnScroll*/
      8192) pagecontent_changes.hideToolbarOnScroll = /*hideToolbarOnScroll*/
      ctx2[13];
      if (dirty[0] & /*messagesContent*/
      16384) pagecontent_changes.messagesContent = /*messagesContent*/
      ctx2[14];
      if (dirty[0] & /*loginScreen*/
      32768) pagecontent_changes.loginScreen = /*loginScreen*/
      ctx2[15];
      if (dirty[1] & /*$$scope*/
      32768) {
        pagecontent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      pagecontent.$set(pagecontent_changes);
    },
    i(local) {
      if (current) return;
      transition_in(pagecontent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pagecontent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pagecontent, detaching);
    }
  };
}
function create_default_slot$6(ctx) {
  let t2;
  let current;
  const static_slot_template = (
    /*#slots*/
    ctx[44].static
  );
  const static_slot = create_slot(
    static_slot_template,
    ctx,
    /*$$scope*/
    ctx[46],
    get_static_slot_context
  );
  const default_slot_template = (
    /*#slots*/
    ctx[44].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[46],
    null
  );
  return {
    c() {
      if (static_slot) static_slot.c();
      t2 = space();
      if (default_slot) default_slot.c();
    },
    m(target, anchor) {
      if (static_slot) {
        static_slot.m(target, anchor);
      }
      insert(target, t2, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (static_slot) {
        if (static_slot.p && (!current || dirty[1] & /*$$scope*/
        32768)) {
          update_slot_base(
            static_slot,
            static_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[46],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[46]
            ) : get_slot_changes(
              static_slot_template,
              /*$$scope*/
              ctx2[46],
              dirty,
              get_static_slot_changes
            ),
            get_static_slot_context
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[46],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[46]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[46],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(static_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(static_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      if (static_slot) static_slot.d(detaching);
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function create_fragment$9(ctx) {
  let div;
  let t2;
  let current_block_type_index;
  let if_block;
  let current;
  const fixed_slot_template = (
    /*#slots*/
    ctx[44].fixed
  );
  const fixed_slot = create_slot(
    fixed_slot_template,
    ctx,
    /*$$scope*/
    ctx[46],
    get_fixed_slot_context
  );
  const if_block_creators = [create_if_block$2, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*pageContent*/
      ctx2[1]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let div_levels = [
    { class: (
      /*classes*/
      ctx[17]
    ) },
    { "data-name": (
      /*name*/
      ctx[0]
    ) },
    restProps(
      /*$$restProps*/
      ctx[24]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  return {
    c() {
      div = element("div");
      if (fixed_slot) fixed_slot.c();
      t2 = space();
      if_block.c();
      set_attributes(div, div_data);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (fixed_slot) {
        fixed_slot.m(div, null);
      }
      append(div, t2);
      if_blocks[current_block_type_index].m(div, null);
      ctx[45](div);
      current = true;
    },
    p(ctx2, dirty) {
      if (fixed_slot) {
        if (fixed_slot.p && (!current || dirty[1] & /*$$scope*/
        32768)) {
          update_slot_base(
            fixed_slot,
            fixed_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[46],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[46]
            ) : get_slot_changes(
              fixed_slot_template,
              /*$$scope*/
              ctx2[46],
              dirty,
              get_fixed_slot_changes
            ),
            get_fixed_slot_context
          );
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty[0] & /*classes*/
        131072) && { class: (
          /*classes*/
          ctx2[17]
        ) },
        (!current || dirty[0] & /*name*/
        1) && { "data-name": (
          /*name*/
          ctx2[0]
        ) },
        dirty[0] & /*$$restProps*/
        16777216 && restProps(
          /*$$restProps*/
          ctx2[24]
        )
      ]));
    },
    i(local) {
      if (current) return;
      transition_in(fixed_slot, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(fixed_slot, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (fixed_slot) fixed_slot.d(detaching);
      if_blocks[current_block_type_index].d();
      ctx[45](null);
    }
  };
}
function instance$a($$self, $$props, $$invalidate) {
  let forceSubnavbar;
  let forceNavbarLarge;
  let classes;
  const omit_props_names = [
    "name",
    "withSubnavbar",
    "subnavbar",
    "withNavbarLarge",
    "navbarLarge",
    "noNavbar",
    "noToolbar",
    "tabs",
    "pageContent",
    "noSwipeback",
    "ptr",
    "ptrDistance",
    "ptrPreloader",
    "ptrBottom",
    "ptrMousewheel",
    "infinite",
    "infiniteTop",
    "infiniteDistance",
    "infinitePreloader",
    "hideBarsOnScroll",
    "hideNavbarOnScroll",
    "hideToolbarOnScroll",
    "messagesContent",
    "loginScreen",
    "class"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  const emit = createEmitter(createEventDispatcher, $$props);
  let { name = void 0 } = $$props;
  let { withSubnavbar = void 0 } = $$props;
  let { subnavbar = void 0 } = $$props;
  let { withNavbarLarge = void 0 } = $$props;
  let { navbarLarge = void 0 } = $$props;
  let { noNavbar = void 0 } = $$props;
  let { noToolbar = void 0 } = $$props;
  let { tabs = void 0 } = $$props;
  let { pageContent = true } = $$props;
  let { noSwipeback = void 0 } = $$props;
  let { ptr = void 0 } = $$props;
  let { ptrDistance = void 0 } = $$props;
  let { ptrPreloader = true } = $$props;
  let { ptrBottom = void 0 } = $$props;
  let { ptrMousewheel = void 0 } = $$props;
  let { infinite = void 0 } = $$props;
  let { infiniteTop = void 0 } = $$props;
  let { infiniteDistance = void 0 } = $$props;
  let { infinitePreloader = true } = $$props;
  let { hideBarsOnScroll = void 0 } = $$props;
  let { hideNavbarOnScroll = void 0 } = $$props;
  let { hideToolbarOnScroll = void 0 } = $$props;
  let { messagesContent = void 0 } = $$props;
  let { loginScreen = void 0 } = $$props;
  let { class: className = void 0 } = $$props;
  let el;
  let hasSubnavbar = false;
  let hasNavbarLarge = false;
  let hasNavbarLargeCollapsed = false;
  let hasCardExpandableOpened = false;
  let routerPositionClass = "";
  let routerPageRole = null;
  let routerPageRoleDetailRoot = false;
  let routerPageMasterStack = false;
  function onPtrPullStart() {
    emit("ptrPullStart");
  }
  function onPtrPullMove() {
    emit("ptrPullMove");
  }
  function onPtrPullEnd() {
    emit("ptrPullEnd");
  }
  function onPtrRefresh(done) {
    emit("ptrRefresh", [done]);
  }
  function onPtrDone() {
    emit("ptrDone");
  }
  function onInfinite() {
    emit("infinite");
  }
  function onPageMounted(page) {
    if (el !== page.el) return;
    emit("pageMounted", [page]);
  }
  function onPageInit(page) {
    if (el !== page.el) return;
    if (typeof withSubnavbar === "undefined" && typeof subnavbar === "undefined") {
      if (page.$navbarEl && page.$navbarEl.length && page.$navbarEl.find(".subnavbar").length || page.$el.children(".navbar").find(".subnavbar").length) {
        $$invalidate(34, hasSubnavbar = true);
      }
    }
    if (typeof withNavbarLarge === "undefined" && typeof navbarLarge === "undefined") {
      if (page.$navbarEl && page.$navbarEl.hasClass("navbar-large") || page.$el.children(".navbar-large").length) {
        $$invalidate(35, hasNavbarLarge = true);
      }
    }
    emit("pageInit", [page]);
  }
  function onPageReinit(page) {
    if (el !== page.el) return;
    emit("pageReinit", [page]);
  }
  function onPageBeforeIn(page) {
    if (el !== page.el) return;
    if (!page.swipeBack) {
      if (page.from === "next") {
        $$invalidate(38, routerPositionClass = "page-next");
      }
      if (page.from === "previous") {
        $$invalidate(38, routerPositionClass = "page-previous");
      }
    }
    emit("pageBeforeIn", [page]);
  }
  function onPageBeforeOut(page) {
    if (el !== page.el) return;
    emit("pageBeforeOut", [page]);
  }
  function onPageAfterOut(page) {
    if (el !== page.el) return;
    if (page.to === "next") {
      $$invalidate(38, routerPositionClass = "page-next");
    }
    if (page.to === "previous") {
      $$invalidate(38, routerPositionClass = "page-previous");
    }
    emit("pageAfterOut", [page]);
  }
  function onPageAfterIn(page) {
    if (el !== page.el) return;
    $$invalidate(38, routerPositionClass = "page-current");
    emit("pageAfterIn", [page]);
  }
  function onPageBeforeRemove(page) {
    if (el !== page.el) return;
    if (page.$navbarEl && page.$navbarEl[0] && page.$navbarEl.parent()[0] && page.$navbarEl.parent()[0] !== el) {
      page.$el.prepend(page.$navbarEl);
    }
    emit("pageBeforeRemove", [page]);
  }
  function onPageBeforeUnmount(page) {
    if (el !== page.el) return;
    emit("pageBeforeUnmount", [page]);
  }
  function onPagePosition(pageEl, position) {
    if (el !== pageEl) return;
    $$invalidate(38, routerPositionClass = `page-${position}`);
  }
  function onPageRole(pageEl, rolesData) {
    if (el !== pageEl) return;
    $$invalidate(39, routerPageRole = rolesData.role);
    $$invalidate(40, routerPageRoleDetailRoot = rolesData.detailRoot);
  }
  function onPageMasterStack(pageEl) {
    if (el !== pageEl) return;
    $$invalidate(41, routerPageMasterStack = true);
  }
  function onPageMasterUnstack(pageEl) {
    if (el !== pageEl) return;
    $$invalidate(41, routerPageMasterStack = false);
  }
  function onPageNavbarLargeCollapsed(pageEl) {
    if (el !== pageEl) return;
    $$invalidate(36, hasNavbarLargeCollapsed = true);
  }
  function onPageNavbarLargeExpanded(pageEl) {
    if (el !== pageEl) return;
    $$invalidate(36, hasNavbarLargeCollapsed = false);
  }
  function onCardOpened(cardEl, pageEl) {
    if (el !== pageEl) return;
    $$invalidate(37, hasCardExpandableOpened = true);
  }
  function onCardClose(cardEl, pageEl) {
    if (el !== pageEl) return;
    $$invalidate(37, hasCardExpandableOpened = false);
  }
  function onPageTabShow(pageEl) {
    if (el !== pageEl) return;
    emit("pageTabShow");
  }
  function onPageTabHide(pageEl) {
    if (el !== pageEl) return;
    emit("pageTabHide");
  }
  function mountPage() {
    app.f7.on("pageMounted", onPageMounted);
    app.f7.on("pageInit", onPageInit);
    app.f7.on("pageReinit", onPageReinit);
    app.f7.on("pageBeforeIn", onPageBeforeIn);
    app.f7.on("pageBeforeOut", onPageBeforeOut);
    app.f7.on("pageAfterOut", onPageAfterOut);
    app.f7.on("pageAfterIn", onPageAfterIn);
    app.f7.on("pageBeforeRemove", onPageBeforeRemove);
    app.f7.on("pageBeforeUnmount", onPageBeforeUnmount);
    app.f7.on("pagePosition", onPagePosition);
    app.f7.on("pageRole", onPageRole);
    app.f7.on("pageMasterStack", onPageMasterStack);
    app.f7.on("pageMasterUnstack", onPageMasterUnstack);
    app.f7.on("pageNavbarLargeCollapsed", onPageNavbarLargeCollapsed);
    app.f7.on("pageNavbarLargeExpanded", onPageNavbarLargeExpanded);
    app.f7.on("cardOpened", onCardOpened);
    app.f7.on("cardClose", onCardClose);
    app.f7.on("pageTabShow", onPageTabShow);
    app.f7.on("pageTabHide", onPageTabHide);
  }
  function destroyPage() {
    app.f7.off("pageMounted", onPageMounted);
    app.f7.off("pageInit", onPageInit);
    app.f7.off("pageReinit", onPageReinit);
    app.f7.off("pageBeforeIn", onPageBeforeIn);
    app.f7.off("pageBeforeOut", onPageBeforeOut);
    app.f7.off("pageAfterOut", onPageAfterOut);
    app.f7.off("pageAfterIn", onPageAfterIn);
    app.f7.off("pageBeforeRemove", onPageBeforeRemove);
    app.f7.off("pageBeforeUnmount", onPageBeforeUnmount);
    app.f7.off("pagePosition", onPagePosition);
    app.f7.off("pageRole", onPageRole);
    app.f7.off("pageMasterStack", onPageMasterStack);
    app.f7.off("pageMasterUnstack", onPageMasterUnstack);
    app.f7.off("pageNavbarLargeCollapsed", onPageNavbarLargeCollapsed);
    app.f7.off("pageNavbarLargeExpanded", onPageNavbarLargeExpanded);
    app.f7.off("cardOpened", onCardOpened);
    app.f7.off("cardClose", onCardClose);
    app.f7.off("pageTabShow", onPageTabShow);
    app.f7.off("pageTabHide", onPageTabHide);
  }
  onMount(() => {
    f7ready(() => {
      if (el) {
        const dom7 = app.f7.$;
        const fixedEls = dom7(el).children(".page-content").children('[data-f7-slot="fixed"]');
        if (fixedEls.length) {
          for (let i = fixedEls.length - 1; i >= 0; i -= 1) {
            dom7(el).prepend(fixedEls[i]);
          }
        }
      }
      mountPage();
    });
  });
  afterUpdate(() => {
    if (el && app.f7) {
      const dom7 = app.f7.$;
      const fixedEls = dom7(el).children(".page-content").children('[data-f7-slot="fixed"]');
      if (fixedEls.length) {
        for (let i = fixedEls.length - 1; i >= 0; i -= 1) {
          dom7(el).prepend(fixedEls[i]);
        }
      }
    }
  });
  onDestroy(() => {
    if (!app.f7) return;
    destroyPage();
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(16, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(69, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(24, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("name" in $$new_props) $$invalidate(0, name = $$new_props.name);
    if ("withSubnavbar" in $$new_props) $$invalidate(25, withSubnavbar = $$new_props.withSubnavbar);
    if ("subnavbar" in $$new_props) $$invalidate(26, subnavbar = $$new_props.subnavbar);
    if ("withNavbarLarge" in $$new_props) $$invalidate(27, withNavbarLarge = $$new_props.withNavbarLarge);
    if ("navbarLarge" in $$new_props) $$invalidate(28, navbarLarge = $$new_props.navbarLarge);
    if ("noNavbar" in $$new_props) $$invalidate(29, noNavbar = $$new_props.noNavbar);
    if ("noToolbar" in $$new_props) $$invalidate(30, noToolbar = $$new_props.noToolbar);
    if ("tabs" in $$new_props) $$invalidate(31, tabs = $$new_props.tabs);
    if ("pageContent" in $$new_props) $$invalidate(1, pageContent = $$new_props.pageContent);
    if ("noSwipeback" in $$new_props) $$invalidate(32, noSwipeback = $$new_props.noSwipeback);
    if ("ptr" in $$new_props) $$invalidate(2, ptr = $$new_props.ptr);
    if ("ptrDistance" in $$new_props) $$invalidate(3, ptrDistance = $$new_props.ptrDistance);
    if ("ptrPreloader" in $$new_props) $$invalidate(4, ptrPreloader = $$new_props.ptrPreloader);
    if ("ptrBottom" in $$new_props) $$invalidate(5, ptrBottom = $$new_props.ptrBottom);
    if ("ptrMousewheel" in $$new_props) $$invalidate(6, ptrMousewheel = $$new_props.ptrMousewheel);
    if ("infinite" in $$new_props) $$invalidate(7, infinite = $$new_props.infinite);
    if ("infiniteTop" in $$new_props) $$invalidate(8, infiniteTop = $$new_props.infiniteTop);
    if ("infiniteDistance" in $$new_props) $$invalidate(9, infiniteDistance = $$new_props.infiniteDistance);
    if ("infinitePreloader" in $$new_props) $$invalidate(10, infinitePreloader = $$new_props.infinitePreloader);
    if ("hideBarsOnScroll" in $$new_props) $$invalidate(11, hideBarsOnScroll = $$new_props.hideBarsOnScroll);
    if ("hideNavbarOnScroll" in $$new_props) $$invalidate(12, hideNavbarOnScroll = $$new_props.hideNavbarOnScroll);
    if ("hideToolbarOnScroll" in $$new_props) $$invalidate(13, hideToolbarOnScroll = $$new_props.hideToolbarOnScroll);
    if ("messagesContent" in $$new_props) $$invalidate(14, messagesContent = $$new_props.messagesContent);
    if ("loginScreen" in $$new_props) $$invalidate(15, loginScreen = $$new_props.loginScreen);
    if ("class" in $$new_props) $$invalidate(33, className = $$new_props.class);
    if ("$$scope" in $$new_props) $$invalidate(46, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*subnavbar, withSubnavbar*/
    100663296 | $$self.$$.dirty[1] & /*hasSubnavbar*/
    8) {
      $$invalidate(43, forceSubnavbar = typeof subnavbar === "undefined" && typeof withSubnavbar === "undefined" ? hasSubnavbar : false);
    }
    if ($$self.$$.dirty[0] & /*navbarLarge, withNavbarLarge*/
    402653184 | $$self.$$.dirty[1] & /*hasNavbarLarge*/
    16) {
      $$invalidate(42, forceNavbarLarge = typeof navbarLarge === "undefined" && typeof withNavbarLarge === "undefined" ? hasNavbarLarge : false);
    }
    $$invalidate(17, classes = classNames(
      className,
      "page",
      routerPositionClass,
      {
        tabs,
        "page-with-subnavbar": subnavbar || withSubnavbar || forceSubnavbar,
        "page-with-navbar-large": navbarLarge || withNavbarLarge || forceNavbarLarge,
        "no-navbar": noNavbar,
        "no-toolbar": noToolbar,
        "no-swipeback": noSwipeback,
        "page-master": routerPageRole === "master",
        "page-master-detail": routerPageRole === "detail",
        "page-master-detail-root": routerPageRoleDetailRoot === true,
        "page-master-stacked": routerPageMasterStack === true,
        "page-with-navbar-large-collapsed": hasNavbarLargeCollapsed === true,
        "page-with-card-opened": hasCardExpandableOpened === true,
        "login-screen-page": loginScreen
      },
      colorClasses($$props)
    ));
  };
  $$props = exclude_internal_props($$props);
  return [
    name,
    pageContent,
    ptr,
    ptrDistance,
    ptrPreloader,
    ptrBottom,
    ptrMousewheel,
    infinite,
    infiniteTop,
    infiniteDistance,
    infinitePreloader,
    hideBarsOnScroll,
    hideNavbarOnScroll,
    hideToolbarOnScroll,
    messagesContent,
    loginScreen,
    el,
    classes,
    onPtrPullStart,
    onPtrPullMove,
    onPtrPullEnd,
    onPtrRefresh,
    onPtrDone,
    onInfinite,
    $$restProps,
    withSubnavbar,
    subnavbar,
    withNavbarLarge,
    navbarLarge,
    noNavbar,
    noToolbar,
    tabs,
    noSwipeback,
    className,
    hasSubnavbar,
    hasNavbarLarge,
    hasNavbarLargeCollapsed,
    hasCardExpandableOpened,
    routerPositionClass,
    routerPageRole,
    routerPageRoleDetailRoot,
    routerPageMasterStack,
    forceNavbarLarge,
    forceSubnavbar,
    slots,
    div_binding,
    $$scope
  ];
}
class Page extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$a,
      create_fragment$9,
      safe_not_equal,
      {
        name: 0,
        withSubnavbar: 25,
        subnavbar: 26,
        withNavbarLarge: 27,
        navbarLarge: 28,
        noNavbar: 29,
        noToolbar: 30,
        tabs: 31,
        pageContent: 1,
        noSwipeback: 32,
        ptr: 2,
        ptrDistance: 3,
        ptrPreloader: 4,
        ptrBottom: 5,
        ptrMousewheel: 6,
        infinite: 7,
        infiniteTop: 8,
        infiniteDistance: 9,
        infinitePreloader: 10,
        hideBarsOnScroll: 11,
        hideNavbarOnScroll: 12,
        hideToolbarOnScroll: 13,
        messagesContent: 14,
        loginScreen: 15,
        class: 33
      },
      null,
      [-1, -1, -1]
    );
  }
}
function create_fragment$8(ctx) {
  let svg;
  let path2;
  let svg_levels = [
    { fill: "currentcolor" },
    { xmlns: "http://www.w3.org/2000/svg" },
    { width: "1em" },
    { height: "1em" },
    { viewBox: "0 0 56 56" },
    /*$$restProps*/
    ctx[0] || {}
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  return {
    c() {
      svg = svg_element("svg");
      path2 = svg_element("path");
      attr(path2, "d", "M 9.4257 43.7500 L 33.0273 43.7500 C 32.8632 46.9141 30.8242 48.9297 28.0117 48.9297 C 25.1757 48.9297 23.1601 46.9141 22.9726 43.7500 L 19.3164 43.7500 C 19.5039 48.2500 23.0429 52.2109 28.0117 52.2109 C 32.9570 52.2109 36.4960 48.2500 36.6835 43.7500 L 46.5742 43.7500 C 48.8005 43.7500 50.1133 42.6016 50.1133 40.9141 C 50.1133 38.5703 47.7460 36.4609 45.7070 34.375 C 44.1601 32.7578 43.7382 29.4297 43.5742 26.7344 C 43.3867 17.5000 41.0195 11.5234 34.7617 9.2734 C 33.9882 6.2266 31.4570 3.7891 28.0117 3.7891 C 24.5429 3.7891 22.0351 6.2266 21.2382 9.2734 C 15.0039 11.5234 12.6132 17.5000 12.4492 26.7344 C 12.2617 29.4297 11.8632 32.7578 10.2929 34.375 C 8.2773 36.4609 5.8867 38.5703 5.8867 40.9141 C 5.8867 42.6016 7.2226 43.7500 9.4257 43.7500 Z M 10.4570 40.2109 L 10.4570 39.9297 C 10.8789 39.2266 12.2617 37.8672 13.5039 36.4844 C 15.1679 34.6094 15.9648 31.6094 16.1757 27.0156 C 16.3632 16.7969 19.4101 13.5156 23.4413 12.4375 C 24.0273 12.2969 24.3320 11.9922 24.3554 11.4062 C 24.4492 8.9453 25.8320 7.2344 28.0117 7.2344 C 30.1679 7.2344 31.5742 8.9453 31.6445 11.4062 C 31.6679 11.9922 31.9960 12.2969 32.5820 12.4375 C 36.5898 13.5156 39.6367 16.7969 39.8476 27.0156 C 40.0351 31.6094 40.8320 34.6094 42.5195 36.4844 C 43.7382 37.8672 45.1445 39.2266 45.5664 39.9297 L 45.5664 40.2109 Z");
      set_svg_attributes(svg, svg_data);
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path2);
    },
    p(ctx2, [dirty]) {
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { fill: "currentcolor" },
        { xmlns: "http://www.w3.org/2000/svg" },
        { width: "1em" },
        { height: "1em" },
        { viewBox: "0 0 56 56" },
        dirty & /*$$restProps*/
        1 && /*$$restProps*/
        (ctx2[0] || {})
      ]));
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function instance$9($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  return [$$restProps];
}
class Bell extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$9, create_fragment$8, safe_not_equal, {});
  }
}
function create_fragment$7(ctx) {
  let svg;
  let path2;
  let svg_levels = [
    { fill: "currentcolor" },
    { xmlns: "http://www.w3.org/2000/svg" },
    { width: "1em" },
    { height: "1em" },
    { viewBox: "0 0 56 56" },
    /*$$restProps*/
    ctx[0] || {}
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  return {
    c() {
      svg = svg_element("svg");
      path2 = svg_element("path");
      attr(path2, "d", "M 6.0626 19.5390 L 49.9144 19.5390 C 50.8984 19.5390 51.7187 18.7656 51.7187 17.7812 C 51.7187 16.7968 50.8984 16 49.9144 16 L 6.0626 16 C 5.0782 16 4.2813 16.7968 4.2813 17.7812 C 4.2813 18.7656 5.0782 19.5390 6.0626 19.5390 Z M 6.0626 29.7578 L 49.9144 29.7578 C 50.8984 29.7578 51.7187 28.9843 51.7187 28 C 51.7187 26.9921 50.8984 26.1953 49.9144 26.1953 L 6.0626 26.1953 C 5.0782 26.1953 4.2813 26.9921 4.2813 28 C 4.2813 28.9843 5.0782 29.7578 6.0626 29.7578 Z M 6.0626 40 L 49.9144 40 C 50.8984 40 51.7187 39.2031 51.7187 38.1953 C 51.7187 37.2109 50.8984 36.4375 49.9144 36.4375 L 6.0626 36.4375 C 5.0782 36.4375 4.2813 37.2109 4.2813 38.1953 C 4.2813 39.2031 5.0782 40 6.0626 40 Z");
      set_svg_attributes(svg, svg_data);
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path2);
    },
    p(ctx2, [dirty]) {
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { fill: "currentcolor" },
        { xmlns: "http://www.w3.org/2000/svg" },
        { width: "1em" },
        { height: "1em" },
        { viewBox: "0 0 56 56" },
        dirty & /*$$restProps*/
        1 && /*$$restProps*/
        (ctx2[0] || {})
      ]));
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function instance$8($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  return [$$restProps];
}
class LineHorizontal3 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$8, create_fragment$7, safe_not_equal, {});
  }
}
function create_fragment$6(ctx) {
  let svg;
  let path2;
  let svg_levels = [
    { fill: "currentcolor" },
    { xmlns: "http://www.w3.org/2000/svg" },
    { width: "1em" },
    { height: "1em" },
    { viewBox: "0 0 56 56" },
    /*$$restProps*/
    ctx[0] || {}
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  return {
    c() {
      svg = svg_element("svg");
      path2 = svg_element("path");
      attr(path2, "d", "M 26.8867 37.5039 C 28.5039 37.5039 29.2539 36.3789 29.2539 34.8789 L 29.2539 34.0820 C 29.3008 30.9883 30.4258 29.6992 34.1758 27.1211 C 38.1836 24.4023 40.7383 21.2617 40.7383 16.7383 C 40.7383 9.7070 35.0195 5.6758 27.9180 5.6758 C 22.6211 5.6758 17.9570 8.1836 15.9648 12.7070 C 15.4726 13.8086 15.2617 14.8867 15.2617 15.7774 C 15.2617 17.1133 16.0352 18.0508 17.4648 18.0508 C 18.6601 18.0508 19.4570 17.3477 19.8086 16.1992 C 21.0274 11.7461 23.9570 10.0586 27.7539 10.0586 C 32.3242 10.0586 35.8867 12.6367 35.8867 16.7148 C 35.8867 20.0664 33.8008 21.9414 30.8008 24.0508 C 27.1211 26.6055 24.4258 29.3477 24.4258 33.4726 L 24.4258 34.9492 C 24.4258 36.4492 25.2461 37.5039 26.8867 37.5039 Z M 26.8867 50.3242 C 28.7383 50.3242 30.2148 48.8242 30.2148 46.9961 C 30.2148 45.1445 28.7383 43.6680 26.8867 43.6680 C 25.0586 43.6680 23.5352 45.1445 23.5352 46.9961 C 23.5352 48.8242 25.0586 50.3242 26.8867 50.3242 Z");
      set_svg_attributes(svg, svg_data);
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path2);
    },
    p(ctx2, [dirty]) {
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { fill: "currentcolor" },
        { xmlns: "http://www.w3.org/2000/svg" },
        { width: "1em" },
        { height: "1em" },
        { viewBox: "0 0 56 56" },
        dirty & /*$$restProps*/
        1 && /*$$restProps*/
        (ctx2[0] || {})
      ]));
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function instance$7($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  return [$$restProps];
}
class Question extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$7, create_fragment$6, safe_not_equal, {});
  }
}
const consoleLogger = {
  type: "logger",
  log(args) {
    this.output("log", args);
  },
  warn(args) {
    this.output("warn", args);
  },
  error(args) {
    this.output("error", args);
  },
  output(type, args) {
    if (console && console[type]) console[type].apply(console, args);
  }
};
class Logger {
  constructor(concreteLogger) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.init(concreteLogger, options);
  }
  init(concreteLogger) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.prefix = options.prefix || "i18next:";
    this.logger = concreteLogger || consoleLogger;
    this.options = options;
    this.debug = options.debug;
  }
  log() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return this.forward(args, "log", "", true);
  }
  warn() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return this.forward(args, "warn", "", true);
  }
  error() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return this.forward(args, "error", "");
  }
  deprecate() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
  }
  forward(args, lvl, prefix, debugOnly) {
    if (debugOnly && !this.debug) return null;
    if (typeof args[0] === "string") args[0] = `${prefix}${this.prefix} ${args[0]}`;
    return this.logger[lvl](args);
  }
  create(moduleName) {
    return new Logger(this.logger, {
      ...{
        prefix: `${this.prefix}:${moduleName}:`
      },
      ...this.options
    });
  }
  clone(options) {
    options = options || this.options;
    options.prefix = options.prefix || this.prefix;
    return new Logger(this.logger, options);
  }
}
var baseLogger = new Logger();
class EventEmitter {
  constructor() {
    this.observers = {};
  }
  on(events, listener) {
    events.split(" ").forEach((event) => {
      if (!this.observers[event]) this.observers[event] = /* @__PURE__ */ new Map();
      const numListeners = this.observers[event].get(listener) || 0;
      this.observers[event].set(listener, numListeners + 1);
    });
    return this;
  }
  off(event, listener) {
    if (!this.observers[event]) return;
    if (!listener) {
      delete this.observers[event];
      return;
    }
    this.observers[event].delete(listener);
  }
  emit(event) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    if (this.observers[event]) {
      const cloned = Array.from(this.observers[event].entries());
      cloned.forEach((_ref) => {
        let [observer, numTimesAdded] = _ref;
        for (let i = 0; i < numTimesAdded; i++) {
          observer(...args);
        }
      });
    }
    if (this.observers["*"]) {
      const cloned = Array.from(this.observers["*"].entries());
      cloned.forEach((_ref2) => {
        let [observer, numTimesAdded] = _ref2;
        for (let i = 0; i < numTimesAdded; i++) {
          observer.apply(observer, [event, ...args]);
        }
      });
    }
  }
}
const defer = () => {
  let res;
  let rej;
  const promise = new Promise((resolve, reject) => {
    res = resolve;
    rej = reject;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
};
const makeString = (object) => {
  if (object == null) return "";
  return "" + object;
};
const copy = (a, s, t2) => {
  a.forEach((m) => {
    if (s[m]) t2[m] = s[m];
  });
};
const lastOfPathSeparatorRegExp = /###/g;
const cleanKey = (key) => key && key.indexOf("###") > -1 ? key.replace(lastOfPathSeparatorRegExp, ".") : key;
const canNotTraverseDeeper = (object) => !object || typeof object === "string";
const getLastOfPath = (object, path2, Empty) => {
  const stack = typeof path2 !== "string" ? path2 : path2.split(".");
  let stackIndex = 0;
  while (stackIndex < stack.length - 1) {
    if (canNotTraverseDeeper(object)) return {};
    const key = cleanKey(stack[stackIndex]);
    if (!object[key] && Empty) object[key] = new Empty();
    if (Object.prototype.hasOwnProperty.call(object, key)) {
      object = object[key];
    } else {
      object = {};
    }
    ++stackIndex;
  }
  if (canNotTraverseDeeper(object)) return {};
  return {
    obj: object,
    k: cleanKey(stack[stackIndex])
  };
};
const setPath = (object, path2, newValue) => {
  const {
    obj,
    k
  } = getLastOfPath(object, path2, Object);
  if (obj !== void 0 || path2.length === 1) {
    obj[k] = newValue;
    return;
  }
  let e = path2[path2.length - 1];
  let p = path2.slice(0, path2.length - 1);
  let last = getLastOfPath(object, p, Object);
  while (last.obj === void 0 && p.length) {
    e = `${p[p.length - 1]}.${e}`;
    p = p.slice(0, p.length - 1);
    last = getLastOfPath(object, p, Object);
    if (last && last.obj && typeof last.obj[`${last.k}.${e}`] !== "undefined") {
      last.obj = void 0;
    }
  }
  last.obj[`${last.k}.${e}`] = newValue;
};
const pushPath = (object, path2, newValue, concat) => {
  const {
    obj,
    k
  } = getLastOfPath(object, path2, Object);
  obj[k] = obj[k] || [];
  obj[k].push(newValue);
};
const getPath = (object, path2) => {
  const {
    obj,
    k
  } = getLastOfPath(object, path2);
  if (!obj) return void 0;
  return obj[k];
};
const getPathWithDefaults = (data2, defaultData, key) => {
  const value2 = getPath(data2, key);
  if (value2 !== void 0) {
    return value2;
  }
  return getPath(defaultData, key);
};
const deepExtend = (target, source, overwrite) => {
  for (const prop2 in source) {
    if (prop2 !== "__proto__" && prop2 !== "constructor") {
      if (prop2 in target) {
        if (typeof target[prop2] === "string" || target[prop2] instanceof String || typeof source[prop2] === "string" || source[prop2] instanceof String) {
          if (overwrite) target[prop2] = source[prop2];
        } else {
          deepExtend(target[prop2], source[prop2], overwrite);
        }
      } else {
        target[prop2] = source[prop2];
      }
    }
  }
  return target;
};
const regexEscape = (str) => str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
const escape = (data2) => {
  if (typeof data2 === "string") {
    return data2.replace(/[&<>"'\/]/g, (s) => _entityMap[s]);
  }
  return data2;
};
class RegExpCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.regExpMap = /* @__PURE__ */ new Map();
    this.regExpQueue = [];
  }
  getRegExp(pattern) {
    const regExpFromCache = this.regExpMap.get(pattern);
    if (regExpFromCache !== void 0) {
      return regExpFromCache;
    }
    const regExpNew = new RegExp(pattern);
    if (this.regExpQueue.length === this.capacity) {
      this.regExpMap.delete(this.regExpQueue.shift());
    }
    this.regExpMap.set(pattern, regExpNew);
    this.regExpQueue.push(pattern);
    return regExpNew;
  }
}
const chars = [" ", ",", "?", "!", ";"];
const looksLikeObjectPathRegExpCache = new RegExpCache(20);
const looksLikeObjectPath = (key, nsSeparator, keySeparator) => {
  nsSeparator = nsSeparator || "";
  keySeparator = keySeparator || "";
  const possibleChars = chars.filter((c) => nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0);
  if (possibleChars.length === 0) return true;
  const r = looksLikeObjectPathRegExpCache.getRegExp(`(${possibleChars.map((c) => c === "?" ? "\\?" : c).join("|")})`);
  let matched = !r.test(key);
  if (!matched) {
    const ki = key.indexOf(keySeparator);
    if (ki > 0 && !r.test(key.substring(0, ki))) {
      matched = true;
    }
  }
  return matched;
};
const deepFind = function(obj, path2) {
  let keySeparator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!obj) return void 0;
  if (obj[path2]) return obj[path2];
  const tokens = path2.split(keySeparator);
  let current = obj;
  for (let i = 0; i < tokens.length; ) {
    if (!current || typeof current !== "object") {
      return void 0;
    }
    let next2;
    let nextPath = "";
    for (let j = i; j < tokens.length; ++j) {
      if (j !== i) {
        nextPath += keySeparator;
      }
      nextPath += tokens[j];
      next2 = current[nextPath];
      if (next2 !== void 0) {
        if (["string", "number", "boolean"].indexOf(typeof next2) > -1 && j < tokens.length - 1) {
          continue;
        }
        i += j - i + 1;
        break;
      }
    }
    current = next2;
  }
  return current;
};
const getCleanedCode = (code) => {
  if (code && code.indexOf("_") > 0) return code.replace("_", "-");
  return code;
};
class ResourceStore extends EventEmitter {
  constructor(data2) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    super();
    this.data = data2 || {};
    this.options = options;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    if (this.options.ignoreJSONStructure === void 0) {
      this.options.ignoreJSONStructure = true;
    }
  }
  addNamespaces(ns) {
    if (this.options.ns.indexOf(ns) < 0) {
      this.options.ns.push(ns);
    }
  }
  removeNamespaces(ns) {
    const index2 = this.options.ns.indexOf(ns);
    if (index2 > -1) {
      this.options.ns.splice(index2, 1);
    }
  }
  getResource(lng, ns, key) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    const ignoreJSONStructure = options.ignoreJSONStructure !== void 0 ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let path2;
    if (lng.indexOf(".") > -1) {
      path2 = lng.split(".");
    } else {
      path2 = [lng, ns];
      if (key) {
        if (Array.isArray(key)) {
          path2.push(...key);
        } else if (typeof key === "string" && keySeparator) {
          path2.push(...key.split(keySeparator));
        } else {
          path2.push(key);
        }
      }
    }
    const result = getPath(this.data, path2);
    if (!result && !ns && !key && lng.indexOf(".") > -1) {
      lng = path2[0];
      ns = path2[1];
      key = path2.slice(2).join(".");
    }
    if (result || !ignoreJSONStructure || typeof key !== "string") return result;
    return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);
  }
  addResource(lng, ns, key, value2) {
    let options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      silent: false
    };
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    let path2 = [lng, ns];
    if (key) path2 = path2.concat(keySeparator ? key.split(keySeparator) : key);
    if (lng.indexOf(".") > -1) {
      path2 = lng.split(".");
      value2 = ns;
      ns = path2[1];
    }
    this.addNamespaces(ns);
    setPath(this.data, path2, value2);
    if (!options.silent) this.emit("added", lng, ns, key, value2);
  }
  addResources(lng, ns, resources2) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
      silent: false
    };
    for (const m in resources2) {
      if (typeof resources2[m] === "string" || Array.isArray(resources2[m])) this.addResource(lng, ns, m, resources2[m], {
        silent: true
      });
    }
    if (!options.silent) this.emit("added", lng, ns, resources2);
  }
  addResourceBundle(lng, ns, resources2, deep, overwrite) {
    let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
      silent: false,
      skipCopy: false
    };
    let path2 = [lng, ns];
    if (lng.indexOf(".") > -1) {
      path2 = lng.split(".");
      deep = resources2;
      resources2 = ns;
      ns = path2[1];
    }
    this.addNamespaces(ns);
    let pack = getPath(this.data, path2) || {};
    if (!options.skipCopy) resources2 = JSON.parse(JSON.stringify(resources2));
    if (deep) {
      deepExtend(pack, resources2, overwrite);
    } else {
      pack = {
        ...pack,
        ...resources2
      };
    }
    setPath(this.data, path2, pack);
    if (!options.silent) this.emit("added", lng, ns, resources2);
  }
  removeResourceBundle(lng, ns) {
    if (this.hasResourceBundle(lng, ns)) {
      delete this.data[lng][ns];
    }
    this.removeNamespaces(ns);
    this.emit("removed", lng, ns);
  }
  hasResourceBundle(lng, ns) {
    return this.getResource(lng, ns) !== void 0;
  }
  getResourceBundle(lng, ns) {
    if (!ns) ns = this.options.defaultNS;
    if (this.options.compatibilityAPI === "v1") return {
      ...{},
      ...this.getResource(lng, ns)
    };
    return this.getResource(lng, ns);
  }
  getDataByLanguage(lng) {
    return this.data[lng];
  }
  hasLanguageSomeTranslations(lng) {
    const data2 = this.getDataByLanguage(lng);
    const n2 = data2 && Object.keys(data2) || [];
    return !!n2.find((v) => data2[v] && Object.keys(data2[v]).length > 0);
  }
  toJSON() {
    return this.data;
  }
}
var postProcessor = {
  processors: {},
  addPostProcessor(module) {
    this.processors[module.name] = module;
  },
  handle(processors, value2, key, options, translator) {
    processors.forEach((processor) => {
      if (this.processors[processor]) value2 = this.processors[processor].process(value2, key, options, translator);
    });
    return value2;
  }
};
const checkedLoadedFor = {};
class Translator extends EventEmitter {
  constructor(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super();
    copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, this);
    this.options = options;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    this.logger = baseLogger.create("translator");
  }
  changeLanguage(lng) {
    if (lng) this.language = lng;
  }
  exists(key) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    if (key === void 0 || key === null) {
      return false;
    }
    const resolved = this.resolve(key, options);
    return resolved && resolved.res !== void 0;
  }
  extractFromKey(key, options) {
    let nsSeparator = options.nsSeparator !== void 0 ? options.nsSeparator : this.options.nsSeparator;
    if (nsSeparator === void 0) nsSeparator = ":";
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    let namespaces = options.ns || this.options.defaultNS || [];
    const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
    const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
    if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
      const m = key.match(this.interpolator.nestingRegexp);
      if (m && m.length > 0) {
        return {
          key,
          namespaces
        };
      }
      const parts = key.split(nsSeparator);
      if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
      key = parts.join(keySeparator);
    }
    if (typeof namespaces === "string") namespaces = [namespaces];
    return {
      key,
      namespaces
    };
  }
  translate(keys, options, lastKey) {
    if (typeof options !== "object" && this.options.overloadTranslationOptionHandler) {
      options = this.options.overloadTranslationOptionHandler(arguments);
    }
    if (typeof options === "object") options = {
      ...options
    };
    if (!options) options = {};
    if (keys === void 0 || keys === null) return "";
    if (!Array.isArray(keys)) keys = [String(keys)];
    const returnDetails = options.returnDetails !== void 0 ? options.returnDetails : this.options.returnDetails;
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    const {
      key,
      namespaces
    } = this.extractFromKey(keys[keys.length - 1], options);
    const namespace = namespaces[namespaces.length - 1];
    const lng = options.lng || this.language;
    const appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (lng && lng.toLowerCase() === "cimode") {
      if (appendNamespaceToCIMode) {
        const nsSeparator = options.nsSeparator || this.options.nsSeparator;
        if (returnDetails) {
          return {
            res: `${namespace}${nsSeparator}${key}`,
            usedKey: key,
            exactUsedKey: key,
            usedLng: lng,
            usedNS: namespace,
            usedParams: this.getUsedParamsDetails(options)
          };
        }
        return `${namespace}${nsSeparator}${key}`;
      }
      if (returnDetails) {
        return {
          res: key,
          usedKey: key,
          exactUsedKey: key,
          usedLng: lng,
          usedNS: namespace,
          usedParams: this.getUsedParamsDetails(options)
        };
      }
      return key;
    }
    const resolved = this.resolve(keys, options);
    let res = resolved && resolved.res;
    const resUsedKey = resolved && resolved.usedKey || key;
    const resExactUsedKey = resolved && resolved.exactUsedKey || key;
    const resType = Object.prototype.toString.apply(res);
    const noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
    const joinArrays = options.joinArrays !== void 0 ? options.joinArrays : this.options.joinArrays;
    const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
    const handleAsObject = typeof res !== "string" && typeof res !== "boolean" && typeof res !== "number";
    if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === "string" && Array.isArray(res))) {
      if (!options.returnObjects && !this.options.returnObjects) {
        if (!this.options.returnedObjectHandler) {
          this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        }
        const r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, {
          ...options,
          ns: namespaces
        }) : `key '${key} (${this.language})' returned an object instead of string.`;
        if (returnDetails) {
          resolved.res = r;
          resolved.usedParams = this.getUsedParamsDetails(options);
          return resolved;
        }
        return r;
      }
      if (keySeparator) {
        const resTypeIsArray = Array.isArray(res);
        const copy2 = resTypeIsArray ? [] : {};
        const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
        for (const m in res) {
          if (Object.prototype.hasOwnProperty.call(res, m)) {
            const deepKey = `${newKeyToUse}${keySeparator}${m}`;
            copy2[m] = this.translate(deepKey, {
              ...options,
              ...{
                joinArrays: false,
                ns: namespaces
              }
            });
            if (copy2[m] === deepKey) copy2[m] = res[m];
          }
        }
        res = copy2;
      }
    } else if (handleAsObjectInI18nFormat && typeof joinArrays === "string" && Array.isArray(res)) {
      res = res.join(joinArrays);
      if (res) res = this.extendTranslation(res, keys, options, lastKey);
    } else {
      let usedDefault = false;
      let usedKey = false;
      const needsPluralHandling = options.count !== void 0 && typeof options.count !== "string";
      const hasDefaultValue = Translator.hasDefaultValue(options);
      const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : "";
      const defaultValueSuffixOrdinalFallback = options.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, {
        ordinal: false
      }) : "";
      const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();
      const defaultValue = needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] || options[`defaultValue${defaultValueSuffix}`] || options[`defaultValue${defaultValueSuffixOrdinalFallback}`] || options.defaultValue;
      if (!this.isValidLookup(res) && hasDefaultValue) {
        usedDefault = true;
        res = defaultValue;
      }
      if (!this.isValidLookup(res)) {
        usedKey = true;
        res = key;
      }
      const missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
      const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res;
      const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
      if (usedKey || usedDefault || updateMissing) {
        this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue : res);
        if (keySeparator) {
          const fk = this.resolve(key, {
            ...options,
            keySeparator: false
          });
          if (fk && fk.res) this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let lngs = [];
        const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
          for (let i = 0; i < fallbackLngs.length; i++) {
            lngs.push(fallbackLngs[i]);
          }
        } else if (this.options.saveMissingTo === "all") {
          lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
        } else {
          lngs.push(options.lng || this.language);
        }
        const send = (l, k, specificDefaultValue) => {
          const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
          if (this.options.missingKeyHandler) {
            this.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, options);
          } else if (this.backendConnector && this.backendConnector.saveMissing) {
            this.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, options);
          }
          this.emit("missingKey", l, namespace, k, res);
        };
        if (this.options.saveMissing) {
          if (this.options.saveMissingPlurals && needsPluralHandling) {
            lngs.forEach((language) => {
              const suffixes = this.pluralResolver.getSuffixes(language, options);
              if (needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] && suffixes.indexOf(`${this.options.pluralSeparator}zero`) < 0) {
                suffixes.push(`${this.options.pluralSeparator}zero`);
              }
              suffixes.forEach((suffix) => {
                send([language], key + suffix, options[`defaultValue${suffix}`] || defaultValue);
              });
            });
          } else {
            send(lngs, key, defaultValue);
          }
        }
      }
      res = this.extendTranslation(res, keys, options, resolved, lastKey);
      if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = `${namespace}:${key}`;
      if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
        if (this.options.compatibilityAPI !== "v1") {
          res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}:${key}` : key, usedDefault ? res : void 0);
        } else {
          res = this.options.parseMissingKeyHandler(res);
        }
      }
    }
    if (returnDetails) {
      resolved.res = res;
      resolved.usedParams = this.getUsedParamsDetails(options);
      return resolved;
    }
    return res;
  }
  extendTranslation(res, key, options, resolved, lastKey) {
    var _this = this;
    if (this.i18nFormat && this.i18nFormat.parse) {
      res = this.i18nFormat.parse(res, {
        ...this.options.interpolation.defaultVariables,
        ...options
      }, options.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {
        resolved
      });
    } else if (!options.skipInterpolation) {
      if (options.interpolation) this.interpolator.init({
        ...options,
        ...{
          interpolation: {
            ...this.options.interpolation,
            ...options.interpolation
          }
        }
      });
      const skipOnVariables = typeof res === "string" && (options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let nestBef;
      if (skipOnVariables) {
        const nb = res.match(this.interpolator.nestingRegexp);
        nestBef = nb && nb.length;
      }
      let data2 = options.replace && typeof options.replace !== "string" ? options.replace : options;
      if (this.options.interpolation.defaultVariables) data2 = {
        ...this.options.interpolation.defaultVariables,
        ...data2
      };
      res = this.interpolator.interpolate(res, data2, options.lng || this.language || resolved.usedLng, options);
      if (skipOnVariables) {
        const na = res.match(this.interpolator.nestingRegexp);
        const nestAft = na && na.length;
        if (nestBef < nestAft) options.nest = false;
      }
      if (!options.lng && this.options.compatibilityAPI !== "v1" && resolved && resolved.res) options.lng = this.language || resolved.usedLng;
      if (options.nest !== false) res = this.interpolator.nest(res, function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (lastKey && lastKey[0] === args[0] && !options.context) {
          _this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);
          return null;
        }
        return _this.translate(...args, key);
      }, options);
      if (options.interpolation) this.interpolator.reset();
    }
    const postProcess = options.postProcess || this.options.postProcess;
    const postProcessorNames = typeof postProcess === "string" ? [postProcess] : postProcess;
    if (res !== void 0 && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
      res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {
        i18nResolved: {
          ...resolved,
          usedParams: this.getUsedParamsDetails(options)
        },
        ...options
      } : options, this);
    }
    return res;
  }
  resolve(keys) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let found;
    let usedKey;
    let exactUsedKey;
    let usedLng;
    let usedNS;
    if (typeof keys === "string") keys = [keys];
    keys.forEach((k) => {
      if (this.isValidLookup(found)) return;
      const extracted = this.extractFromKey(k, options);
      const key = extracted.key;
      usedKey = key;
      let namespaces = extracted.namespaces;
      if (this.options.fallbackNS) namespaces = namespaces.concat(this.options.fallbackNS);
      const needsPluralHandling = options.count !== void 0 && typeof options.count !== "string";
      const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();
      const needsContextHandling = options.context !== void 0 && (typeof options.context === "string" || typeof options.context === "number") && options.context !== "";
      const codes = options.lngs ? options.lngs : this.languageUtils.toResolveHierarchy(options.lng || this.language, options.fallbackLng);
      namespaces.forEach((ns) => {
        if (this.isValidLookup(found)) return;
        usedNS = ns;
        if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(usedNS)) {
          checkedLoadedFor[`${codes[0]}-${ns}`] = true;
          this.logger.warn(`key "${usedKey}" for languages "${codes.join(", ")}" won't get resolved as namespace "${usedNS}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        }
        codes.forEach((code) => {
          if (this.isValidLookup(found)) return;
          usedLng = code;
          const finalKeys = [key];
          if (this.i18nFormat && this.i18nFormat.addLookupKeys) {
            this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);
          } else {
            let pluralSuffix;
            if (needsPluralHandling) pluralSuffix = this.pluralResolver.getSuffix(code, options.count, options);
            const zeroSuffix = `${this.options.pluralSeparator}zero`;
            const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (needsPluralHandling) {
              finalKeys.push(key + pluralSuffix);
              if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
              }
              if (needsZeroSuffixLookup) {
                finalKeys.push(key + zeroSuffix);
              }
            }
            if (needsContextHandling) {
              const contextKey = `${key}${this.options.contextSeparator}${options.context}`;
              finalKeys.push(contextKey);
              if (needsPluralHandling) {
                finalKeys.push(contextKey + pluralSuffix);
                if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                  finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                }
                if (needsZeroSuffixLookup) {
                  finalKeys.push(contextKey + zeroSuffix);
                }
              }
            }
          }
          let possibleKey;
          while (possibleKey = finalKeys.pop()) {
            if (!this.isValidLookup(found)) {
              exactUsedKey = possibleKey;
              found = this.getResource(code, ns, possibleKey, options);
            }
          }
        });
      });
    });
    return {
      res: found,
      usedKey,
      exactUsedKey,
      usedLng,
      usedNS
    };
  }
  isValidLookup(res) {
    return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
  }
  getResource(code, ns, key) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code, ns, key, options);
    return this.resourceStore.getResource(code, ns, key, options);
  }
  getUsedParamsDetails() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const optionsKeys = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"];
    const useOptionsReplaceForData = options.replace && typeof options.replace !== "string";
    let data2 = useOptionsReplaceForData ? options.replace : options;
    if (useOptionsReplaceForData && typeof options.count !== "undefined") {
      data2.count = options.count;
    }
    if (this.options.interpolation.defaultVariables) {
      data2 = {
        ...this.options.interpolation.defaultVariables,
        ...data2
      };
    }
    if (!useOptionsReplaceForData) {
      data2 = {
        ...data2
      };
      for (const key of optionsKeys) {
        delete data2[key];
      }
    }
    return data2;
  }
  static hasDefaultValue(options) {
    const prefix = "defaultValue";
    for (const option in options) {
      if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && void 0 !== options[option]) {
        return true;
      }
    }
    return false;
  }
}
const capitalize = (string) => string.charAt(0).toUpperCase() + string.slice(1);
class LanguageUtil {
  constructor(options) {
    this.options = options;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create("languageUtils");
  }
  getScriptPartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0) return null;
    const p = code.split("-");
    if (p.length === 2) return null;
    p.pop();
    if (p[p.length - 1].toLowerCase() === "x") return null;
    return this.formatLanguageCode(p.join("-"));
  }
  getLanguagePartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0) return code;
    const p = code.split("-");
    return this.formatLanguageCode(p[0]);
  }
  formatLanguageCode(code) {
    if (typeof code === "string" && code.indexOf("-") > -1) {
      const specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
      let p = code.split("-");
      if (this.options.lowerCaseLng) {
        p = p.map((part) => part.toLowerCase());
      } else if (p.length === 2) {
        p[0] = p[0].toLowerCase();
        p[1] = p[1].toUpperCase();
        if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
      } else if (p.length === 3) {
        p[0] = p[0].toLowerCase();
        if (p[1].length === 2) p[1] = p[1].toUpperCase();
        if (p[0] !== "sgn" && p[2].length === 2) p[2] = p[2].toUpperCase();
        if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
        if (specialCases.indexOf(p[2].toLowerCase()) > -1) p[2] = capitalize(p[2].toLowerCase());
      }
      return p.join("-");
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
  }
  isSupportedCode(code) {
    if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
      code = this.getLanguagePartFromCode(code);
    }
    return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
  }
  getBestMatchFromCodes(codes) {
    if (!codes) return null;
    let found;
    codes.forEach((code) => {
      if (found) return;
      const cleanedLng = this.formatLanguageCode(code);
      if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng)) found = cleanedLng;
    });
    if (!found && this.options.supportedLngs) {
      codes.forEach((code) => {
        if (found) return;
        const lngOnly = this.getLanguagePartFromCode(code);
        if (this.isSupportedCode(lngOnly)) return found = lngOnly;
        found = this.options.supportedLngs.find((supportedLng) => {
          if (supportedLng === lngOnly) return supportedLng;
          if (supportedLng.indexOf("-") < 0 && lngOnly.indexOf("-") < 0) return;
          if (supportedLng.indexOf("-") > 0 && lngOnly.indexOf("-") < 0 && supportedLng.substring(0, supportedLng.indexOf("-")) === lngOnly) return supportedLng;
          if (supportedLng.indexOf(lngOnly) === 0 && lngOnly.length > 1) return supportedLng;
        });
      });
    }
    if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];
    return found;
  }
  getFallbackCodes(fallbacks, code) {
    if (!fallbacks) return [];
    if (typeof fallbacks === "function") fallbacks = fallbacks(code);
    if (typeof fallbacks === "string") fallbacks = [fallbacks];
    if (Array.isArray(fallbacks)) return fallbacks;
    if (!code) return fallbacks.default || [];
    let found = fallbacks[code];
    if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
    if (!found) found = fallbacks[this.formatLanguageCode(code)];
    if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];
    if (!found) found = fallbacks.default;
    return found || [];
  }
  toResolveHierarchy(code, fallbackCode) {
    const fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
    const codes = [];
    const addCode = (c) => {
      if (!c) return;
      if (this.isSupportedCode(c)) {
        codes.push(c);
      } else {
        this.logger.warn(`rejecting language code not found in supportedLngs: ${c}`);
      }
    };
    if (typeof code === "string" && (code.indexOf("-") > -1 || code.indexOf("_") > -1)) {
      if (this.options.load !== "languageOnly") addCode(this.formatLanguageCode(code));
      if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly") addCode(this.getScriptPartFromCode(code));
      if (this.options.load !== "currentOnly") addCode(this.getLanguagePartFromCode(code));
    } else if (typeof code === "string") {
      addCode(this.formatLanguageCode(code));
    }
    fallbackCodes.forEach((fc) => {
      if (codes.indexOf(fc) < 0) addCode(this.formatLanguageCode(fc));
    });
    return codes;
  }
}
let sets = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}];
let _rulesPluralsTypes = {
  1: (n2) => Number(n2 > 1),
  2: (n2) => Number(n2 != 1),
  3: (n2) => 0,
  4: (n2) => Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2),
  5: (n2) => Number(n2 == 0 ? 0 : n2 == 1 ? 1 : n2 == 2 ? 2 : n2 % 100 >= 3 && n2 % 100 <= 10 ? 3 : n2 % 100 >= 11 ? 4 : 5),
  6: (n2) => Number(n2 == 1 ? 0 : n2 >= 2 && n2 <= 4 ? 1 : 2),
  7: (n2) => Number(n2 == 1 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2),
  8: (n2) => Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 != 8 && n2 != 11 ? 2 : 3),
  9: (n2) => Number(n2 >= 2),
  10: (n2) => Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 < 7 ? 2 : n2 < 11 ? 3 : 4),
  11: (n2) => Number(n2 == 1 || n2 == 11 ? 0 : n2 == 2 || n2 == 12 ? 1 : n2 > 2 && n2 < 20 ? 2 : 3),
  12: (n2) => Number(n2 % 10 != 1 || n2 % 100 == 11),
  13: (n2) => Number(n2 !== 0),
  14: (n2) => Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 == 3 ? 2 : 3),
  15: (n2) => Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2),
  16: (n2) => Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 !== 0 ? 1 : 2),
  17: (n2) => Number(n2 == 1 || n2 % 10 == 1 && n2 % 100 != 11 ? 0 : 1),
  18: (n2) => Number(n2 == 0 ? 0 : n2 == 1 ? 1 : 2),
  19: (n2) => Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 1 && n2 % 100 < 11 ? 1 : n2 % 100 > 10 && n2 % 100 < 20 ? 2 : 3),
  20: (n2) => Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 0 && n2 % 100 < 20 ? 1 : 2),
  21: (n2) => Number(n2 % 100 == 1 ? 1 : n2 % 100 == 2 ? 2 : n2 % 100 == 3 || n2 % 100 == 4 ? 3 : 0),
  22: (n2) => Number(n2 == 1 ? 0 : n2 == 2 ? 1 : (n2 < 0 || n2 > 10) && n2 % 10 == 0 ? 2 : 3)
};
const nonIntlVersions = ["v1", "v2", "v3"];
const intlVersions = ["v4"];
const suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
const createRules = () => {
  const rules = {};
  sets.forEach((set) => {
    set.lngs.forEach((l) => {
      rules[l] = {
        numbers: set.nr,
        plurals: _rulesPluralsTypes[set.fc]
      };
    });
  });
  return rules;
};
class PluralResolver {
  constructor(languageUtils) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.languageUtils = languageUtils;
    this.options = options;
    this.logger = baseLogger.create("pluralResolver");
    if ((!this.options.compatibilityJSON || intlVersions.includes(this.options.compatibilityJSON)) && (typeof Intl === "undefined" || !Intl.PluralRules)) {
      this.options.compatibilityJSON = "v3";
      this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.");
    }
    this.rules = createRules();
    this.pluralRulesCache = {};
  }
  addRule(lng, obj) {
    this.rules[lng] = obj;
  }
  clearCache() {
    this.pluralRulesCache = {};
  }
  getRule(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (this.shouldUseIntlApi()) {
      try {
        const cleanedCode = getCleanedCode(code === "dev" ? "en" : code);
        const type = options.ordinal ? "ordinal" : "cardinal";
        const cacheKey = JSON.stringify({
          cleanedCode,
          type
        });
        if (cacheKey in this.pluralRulesCache) {
          return this.pluralRulesCache[cacheKey];
        }
        const rule = new Intl.PluralRules(cleanedCode, {
          type
        });
        this.pluralRulesCache[cacheKey] = rule;
        return rule;
      } catch (err) {
        return;
      }
    }
    return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
  }
  needsPlural(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const rule = this.getRule(code, options);
    if (this.shouldUseIntlApi()) {
      return rule && rule.resolvedOptions().pluralCategories.length > 1;
    }
    return rule && rule.numbers.length > 1;
  }
  getPluralFormsOfKey(code, key) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.getSuffixes(code, options).map((suffix) => `${key}${suffix}`);
  }
  getSuffixes(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const rule = this.getRule(code, options);
    if (!rule) {
      return [];
    }
    if (this.shouldUseIntlApi()) {
      return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2) => suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory) => `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${pluralCategory}`);
    }
    return rule.numbers.map((number) => this.getSuffix(code, number, options));
  }
  getSuffix(code, count) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const rule = this.getRule(code, options);
    if (rule) {
      if (this.shouldUseIntlApi()) {
        return `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${rule.select(count)}`;
      }
      return this.getSuffixRetroCompatible(rule, count);
    }
    this.logger.warn(`no plural rule found for: ${code}`);
    return "";
  }
  getSuffixRetroCompatible(rule, count) {
    const idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
    let suffix = rule.numbers[idx];
    if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
      if (suffix === 2) {
        suffix = "plural";
      } else if (suffix === 1) {
        suffix = "";
      }
    }
    const returnSuffix = () => this.options.prepend && suffix.toString() ? this.options.prepend + suffix.toString() : suffix.toString();
    if (this.options.compatibilityJSON === "v1") {
      if (suffix === 1) return "";
      if (typeof suffix === "number") return `_plural_${suffix.toString()}`;
      return returnSuffix();
    } else if (this.options.compatibilityJSON === "v2") {
      return returnSuffix();
    } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
      return returnSuffix();
    }
    return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
  }
  shouldUseIntlApi() {
    return !nonIntlVersions.includes(this.options.compatibilityJSON);
  }
}
const deepFindWithDefaults = function(data2, defaultData, key) {
  let keySeparator = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".";
  let ignoreJSONStructure = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
  let path2 = getPathWithDefaults(data2, defaultData, key);
  if (!path2 && ignoreJSONStructure && typeof key === "string") {
    path2 = deepFind(data2, key, keySeparator);
    if (path2 === void 0) path2 = deepFind(defaultData, key, keySeparator);
  }
  return path2;
};
const regexSafe = (val2) => val2.replace(/\$/g, "$$$$");
class Interpolator {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = baseLogger.create("interpolator");
    this.options = options;
    this.format = options.interpolation && options.interpolation.format || ((value2) => value2);
    this.init(options);
  }
  init() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!options.interpolation) options.interpolation = {
      escapeValue: true
    };
    const {
      escape: escape$1,
      escapeValue,
      useRawValueToEscape,
      prefix,
      prefixEscaped,
      suffix,
      suffixEscaped,
      formatSeparator,
      unescapeSuffix,
      unescapePrefix,
      nestingPrefix,
      nestingPrefixEscaped,
      nestingSuffix,
      nestingSuffixEscaped,
      nestingOptionsSeparator,
      maxReplaces,
      alwaysFormat
    } = options.interpolation;
    this.escape = escape$1 !== void 0 ? escape$1 : escape;
    this.escapeValue = escapeValue !== void 0 ? escapeValue : true;
    this.useRawValueToEscape = useRawValueToEscape !== void 0 ? useRawValueToEscape : false;
    this.prefix = prefix ? regexEscape(prefix) : prefixEscaped || "{{";
    this.suffix = suffix ? regexEscape(suffix) : suffixEscaped || "}}";
    this.formatSeparator = formatSeparator || ",";
    this.unescapePrefix = unescapeSuffix ? "" : unescapePrefix || "-";
    this.unescapeSuffix = this.unescapePrefix ? "" : unescapeSuffix || "";
    this.nestingPrefix = nestingPrefix ? regexEscape(nestingPrefix) : nestingPrefixEscaped || regexEscape("$t(");
    this.nestingSuffix = nestingSuffix ? regexEscape(nestingSuffix) : nestingSuffixEscaped || regexEscape(")");
    this.nestingOptionsSeparator = nestingOptionsSeparator || ",";
    this.maxReplaces = maxReplaces || 1e3;
    this.alwaysFormat = alwaysFormat !== void 0 ? alwaysFormat : false;
    this.resetRegExp();
  }
  reset() {
    if (this.options) this.init(this.options);
  }
  resetRegExp() {
    const getOrResetRegExp = (existingRegExp, pattern) => {
      if (existingRegExp && existingRegExp.source === pattern) {
        existingRegExp.lastIndex = 0;
        return existingRegExp;
      }
      return new RegExp(pattern, "g");
    };
    this.regexp = getOrResetRegExp(this.regexp, `${this.prefix}(.+?)${this.suffix}`);
    this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`);
    this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`);
  }
  interpolate(str, data2, lng, options) {
    let match;
    let value2;
    let replaces;
    const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
    const handleFormat = (key) => {
      if (key.indexOf(this.formatSeparator) < 0) {
        const path2 = deepFindWithDefaults(data2, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(path2, void 0, lng, {
          ...options,
          ...data2,
          interpolationkey: key
        }) : path2;
      }
      const p = key.split(this.formatSeparator);
      const k = p.shift().trim();
      const f = p.join(this.formatSeparator).trim();
      return this.format(deepFindWithDefaults(data2, defaultData, k, this.options.keySeparator, this.options.ignoreJSONStructure), f, lng, {
        ...options,
        ...data2,
        interpolationkey: k
      });
    };
    this.resetRegExp();
    const missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
    const skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    const todos = [{
      regex: this.regexpUnescape,
      safeValue: (val2) => regexSafe(val2)
    }, {
      regex: this.regexp,
      safeValue: (val2) => this.escapeValue ? regexSafe(this.escape(val2)) : regexSafe(val2)
    }];
    todos.forEach((todo) => {
      replaces = 0;
      while (match = todo.regex.exec(str)) {
        const matchedVar = match[1].trim();
        value2 = handleFormat(matchedVar);
        if (value2 === void 0) {
          if (typeof missingInterpolationHandler === "function") {
            const temp = missingInterpolationHandler(str, match, options);
            value2 = typeof temp === "string" ? temp : "";
          } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {
            value2 = "";
          } else if (skipOnVariables) {
            value2 = match[0];
            continue;
          } else {
            this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);
            value2 = "";
          }
        } else if (typeof value2 !== "string" && !this.useRawValueToEscape) {
          value2 = makeString(value2);
        }
        const safeValue = todo.safeValue(value2);
        str = str.replace(match[0], safeValue);
        if (skipOnVariables) {
          todo.regex.lastIndex += value2.length;
          todo.regex.lastIndex -= match[0].length;
        } else {
          todo.regex.lastIndex = 0;
        }
        replaces++;
        if (replaces >= this.maxReplaces) {
          break;
        }
      }
    });
    return str;
  }
  nest(str, fc) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let match;
    let value2;
    let clonedOptions;
    const handleHasOptions = (key, inheritedOptions) => {
      const sep = this.nestingOptionsSeparator;
      if (key.indexOf(sep) < 0) return key;
      const c = key.split(new RegExp(`${sep}[ ]*{`));
      let optionsString = `{${c[1]}`;
      key = c[0];
      optionsString = this.interpolate(optionsString, clonedOptions);
      const matchedSingleQuotes = optionsString.match(/'/g);
      const matchedDoubleQuotes = optionsString.match(/"/g);
      if (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
        optionsString = optionsString.replace(/'/g, '"');
      }
      try {
        clonedOptions = JSON.parse(optionsString);
        if (inheritedOptions) clonedOptions = {
          ...inheritedOptions,
          ...clonedOptions
        };
      } catch (e) {
        this.logger.warn(`failed parsing options string in nesting for key ${key}`, e);
        return `${key}${sep}${optionsString}`;
      }
      if (clonedOptions.defaultValue && clonedOptions.defaultValue.indexOf(this.prefix) > -1) delete clonedOptions.defaultValue;
      return key;
    };
    while (match = this.nestingRegexp.exec(str)) {
      let formatters = [];
      clonedOptions = {
        ...options
      };
      clonedOptions = clonedOptions.replace && typeof clonedOptions.replace !== "string" ? clonedOptions.replace : clonedOptions;
      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;
      let doReduce = false;
      if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {
        const r = match[1].split(this.formatSeparator).map((elem) => elem.trim());
        match[1] = r.shift();
        formatters = r;
        doReduce = true;
      }
      value2 = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
      if (value2 && match[0] === str && typeof value2 !== "string") return value2;
      if (typeof value2 !== "string") value2 = makeString(value2);
      if (!value2) {
        this.logger.warn(`missed to resolve ${match[1]} for nesting ${str}`);
        value2 = "";
      }
      if (doReduce) {
        value2 = formatters.reduce((v, f) => this.format(v, f, options.lng, {
          ...options,
          interpolationkey: match[1].trim()
        }), value2.trim());
      }
      str = str.replace(match[0], value2);
      this.regexp.lastIndex = 0;
    }
    return str;
  }
}
const parseFormatStr = (formatStr) => {
  let formatName = formatStr.toLowerCase().trim();
  const formatOptions = {};
  if (formatStr.indexOf("(") > -1) {
    const p = formatStr.split("(");
    formatName = p[0].toLowerCase().trim();
    const optStr = p[1].substring(0, p[1].length - 1);
    if (formatName === "currency" && optStr.indexOf(":") < 0) {
      if (!formatOptions.currency) formatOptions.currency = optStr.trim();
    } else if (formatName === "relativetime" && optStr.indexOf(":") < 0) {
      if (!formatOptions.range) formatOptions.range = optStr.trim();
    } else {
      const opts = optStr.split(";");
      opts.forEach((opt) => {
        if (opt) {
          const [key, ...rest] = opt.split(":");
          const val2 = rest.join(":").trim().replace(/^'+|'+$/g, "");
          const trimmedKey = key.trim();
          if (!formatOptions[trimmedKey]) formatOptions[trimmedKey] = val2;
          if (val2 === "false") formatOptions[trimmedKey] = false;
          if (val2 === "true") formatOptions[trimmedKey] = true;
          if (!isNaN(val2)) formatOptions[trimmedKey] = parseInt(val2, 10);
        }
      });
    }
  }
  return {
    formatName,
    formatOptions
  };
};
const createCachedFormatter = (fn) => {
  const cache = {};
  return (val2, lng, options) => {
    let optForCache = options;
    if (options && options.interpolationkey && options.formatParams && options.formatParams[options.interpolationkey] && options[options.interpolationkey]) {
      optForCache = {
        ...optForCache,
        [options.interpolationkey]: void 0
      };
    }
    const key = lng + JSON.stringify(optForCache);
    let formatter = cache[key];
    if (!formatter) {
      formatter = fn(getCleanedCode(lng), options);
      cache[key] = formatter;
    }
    return formatter(val2);
  };
};
class Formatter {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = baseLogger.create("formatter");
    this.options = options;
    this.formats = {
      number: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt
        });
        return (val2) => formatter.format(val2);
      }),
      currency: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt,
          style: "currency"
        });
        return (val2) => formatter.format(val2);
      }),
      datetime: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.DateTimeFormat(lng, {
          ...opt
        });
        return (val2) => formatter.format(val2);
      }),
      relativetime: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.RelativeTimeFormat(lng, {
          ...opt
        });
        return (val2) => formatter.format(val2, opt.range || "day");
      }),
      list: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.ListFormat(lng, {
          ...opt
        });
        return (val2) => formatter.format(val2);
      })
    };
    this.init(options);
  }
  init(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    const iOpts = options.interpolation;
    this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
  }
  add(name, fc) {
    this.formats[name.toLowerCase().trim()] = fc;
  }
  addCached(name, fc) {
    this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);
  }
  format(value2, format, lng) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const formats = format.split(this.formatSeparator);
    if (formats.length > 1 && formats[0].indexOf("(") > 1 && formats[0].indexOf(")") < 0 && formats.find((f) => f.indexOf(")") > -1)) {
      const lastIndex = formats.findIndex((f) => f.indexOf(")") > -1);
      formats[0] = [formats[0], ...formats.splice(1, lastIndex)].join(this.formatSeparator);
    }
    const result = formats.reduce((mem, f) => {
      const {
        formatName,
        formatOptions
      } = parseFormatStr(f);
      if (this.formats[formatName]) {
        let formatted = mem;
        try {
          const valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};
          const l = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
          formatted = this.formats[formatName](mem, l, {
            ...formatOptions,
            ...options,
            ...valOptions
          });
        } catch (error) {
          this.logger.warn(error);
        }
        return formatted;
      } else {
        this.logger.warn(`there was no format function for ${formatName}`);
      }
      return mem;
    }, value2);
    return result;
  }
}
const removePending = (q, name) => {
  if (q.pending[name] !== void 0) {
    delete q.pending[name];
    q.pendingCount--;
  }
};
class Connector extends EventEmitter {
  constructor(backend, store, services) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    super();
    this.backend = backend;
    this.store = store;
    this.services = services;
    this.languageUtils = services.languageUtils;
    this.options = options;
    this.logger = baseLogger.create("backendConnector");
    this.waitingReads = [];
    this.maxParallelReads = options.maxParallelReads || 10;
    this.readingCalls = 0;
    this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;
    this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;
    this.state = {};
    this.queue = [];
    if (this.backend && this.backend.init) {
      this.backend.init(services, options.backend, options);
    }
  }
  queueLoad(languages, namespaces, options, callback) {
    const toLoad = {};
    const pending = {};
    const toLoadLanguages = {};
    const toLoadNamespaces = {};
    languages.forEach((lng) => {
      let hasAllNamespaces = true;
      namespaces.forEach((ns) => {
        const name = `${lng}|${ns}`;
        if (!options.reload && this.store.hasResourceBundle(lng, ns)) {
          this.state[name] = 2;
        } else if (this.state[name] < 0) ;
        else if (this.state[name] === 1) {
          if (pending[name] === void 0) pending[name] = true;
        } else {
          this.state[name] = 1;
          hasAllNamespaces = false;
          if (pending[name] === void 0) pending[name] = true;
          if (toLoad[name] === void 0) toLoad[name] = true;
          if (toLoadNamespaces[ns] === void 0) toLoadNamespaces[ns] = true;
        }
      });
      if (!hasAllNamespaces) toLoadLanguages[lng] = true;
    });
    if (Object.keys(toLoad).length || Object.keys(pending).length) {
      this.queue.push({
        pending,
        pendingCount: Object.keys(pending).length,
        loaded: {},
        errors: [],
        callback
      });
    }
    return {
      toLoad: Object.keys(toLoad),
      pending: Object.keys(pending),
      toLoadLanguages: Object.keys(toLoadLanguages),
      toLoadNamespaces: Object.keys(toLoadNamespaces)
    };
  }
  loaded(name, err, data2) {
    const s = name.split("|");
    const lng = s[0];
    const ns = s[1];
    if (err) this.emit("failedLoading", lng, ns, err);
    if (!err && data2) {
      this.store.addResourceBundle(lng, ns, data2, void 0, void 0, {
        skipCopy: true
      });
    }
    this.state[name] = err ? -1 : 2;
    if (err && data2) this.state[name] = 0;
    const loaded = {};
    this.queue.forEach((q) => {
      pushPath(q.loaded, [lng], ns);
      removePending(q, name);
      if (err) q.errors.push(err);
      if (q.pendingCount === 0 && !q.done) {
        Object.keys(q.loaded).forEach((l) => {
          if (!loaded[l]) loaded[l] = {};
          const loadedKeys = q.loaded[l];
          if (loadedKeys.length) {
            loadedKeys.forEach((n2) => {
              if (loaded[l][n2] === void 0) loaded[l][n2] = true;
            });
          }
        });
        q.done = true;
        if (q.errors.length) {
          q.callback(q.errors);
        } else {
          q.callback();
        }
      }
    });
    this.emit("loaded", loaded);
    this.queue = this.queue.filter((q) => !q.done);
  }
  read(lng, ns, fcName) {
    let tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    let wait = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout;
    let callback = arguments.length > 5 ? arguments[5] : void 0;
    if (!lng.length) return callback(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng,
        ns,
        fcName,
        tried,
        wait,
        callback
      });
      return;
    }
    this.readingCalls++;
    const resolver = (err, data2) => {
      this.readingCalls--;
      if (this.waitingReads.length > 0) {
        const next2 = this.waitingReads.shift();
        this.read(next2.lng, next2.ns, next2.fcName, next2.tried, next2.wait, next2.callback);
      }
      if (err && data2 && tried < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);
        }, wait);
        return;
      }
      callback(err, data2);
    };
    const fc = this.backend[fcName].bind(this.backend);
    if (fc.length === 2) {
      try {
        const r = fc(lng, ns);
        if (r && typeof r.then === "function") {
          r.then((data2) => resolver(null, data2)).catch(resolver);
        } else {
          resolver(null, r);
        }
      } catch (err) {
        resolver(err);
      }
      return;
    }
    return fc(lng, ns, resolver);
  }
  prepareLoading(languages, namespaces) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let callback = arguments.length > 3 ? arguments[3] : void 0;
    if (!this.backend) {
      this.logger.warn("No backend was added via i18next.use. Will not load resources.");
      return callback && callback();
    }
    if (typeof languages === "string") languages = this.languageUtils.toResolveHierarchy(languages);
    if (typeof namespaces === "string") namespaces = [namespaces];
    const toLoad = this.queueLoad(languages, namespaces, options, callback);
    if (!toLoad.toLoad.length) {
      if (!toLoad.pending.length) callback();
      return null;
    }
    toLoad.toLoad.forEach((name) => {
      this.loadOne(name);
    });
  }
  load(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {}, callback);
  }
  reload(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {
      reload: true
    }, callback);
  }
  loadOne(name) {
    let prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const s = name.split("|");
    const lng = s[0];
    const ns = s[1];
    this.read(lng, ns, "read", void 0, void 0, (err, data2) => {
      if (err) this.logger.warn(`${prefix}loading namespace ${ns} for language ${lng} failed`, err);
      if (!err && data2) this.logger.log(`${prefix}loaded namespace ${ns} for language ${lng}`, data2);
      this.loaded(name, err, data2);
    });
  }
  saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
    let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
    let clb = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {
    };
    if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
      this.logger.warn(`did not save key "${key}" as the namespace "${namespace}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (key === void 0 || key === null || key === "") return;
    if (this.backend && this.backend.create) {
      const opts = {
        ...options,
        isUpdate
      };
      const fc = this.backend.create.bind(this.backend);
      if (fc.length < 6) {
        try {
          let r;
          if (fc.length === 5) {
            r = fc(languages, namespace, key, fallbackValue, opts);
          } else {
            r = fc(languages, namespace, key, fallbackValue);
          }
          if (r && typeof r.then === "function") {
            r.then((data2) => clb(null, data2)).catch(clb);
          } else {
            clb(null, r);
          }
        } catch (err) {
          clb(err);
        }
      } else {
        fc(languages, namespace, key, fallbackValue, clb, opts);
      }
    }
    if (!languages || !languages[0]) return;
    this.store.addResource(languages[0], namespace, key, fallbackValue);
  }
}
const get = () => ({
  debug: false,
  initImmediate: true,
  ns: ["translation"],
  defaultNS: ["translation"],
  fallbackLng: ["dev"],
  fallbackNS: false,
  supportedLngs: false,
  nonExplicitSupportedLngs: false,
  load: "all",
  preload: false,
  simplifyPluralSuffix: true,
  keySeparator: ".",
  nsSeparator: ":",
  pluralSeparator: "_",
  contextSeparator: "_",
  partialBundledLanguages: false,
  saveMissing: false,
  updateMissing: false,
  saveMissingTo: "fallback",
  saveMissingPlurals: true,
  missingKeyHandler: false,
  missingInterpolationHandler: false,
  postProcess: false,
  postProcessPassResolved: false,
  returnNull: false,
  returnEmptyString: true,
  returnObjects: false,
  joinArrays: false,
  returnedObjectHandler: false,
  parseMissingKeyHandler: false,
  appendNamespaceToMissingKey: false,
  appendNamespaceToCIMode: false,
  overloadTranslationOptionHandler: (args) => {
    let ret = {};
    if (typeof args[1] === "object") ret = args[1];
    if (typeof args[1] === "string") ret.defaultValue = args[1];
    if (typeof args[2] === "string") ret.tDescription = args[2];
    if (typeof args[2] === "object" || typeof args[3] === "object") {
      const options = args[3] || args[2];
      Object.keys(options).forEach((key) => {
        ret[key] = options[key];
      });
    }
    return ret;
  },
  interpolation: {
    escapeValue: true,
    format: (value2) => value2,
    prefix: "{{",
    suffix: "}}",
    formatSeparator: ",",
    unescapePrefix: "-",
    nestingPrefix: "$t(",
    nestingSuffix: ")",
    nestingOptionsSeparator: ",",
    maxReplaces: 1e3,
    skipOnVariables: true
  }
});
const transformOptions = (options) => {
  if (typeof options.ns === "string") options.ns = [options.ns];
  if (typeof options.fallbackLng === "string") options.fallbackLng = [options.fallbackLng];
  if (typeof options.fallbackNS === "string") options.fallbackNS = [options.fallbackNS];
  if (options.supportedLngs && options.supportedLngs.indexOf("cimode") < 0) {
    options.supportedLngs = options.supportedLngs.concat(["cimode"]);
  }
  return options;
};
const noop = () => {
};
const bindMemberFunctions = (inst) => {
  const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach((mem) => {
    if (typeof inst[mem] === "function") {
      inst[mem] = inst[mem].bind(inst);
    }
  });
};
class I18n extends EventEmitter {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    super();
    this.options = transformOptions(options);
    this.services = {};
    this.logger = baseLogger;
    this.modules = {
      external: []
    };
    bindMemberFunctions(this);
    if (callback && !this.isInitialized && !options.isClone) {
      if (!this.options.initImmediate) {
        this.init(options, callback);
        return this;
      }
      setTimeout(() => {
        this.init(options, callback);
      }, 0);
    }
  }
  init() {
    var _this = this;
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    this.isInitializing = true;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (!options.defaultNS && options.defaultNS !== false && options.ns) {
      if (typeof options.ns === "string") {
        options.defaultNS = options.ns;
      } else if (options.ns.indexOf("translation") < 0) {
        options.defaultNS = options.ns[0];
      }
    }
    const defOpts = get();
    this.options = {
      ...defOpts,
      ...this.options,
      ...transformOptions(options)
    };
    if (this.options.compatibilityAPI !== "v1") {
      this.options.interpolation = {
        ...defOpts.interpolation,
        ...this.options.interpolation
      };
    }
    if (options.keySeparator !== void 0) {
      this.options.userDefinedKeySeparator = options.keySeparator;
    }
    if (options.nsSeparator !== void 0) {
      this.options.userDefinedNsSeparator = options.nsSeparator;
    }
    const createClassOnDemand = (ClassOrObject) => {
      if (!ClassOrObject) return null;
      if (typeof ClassOrObject === "function") return new ClassOrObject();
      return ClassOrObject;
    };
    if (!this.options.isClone) {
      if (this.modules.logger) {
        baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
      } else {
        baseLogger.init(null, this.options);
      }
      let formatter;
      if (this.modules.formatter) {
        formatter = this.modules.formatter;
      } else if (typeof Intl !== "undefined") {
        formatter = Formatter;
      }
      const lu = new LanguageUtil(this.options);
      this.store = new ResourceStore(this.options.resources, this.options);
      const s = this.services;
      s.logger = baseLogger;
      s.resourceStore = this.store;
      s.languageUtils = lu;
      s.pluralResolver = new PluralResolver(lu, {
        prepend: this.options.pluralSeparator,
        compatibilityJSON: this.options.compatibilityJSON,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      });
      if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
        s.formatter = createClassOnDemand(formatter);
        s.formatter.init(s, this.options);
        this.options.interpolation.format = s.formatter.format.bind(s.formatter);
      }
      s.interpolator = new Interpolator(this.options);
      s.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      };
      s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
      s.backendConnector.on("*", function(event) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        _this.emit(event, ...args);
      });
      if (this.modules.languageDetector) {
        s.languageDetector = createClassOnDemand(this.modules.languageDetector);
        if (s.languageDetector.init) s.languageDetector.init(s, this.options.detection, this.options);
      }
      if (this.modules.i18nFormat) {
        s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
        if (s.i18nFormat.init) s.i18nFormat.init(this);
      }
      this.translator = new Translator(this.services, this.options);
      this.translator.on("*", function(event) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        _this.emit(event, ...args);
      });
      this.modules.external.forEach((m) => {
        if (m.init) m.init(this);
      });
    }
    this.format = this.options.interpolation.format;
    if (!callback) callback = noop;
    if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      if (codes.length > 0 && codes[0] !== "dev") this.options.lng = codes[0];
    }
    if (!this.services.languageDetector && !this.options.lng) {
      this.logger.warn("init: no languageDetector is used and no lng is defined");
    }
    const storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
    storeApi.forEach((fcName) => {
      this[fcName] = function() {
        return _this.store[fcName](...arguments);
      };
    });
    const storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
    storeApiChained.forEach((fcName) => {
      this[fcName] = function() {
        _this.store[fcName](...arguments);
        return _this;
      };
    });
    const deferred = defer();
    const load2 = () => {
      const finish = (err, t2) => {
        this.isInitializing = false;
        if (this.isInitialized && !this.initializedStoreOnce) this.logger.warn("init: i18next is already initialized. You should call init just once!");
        this.isInitialized = true;
        if (!this.options.isClone) this.logger.log("initialized", this.options);
        this.emit("initialized", this.options);
        deferred.resolve(t2);
        callback(err, t2);
      };
      if (this.languages && this.options.compatibilityAPI !== "v1" && !this.isInitialized) return finish(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, finish);
    };
    if (this.options.resources || !this.options.initImmediate) {
      load2();
    } else {
      setTimeout(load2, 0);
    }
    return deferred;
  }
  loadResources(language) {
    let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
    let usedCallback = callback;
    const usedLng = typeof language === "string" ? language : this.language;
    if (typeof language === "function") usedCallback = language;
    if (!this.options.resources || this.options.partialBundledLanguages) {
      if (usedLng && usedLng.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return usedCallback();
      const toLoad = [];
      const append2 = (lng) => {
        if (!lng) return;
        if (lng === "cimode") return;
        const lngs = this.services.languageUtils.toResolveHierarchy(lng);
        lngs.forEach((l) => {
          if (l === "cimode") return;
          if (toLoad.indexOf(l) < 0) toLoad.push(l);
        });
      };
      if (!usedLng) {
        const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        fallbacks.forEach((l) => append2(l));
      } else {
        append2(usedLng);
      }
      if (this.options.preload) {
        this.options.preload.forEach((l) => append2(l));
      }
      this.services.backendConnector.load(toLoad, this.options.ns, (e) => {
        if (!e && !this.resolvedLanguage && this.language) this.setResolvedLanguage(this.language);
        usedCallback(e);
      });
    } else {
      usedCallback(null);
    }
  }
  reloadResources(lngs, ns, callback) {
    const deferred = defer();
    if (typeof lngs === "function") {
      callback = lngs;
      lngs = void 0;
    }
    if (typeof ns === "function") {
      callback = ns;
      ns = void 0;
    }
    if (!lngs) lngs = this.languages;
    if (!ns) ns = this.options.ns;
    if (!callback) callback = noop;
    this.services.backendConnector.reload(lngs, ns, (err) => {
      deferred.resolve();
      callback(err);
    });
    return deferred;
  }
  use(module) {
    if (!module) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!module.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    if (module.type === "backend") {
      this.modules.backend = module;
    }
    if (module.type === "logger" || module.log && module.warn && module.error) {
      this.modules.logger = module;
    }
    if (module.type === "languageDetector") {
      this.modules.languageDetector = module;
    }
    if (module.type === "i18nFormat") {
      this.modules.i18nFormat = module;
    }
    if (module.type === "postProcessor") {
      postProcessor.addPostProcessor(module);
    }
    if (module.type === "formatter") {
      this.modules.formatter = module;
    }
    if (module.type === "3rdParty") {
      this.modules.external.push(module);
    }
    return this;
  }
  setResolvedLanguage(l) {
    if (!l || !this.languages) return;
    if (["cimode", "dev"].indexOf(l) > -1) return;
    for (let li = 0; li < this.languages.length; li++) {
      const lngInLngs = this.languages[li];
      if (["cimode", "dev"].indexOf(lngInLngs) > -1) continue;
      if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
        this.resolvedLanguage = lngInLngs;
        break;
      }
    }
  }
  changeLanguage(lng, callback) {
    var _this2 = this;
    this.isLanguageChangingTo = lng;
    const deferred = defer();
    this.emit("languageChanging", lng);
    const setLngProps = (l) => {
      this.language = l;
      this.languages = this.services.languageUtils.toResolveHierarchy(l);
      this.resolvedLanguage = void 0;
      this.setResolvedLanguage(l);
    };
    const done = (err, l) => {
      if (l) {
        setLngProps(l);
        this.translator.changeLanguage(l);
        this.isLanguageChangingTo = void 0;
        this.emit("languageChanged", l);
        this.logger.log("languageChanged", l);
      } else {
        this.isLanguageChangingTo = void 0;
      }
      deferred.resolve(function() {
        return _this2.t(...arguments);
      });
      if (callback) callback(err, function() {
        return _this2.t(...arguments);
      });
    };
    const setLng = (lngs) => {
      if (!lng && !lngs && this.services.languageDetector) lngs = [];
      const l = typeof lngs === "string" ? lngs : this.services.languageUtils.getBestMatchFromCodes(lngs);
      if (l) {
        if (!this.language) {
          setLngProps(l);
        }
        if (!this.translator.language) this.translator.changeLanguage(l);
        if (this.services.languageDetector && this.services.languageDetector.cacheUserLanguage) this.services.languageDetector.cacheUserLanguage(l);
      }
      this.loadResources(l, (err) => {
        done(err, l);
      });
    };
    if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
      setLng(this.services.languageDetector.detect());
    } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
      if (this.services.languageDetector.detect.length === 0) {
        this.services.languageDetector.detect().then(setLng);
      } else {
        this.services.languageDetector.detect(setLng);
      }
    } else {
      setLng(lng);
    }
    return deferred;
  }
  getFixedT(lng, ns, keyPrefix) {
    var _this3 = this;
    const fixedT = function(key, opts) {
      let options;
      if (typeof opts !== "object") {
        for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
          rest[_key3 - 2] = arguments[_key3];
        }
        options = _this3.options.overloadTranslationOptionHandler([key, opts].concat(rest));
      } else {
        options = {
          ...opts
        };
      }
      options.lng = options.lng || fixedT.lng;
      options.lngs = options.lngs || fixedT.lngs;
      options.ns = options.ns || fixedT.ns;
      if (options.keyPrefix !== "") options.keyPrefix = options.keyPrefix || keyPrefix || fixedT.keyPrefix;
      const keySeparator = _this3.options.keySeparator || ".";
      let resultKey;
      if (options.keyPrefix && Array.isArray(key)) {
        resultKey = key.map((k) => `${options.keyPrefix}${keySeparator}${k}`);
      } else {
        resultKey = options.keyPrefix ? `${options.keyPrefix}${keySeparator}${key}` : key;
      }
      return _this3.t(resultKey, options);
    };
    if (typeof lng === "string") {
      fixedT.lng = lng;
    } else {
      fixedT.lngs = lng;
    }
    fixedT.ns = ns;
    fixedT.keyPrefix = keyPrefix;
    return fixedT;
  }
  t() {
    return this.translator && this.translator.translate(...arguments);
  }
  exists() {
    return this.translator && this.translator.exists(...arguments);
  }
  setDefaultNamespace(ns) {
    this.options.defaultNS = ns;
  }
  hasLoadedNamespace(ns) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!this.isInitialized) {
      this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
      return false;
    }
    if (!this.languages || !this.languages.length) {
      this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
      return false;
    }
    const lng = options.lng || this.resolvedLanguage || this.languages[0];
    const fallbackLng = this.options ? this.options.fallbackLng : false;
    const lastLng = this.languages[this.languages.length - 1];
    if (lng.toLowerCase() === "cimode") return true;
    const loadNotPending = (l, n2) => {
      const loadState = this.services.backendConnector.state[`${l}|${n2}`];
      return loadState === -1 || loadState === 0 || loadState === 2;
    };
    if (options.precheck) {
      const preResult = options.precheck(this, loadNotPending);
      if (preResult !== void 0) return preResult;
    }
    if (this.hasResourceBundle(lng, ns)) return true;
    if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;
    if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
    return false;
  }
  loadNamespaces(ns, callback) {
    const deferred = defer();
    if (!this.options.ns) {
      if (callback) callback();
      return Promise.resolve();
    }
    if (typeof ns === "string") ns = [ns];
    ns.forEach((n2) => {
      if (this.options.ns.indexOf(n2) < 0) this.options.ns.push(n2);
    });
    this.loadResources((err) => {
      deferred.resolve();
      if (callback) callback(err);
    });
    return deferred;
  }
  loadLanguages(lngs, callback) {
    const deferred = defer();
    if (typeof lngs === "string") lngs = [lngs];
    const preloaded = this.options.preload || [];
    const newLngs = lngs.filter((lng) => preloaded.indexOf(lng) < 0 && this.services.languageUtils.isSupportedCode(lng));
    if (!newLngs.length) {
      if (callback) callback();
      return Promise.resolve();
    }
    this.options.preload = preloaded.concat(newLngs);
    this.loadResources((err) => {
      deferred.resolve();
      if (callback) callback(err);
    });
    return deferred;
  }
  dir(lng) {
    if (!lng) lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);
    if (!lng) return "rtl";
    const rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
    const languageUtils = this.services && this.services.languageUtils || new LanguageUtil(get());
    return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    return new I18n(options, callback);
  }
  cloneInstance() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
    const forkResourceStore = options.forkResourceStore;
    if (forkResourceStore) delete options.forkResourceStore;
    const mergedOptions = {
      ...this.options,
      ...options,
      ...{
        isClone: true
      }
    };
    const clone = new I18n(mergedOptions);
    if (options.debug !== void 0 || options.prefix !== void 0) {
      clone.logger = clone.logger.clone(options);
    }
    const membersToCopy = ["store", "services", "language"];
    membersToCopy.forEach((m) => {
      clone[m] = this[m];
    });
    clone.services = {
      ...this.services
    };
    clone.services.utils = {
      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
    };
    if (forkResourceStore) {
      clone.store = new ResourceStore(this.store.data, mergedOptions);
      clone.services.resourceStore = clone.store;
    }
    clone.translator = new Translator(clone.services, mergedOptions);
    clone.translator.on("*", function(event) {
      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        args[_key4 - 1] = arguments[_key4];
      }
      clone.emit(event, ...args);
    });
    clone.init(mergedOptions, callback);
    clone.translator.options = mergedOptions;
    clone.translator.backendConnector.services.utils = {
      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
    };
    return clone;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
}
const instance$6 = I18n.createInstance();
instance$6.createInstance = I18n.createInstance;
instance$6.createInstance;
instance$6.dir;
instance$6.init;
instance$6.loadResources;
instance$6.reloadResources;
instance$6.use;
instance$6.changeLanguage;
instance$6.getFixedT;
instance$6.t;
instance$6.exists;
instance$6.setDefaultNamespace;
instance$6.hasLoadedNamespace;
instance$6.loadNamespaces;
instance$6.loadLanguages;
const subscriber_queue = [];
function writable(value2, start = noop$1) {
  let stop2;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value2, new_value)) {
      value2 = new_value;
      if (stop2) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value2);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value2));
  }
  function subscribe2(run2, invalidate = noop$1) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop2 = start(set, update2) || noop$1;
    }
    run2(value2);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop2) {
        stop2();
        stop2 = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}
const isLoading = writable(true);
class I18NextTranslationStore {
  constructor(i18n2) {
    this.i18n = this.createInstance(i18n2);
    this.isLoading = this.createLoadingInstance(i18n2);
  }
  createInstance(i18n2) {
    const i18nWritable = writable(i18n2);
    i18n2.on("initialized", () => {
      i18nWritable.set(i18n2);
    });
    i18n2.on("loaded", () => {
      i18nWritable.set(i18n2);
    });
    i18n2.on("added", () => i18nWritable.set(i18n2));
    i18n2.on("languageChanged", () => {
      i18nWritable.set(i18n2);
    });
    return i18nWritable;
  }
  createLoadingInstance(i18n2) {
    i18n2.on("loaded", (resources2) => {
      Object.keys(resources2).length !== 0 && isLoading.set(false);
    });
    i18n2.on("failedLoading", () => {
      isLoading.set(true);
    });
    return isLoading;
  }
}
const createI18nStore = (i18n2) => {
  const i18nStore = new I18NextTranslationStore(i18n2);
  return i18nStore.i18n;
};
const {
  slice,
  forEach
} = [];
function defaults(obj) {
  forEach.call(slice.call(arguments, 1), (source) => {
    if (source) {
      for (const prop2 in source) {
        if (obj[prop2] === void 0) obj[prop2] = source[prop2];
      }
    }
  });
  return obj;
}
const fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
const serializeCookie = (name, val2, options) => {
  const opt = options || {};
  opt.path = opt.path || "/";
  const value2 = encodeURIComponent(val2);
  let str = `${name}=${value2}`;
  if (opt.maxAge > 0) {
    const maxAge = opt.maxAge - 0;
    if (Number.isNaN(maxAge)) throw new Error("maxAge should be a Number");
    str += `; Max-Age=${Math.floor(maxAge)}`;
  }
  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError("option domain is invalid");
    }
    str += `; Domain=${opt.domain}`;
  }
  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError("option path is invalid");
    }
    str += `; Path=${opt.path}`;
  }
  if (opt.expires) {
    if (typeof opt.expires.toUTCString !== "function") {
      throw new TypeError("option expires is invalid");
    }
    str += `; Expires=${opt.expires.toUTCString()}`;
  }
  if (opt.httpOnly) str += "; HttpOnly";
  if (opt.secure) str += "; Secure";
  if (opt.sameSite) {
    const sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true:
        str += "; SameSite=Strict";
        break;
      case "lax":
        str += "; SameSite=Lax";
        break;
      case "strict":
        str += "; SameSite=Strict";
        break;
      case "none":
        str += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return str;
};
const cookie = {
  create(name, value2, minutes, domain) {
    let cookieOptions = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      path: "/",
      sameSite: "strict"
    };
    if (minutes) {
      cookieOptions.expires = /* @__PURE__ */ new Date();
      cookieOptions.expires.setTime(cookieOptions.expires.getTime() + minutes * 60 * 1e3);
    }
    if (domain) cookieOptions.domain = domain;
    document.cookie = serializeCookie(name, encodeURIComponent(value2), cookieOptions);
  },
  read(name) {
    const nameEQ = `${name}=`;
    const ca = document.cookie.split(";");
    for (let i = 0; i < ca.length; i++) {
      let c = ca[i];
      while (c.charAt(0) === " ") c = c.substring(1, c.length);
      if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
    }
    return null;
  },
  remove(name) {
    this.create(name, "", -1);
  }
};
var cookie$1 = {
  name: "cookie",
  // Deconstruct the options object and extract the lookupCookie property
  lookup(_ref) {
    let {
      lookupCookie
    } = _ref;
    if (lookupCookie && typeof document !== "undefined") {
      return cookie.read(lookupCookie) || void 0;
    }
    return void 0;
  },
  // Deconstruct the options object and extract the lookupCookie, cookieMinutes, cookieDomain, and cookieOptions properties
  cacheUserLanguage(lng, _ref2) {
    let {
      lookupCookie,
      cookieMinutes,
      cookieDomain,
      cookieOptions
    } = _ref2;
    if (lookupCookie && typeof document !== "undefined") {
      cookie.create(lookupCookie, lng, cookieMinutes, cookieDomain, cookieOptions);
    }
  }
};
var querystring = {
  name: "querystring",
  // Deconstruct the options object and extract the lookupQuerystring property
  lookup(_ref) {
    var _a;
    let {
      lookupQuerystring
    } = _ref;
    let found;
    if (typeof window !== "undefined") {
      let {
        search
      } = window.location;
      if (!window.location.search && ((_a = window.location.hash) == null ? void 0 : _a.indexOf("?")) > -1) {
        search = window.location.hash.substring(window.location.hash.indexOf("?"));
      }
      const query = search.substring(1);
      const params = query.split("&");
      for (let i = 0; i < params.length; i++) {
        const pos = params[i].indexOf("=");
        if (pos > 0) {
          const key = params[i].substring(0, pos);
          if (key === lookupQuerystring) {
            found = params[i].substring(pos + 1);
          }
        }
      }
    }
    return found;
  }
};
let hasLocalStorageSupport = null;
const localStorageAvailable = () => {
  if (hasLocalStorageSupport !== null) return hasLocalStorageSupport;
  try {
    hasLocalStorageSupport = window !== "undefined" && window.localStorage !== null;
    const testKey = "i18next.translate.boo";
    window.localStorage.setItem(testKey, "foo");
    window.localStorage.removeItem(testKey);
  } catch (e) {
    hasLocalStorageSupport = false;
  }
  return hasLocalStorageSupport;
};
var localStorage = {
  name: "localStorage",
  // Deconstruct the options object and extract the lookupLocalStorage property
  lookup(_ref) {
    let {
      lookupLocalStorage
    } = _ref;
    if (lookupLocalStorage && localStorageAvailable()) {
      return window.localStorage.getItem(lookupLocalStorage) || void 0;
    }
    return void 0;
  },
  // Deconstruct the options object and extract the lookupLocalStorage property
  cacheUserLanguage(lng, _ref2) {
    let {
      lookupLocalStorage
    } = _ref2;
    if (lookupLocalStorage && localStorageAvailable()) {
      window.localStorage.setItem(lookupLocalStorage, lng);
    }
  }
};
let hasSessionStorageSupport = null;
const sessionStorageAvailable = () => {
  if (hasSessionStorageSupport !== null) return hasSessionStorageSupport;
  try {
    hasSessionStorageSupport = window !== "undefined" && window.sessionStorage !== null;
    const testKey = "i18next.translate.boo";
    window.sessionStorage.setItem(testKey, "foo");
    window.sessionStorage.removeItem(testKey);
  } catch (e) {
    hasSessionStorageSupport = false;
  }
  return hasSessionStorageSupport;
};
var sessionStorage = {
  name: "sessionStorage",
  lookup(_ref) {
    let {
      lookupSessionStorage
    } = _ref;
    if (lookupSessionStorage && sessionStorageAvailable()) {
      return window.sessionStorage.getItem(lookupSessionStorage) || void 0;
    }
    return void 0;
  },
  cacheUserLanguage(lng, _ref2) {
    let {
      lookupSessionStorage
    } = _ref2;
    if (lookupSessionStorage && sessionStorageAvailable()) {
      window.sessionStorage.setItem(lookupSessionStorage, lng);
    }
  }
};
var navigator$1 = {
  name: "navigator",
  lookup(options) {
    const found = [];
    if (typeof navigator !== "undefined") {
      const {
        languages,
        userLanguage,
        language
      } = navigator;
      if (languages) {
        for (let i = 0; i < languages.length; i++) {
          found.push(languages[i]);
        }
      }
      if (userLanguage) {
        found.push(userLanguage);
      }
      if (language) {
        found.push(language);
      }
    }
    return found.length > 0 ? found : void 0;
  }
};
var htmlTag = {
  name: "htmlTag",
  // Deconstruct the options object and extract the htmlTag property
  lookup(_ref) {
    let {
      htmlTag: htmlTag2
    } = _ref;
    let found;
    const internalHtmlTag = htmlTag2 || (typeof document !== "undefined" ? document.documentElement : null);
    if (internalHtmlTag && typeof internalHtmlTag.getAttribute === "function") {
      found = internalHtmlTag.getAttribute("lang");
    }
    return found;
  }
};
var path = {
  name: "path",
  // Deconstruct the options object and extract the lookupFromPathIndex property
  lookup(_ref) {
    var _a;
    let {
      lookupFromPathIndex
    } = _ref;
    if (typeof window === "undefined") return void 0;
    const language = window.location.pathname.match(/\/([a-zA-Z-]*)/g);
    if (!Array.isArray(language)) return void 0;
    const index2 = typeof lookupFromPathIndex === "number" ? lookupFromPathIndex : 0;
    return (_a = language[index2]) == null ? void 0 : _a.replace("/", "");
  }
};
var subdomain = {
  name: "subdomain",
  lookup(_ref) {
    var _a, _b;
    let {
      lookupFromSubdomainIndex
    } = _ref;
    const internalLookupFromSubdomainIndex = typeof lookupFromSubdomainIndex === "number" ? lookupFromSubdomainIndex + 1 : 1;
    const language = typeof window !== "undefined" && ((_b = (_a = window.location) == null ? void 0 : _a.hostname) == null ? void 0 : _b.match(/^(\w{2,5})\.(([a-z0-9-]{1,63}\.[a-z]{2,6})|localhost)/i));
    if (!language) return void 0;
    return language[internalLookupFromSubdomainIndex];
  }
};
function getDefaults() {
  return {
    order: ["querystring", "cookie", "localStorage", "sessionStorage", "navigator", "htmlTag"],
    lookupQuerystring: "lng",
    lookupCookie: "i18next",
    lookupLocalStorage: "i18nextLng",
    lookupSessionStorage: "i18nextLng",
    // cache user language
    caches: ["localStorage"],
    excludeCacheFor: ["cimode"],
    // cookieMinutes: 10,
    // cookieDomain: 'myDomain'
    convertDetectedLanguage: (l) => l
  };
}
class Browser {
  constructor(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.type = "languageDetector";
    this.detectors = {};
    this.init(services, options);
  }
  init(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let i18nOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    this.services = services || {
      languageUtils: {}
    };
    this.options = defaults(options, this.options || {}, getDefaults());
    if (typeof this.options.convertDetectedLanguage === "string" && this.options.convertDetectedLanguage.indexOf("15897") > -1) {
      this.options.convertDetectedLanguage = (l) => l.replace("-", "_");
    }
    if (this.options.lookupFromUrlIndex) this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex;
    this.i18nOptions = i18nOptions;
    this.addDetector(cookie$1);
    this.addDetector(querystring);
    this.addDetector(localStorage);
    this.addDetector(sessionStorage);
    this.addDetector(navigator$1);
    this.addDetector(htmlTag);
    this.addDetector(path);
    this.addDetector(subdomain);
  }
  addDetector(detector) {
    this.detectors[detector.name] = detector;
    return this;
  }
  detect(detectionOrder) {
    if (!detectionOrder) detectionOrder = this.options.order;
    let detected = [];
    detectionOrder.forEach((detectorName) => {
      if (this.detectors[detectorName]) {
        let lookup = this.detectors[detectorName].lookup(this.options);
        if (lookup && typeof lookup === "string") lookup = [lookup];
        if (lookup) detected = detected.concat(lookup);
      }
    });
    detected = detected.map((d) => this.options.convertDetectedLanguage(d));
    if (this.services.languageUtils.getBestMatchFromCodes) return detected;
    return detected.length > 0 ? detected[0] : null;
  }
  cacheUserLanguage(lng, caches) {
    if (!caches) caches = this.options.caches;
    if (!caches) return;
    if (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(lng) > -1) return;
    caches.forEach((cacheName) => {
      if (this.detectors[cacheName]) this.detectors[cacheName].cacheUserLanguage(lng, this.options);
    });
  }
}
Browser.type = "languageDetector";
const uiEN = {
  panel: {
    title: "Menu",
    navTitle: "Navigation",
    navAbout: "About page"
  },
  langswitcher: {
    title: "Choise lang"
  },
  home: {
    navTitle: "Holiday calendar"
  },
  about: {
    navTitle: "About",
    blockTitle: "Welcome to About page!",
    description: "This page about of all us."
  },
  calendar: {
    months: [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ],
    days: [
      "Mon",
      "Tue",
      "Wed",
      "Thu",
      "Fri",
      "Sat",
      "Sun"
    ]
  }
};
const calendarEN = {
  govnonworkingday: [
    {
      date: {
        month: 0,
        day: 1
      },
      hours: 23,
      minutes: 59,
      title: "en",
      color: "#ff2d55"
    },
    {
      date: {
        month: 1,
        day: 6
      },
      hours: 9,
      minutes: 30,
      title: "en",
      color: "#ff2d55"
    },
    {
      date: {
        month: 4,
        day: 1
      },
      hours: 9,
      minutes: 30,
      title: "en",
      color: "#ff2d55"
    },
    {
      date: {
        month: 4,
        day: 3
      },
      hours: 9,
      minutes: 30,
      title: "en",
      color: "#ff2d55"
    },
    {
      date: {
        month: 7,
        day: 15
      },
      hours: 9,
      minutes: 30,
      title: "en",
      color: "#ff2d55"
    },
    {
      date: {
        month: 10,
        day: 1
      },
      hours: 9,
      minutes: 30,
      title: "en",
      color: "#ff2d55"
    },
    {
      date: {
        month: 10,
        day: 11
      },
      hours: 9,
      minutes: 30,
      title: "en",
      color: "#ff2d55"
    },
    {
      date: {
        month: 11,
        day: 25
      },
      hours: 9,
      minutes: 30,
      title: "en",
      color: "#ff2d55"
    },
    {
      date: {
        month: 11,
        day: 26
      },
      hours: 9,
      minutes: 30,
      title: "en",
      color: "#ff2d55"
    }
  ]
};
const logRU = {
  debug: {
    langDefault: "  :",
    onLanguageChangedMsg: "i18next onLanguageChanged:",
    app: {
      localesChecking: "APP ->  :"
    },
    calendar: {
      dataFromLocales: "Calendar ->   :",
      eventAfterLangChanged: "Calendar ->   (  ):",
      eventDefault: "Calendar ->   ( ):",
      monthAfterLangChanged: "Calendar ->    (  ):"
    }
  }
};
const uiRU = {
  panel: {
    title: "",
    navTitle: "",
    navAbout: " "
  },
  langswitcher: {
    title: " "
  },
  home: {
    navTitle: " "
  },
  about: {
    navTitle: " ",
    blockTitle: "     !",
    description: "   ,       ."
  },
  calendar: {
    months: [
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      ""
    ],
    days: [
      "",
      "",
      "",
      "",
      "",
      "",
      ""
    ]
  }
};
const calendarRU = {
  govnonworkingday: [
    {
      date: {
        month: 0,
        day: 1
      },
      hours: 23,
      minutes: 59,
      title: " ",
      color: "#ff2d55"
    },
    {
      date: {
        month: 1,
        day: 6
      },
      hours: 9,
      minutes: 30,
      title: "",
      color: "#ff2d55"
    },
    {
      date: {
        month: 4,
        day: 1
      },
      hours: 9,
      minutes: 30,
      title: "   ",
      color: "#ff2d55"
    },
    {
      date: {
        month: 4,
        day: 3
      },
      hours: 9,
      minutes: 30,
      title: "    (    3  1791)",
      color: "#ff2d55"
    },
    {
      date: {
        month: 7,
        day: 15
      },
      hours: 9,
      minutes: 30,
      title: "   ",
      color: "#ff2d55"
    },
    {
      date: {
        month: 10,
        day: 1
      },
      hours: 9,
      minutes: 30,
      title: "  ",
      color: "#ff2d55"
    },
    {
      date: {
        month: 10,
        day: 11
      },
      hours: 9,
      minutes: 30,
      title: "  ",
      color: "#ff2d55"
    },
    {
      date: {
        month: 11,
        day: 25
      },
      hours: 9,
      minutes: 30,
      title: "  ",
      color: "#ff2d55"
    },
    {
      date: {
        month: 11,
        day: 26
      },
      hours: 9,
      minutes: 30,
      title: "  ",
      color: "#ff2d55"
    }
  ]
};
const logEN = {
  debug: {
    langDefault: "default language:",
    onLanguageChangedMsg: "i18next onLanguageChanged:",
    app: {
      localesChecking: "APP -> checking translations:"
    },
    calendar: {
      dataFromLocales: "Calendar -> data from translations:",
      eventAfterLangChanged: "Calendar -> Calendar events (after changing language):",
      eventDefault: "Calendar -> Calendar events (normal state):"
    }
  }
};
const resources = {
  en: {
    ui: uiEN,
    calendar: calendarEN,
    debugmsg: logEN
  },
  ru: {
    ui: uiRU,
    calendar: calendarRU,
    debugmsg: logRU
  }
};
instance$6.use(Browser).init({
  debug: false,
  detection: {
    order: ["querystring", "localStorage", "navigator"],
    caches: ["localStorage"],
    lookupQuerystring: "lng",
    lookupLocalStorage: "locale"
  },
  fallbackLng: "ru",
  resources,
  interpolation: {
    escapeValue: false
    // not needed for svelte as it escapes by default
  }
});
const i18n = createI18nStore(instance$6);
function debug(msg, value2) {
}
function create_default_slot$5(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "id", "calendar-container");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment$5(ctx) {
  let block;
  let current;
  block = new Block({
    props: {
      strong: true,
      inset: true,
      $$slots: { default: [create_default_slot$5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(block.$$.fragment);
    },
    m(target, anchor) {
      mount_component(block, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const block_changes = {};
      if (dirty & /*$$scope*/
      1024) {
        block_changes.$$scope = { dirty, ctx: ctx2 };
      }
      block.$set(block_changes);
    },
    i(local) {
      if (current) return;
      transition_in(block.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(block.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(block, detaching);
    }
  };
}
function instance$5($$self, $$props, $$invalidate) {
  let $i18n;
  const i18n2 = getContext("i18n");
  component_subscribe($$self, i18n2, (value2) => $$invalidate(2, $i18n = value2));
  let lng = $i18n.language;
  $i18n.t("debugmsg:debug:langDefault");
  const date = /* @__PURE__ */ new Date();
  const year = date.getFullYear();
  let { events = [] } = $$props;
  function renderLocalesCollection(array2) {
    array2.forEach((item) => {
      $i18n.t("debugmsg:debug:calendar:dataFromLocales");
      events.push({
        date: new Date(year, item.date.month, item.date.day),
        hours: item.hours,
        minutes: item.minutes,
        title: item.title,
        color: item.color
      });
    });
  }
  function dynamicArrayGeneration(value2 = lng) {
    switch (value2) {
      case "ru":
        events.splice(0, events.length);
        renderLocalesCollection(resources.ru.calendar.govnonworkingday);
        break;
      case "en":
        events.splice(0, events.length);
        renderLocalesCollection(resources.en.calendar.govnonworkingday);
        break;
      default:
        events.splice(0, events.length);
        renderLocalesCollection(resources.ru.calendar.govnonworkingday);
    }
    $i18n.on("languageChanged", (changed) => {
      $i18n.t("debugmsg:debug:onLanguageChangedMsg");
      dynamicArrayGeneration(changed);
      $i18n.t("debugmsg:debug:calendar:eventAfterLangChanged");
    });
  }
  $i18n.t("debugmsg:debug:calendar:eventDefault");
  dynamicArrayGeneration();
  $$self.$$set = ($$props2) => {
    if ("events" in $$props2) $$invalidate(1, events = $$props2.events);
  };
  return [i18n2, events];
}
class CalendarzSwiat extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$5, create_fragment$5, safe_not_equal, { events: 1 });
  }
}
function get_each_context$2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list[i];
  child_ctx[3] = i;
  return child_ctx;
}
function create_default_slot_5$1(ctx) {
  let t2;
  return {
    c() {
      t2 = text("Notification");
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_root_start_slot$1(ctx) {
  let div;
  let div_style_value;
  return {
    c() {
      div = element("div");
      attr(div, "class", "event-color");
      attr(div, "style", div_style_value = `background-color: ${/*item*/
      ctx[1].color}`);
      attr(div, "slot", "root-start");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*eventItems*/
      1 && div_style_value !== (div_style_value = `background-color: ${/*item*/
      ctx2[1].color}`)) {
        attr(div, "style", div_style_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_each_block$2(key_1, ctx) {
  let first;
  let listitem;
  let current;
  listitem = new List_item({
    props: {
      title: (
        /*item*/
        ctx[1].title
      ),
      after: (
        /*item*/
        ctx[1].time
      ),
      $$slots: { "root-start": [create_root_start_slot$1] },
      $$scope: { ctx }
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(listitem.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(listitem, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const listitem_changes = {};
      if (dirty & /*eventItems*/
      1) listitem_changes.title = /*item*/
      ctx[1].title;
      if (dirty & /*eventItems*/
      1) listitem_changes.after = /*item*/
      ctx[1].time;
      if (dirty & /*$$scope, eventItems*/
      17) {
        listitem_changes.$$scope = { dirty, ctx };
      }
      listitem.$set(listitem_changes);
    },
    i(local) {
      if (current) return;
      transition_in(listitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(listitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(listitem, detaching);
    }
  };
}
function create_if_block$1(ctx) {
  let listitem;
  let current;
  listitem = new List_item({
    props: {
      $$slots: { default: [create_default_slot_4$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(listitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(listitem, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(listitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(listitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(listitem, detaching);
    }
  };
}
function create_default_slot_4$3(ctx) {
  let t2;
  return {
    c() {
      t2 = text(" .");
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_3$3(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t2;
  let if_block_anchor;
  let current;
  let each_value = ensure_array_like(
    /*eventItems*/
    ctx[0]
  );
  const get_key = (ctx2) => (
    /*index*/
    ctx2[3]
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$2(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$2(key, child_ctx));
  }
  let if_block = (
    /*eventItems*/
    ctx[0].length === 0 && create_if_block$1(ctx)
  );
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t2 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, t2, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*eventItems*/
      1) {
        each_value = ensure_array_like(
          /*eventItems*/
          ctx2[0]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, t2.parentNode, outro_and_destroy_block, create_each_block$2, t2, get_each_context$2);
        check_outros();
      }
      if (
        /*eventItems*/
        ctx2[0].length === 0
      ) {
        if (if_block) {
          if (dirty & /*eventItems*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(if_block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(if_block_anchor);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_default_slot_2$3(ctx) {
  let list;
  let current;
  list = new List({
    props: {
      $$slots: { default: [create_default_slot_3$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(list.$$.fragment);
    },
    m(target, anchor) {
      mount_component(list, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const list_changes = {};
      if (dirty & /*$$scope, eventItems*/
      17) {
        list_changes.$$scope = { dirty, ctx: ctx2 };
      }
      list.$set(list_changes);
    },
    i(local) {
      if (current) return;
      transition_in(list.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(list.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(list, detaching);
    }
  };
}
function create_default_slot_1$4(ctx) {
  let blocktitle;
  let t2;
  let block;
  let current;
  blocktitle = new Block_title({
    props: {
      large: true,
      $$slots: { default: [create_default_slot_5$1] },
      $$scope: { ctx }
    }
  });
  block = new Block({
    props: {
      strongIos: true,
      outlineIos: true,
      $$slots: { default: [create_default_slot_2$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(blocktitle.$$.fragment);
      t2 = space();
      create_component(block.$$.fragment);
    },
    m(target, anchor) {
      mount_component(blocktitle, target, anchor);
      insert(target, t2, anchor);
      mount_component(block, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const blocktitle_changes = {};
      if (dirty & /*$$scope*/
      16) {
        blocktitle_changes.$$scope = { dirty, ctx: ctx2 };
      }
      blocktitle.$set(blocktitle_changes);
      const block_changes = {};
      if (dirty & /*$$scope, eventItems*/
      17) {
        block_changes.$$scope = { dirty, ctx: ctx2 };
      }
      block.$set(block_changes);
    },
    i(local) {
      if (current) return;
      transition_in(blocktitle.$$.fragment, local);
      transition_in(block.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(blocktitle.$$.fragment, local);
      transition_out(block.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(blocktitle, detaching);
      destroy_component(block, detaching);
    }
  };
}
function create_fixed_slot(ctx) {
  let button;
  return {
    c() {
      button = element("button");
      attr(button, "slot", "fixed");
      attr(button, "class", "UI-swipe-handler swipe-handler");
    },
    m(target, anchor) {
      insert(target, button, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
    }
  };
}
function create_default_slot$4(ctx) {
  let page;
  let current;
  page = new Page({
    props: {
      $$slots: {
        fixed: [create_fixed_slot],
        default: [create_default_slot_1$4]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(page.$$.fragment);
    },
    m(target, anchor) {
      mount_component(page, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const page_changes = {};
      if (dirty & /*$$scope, eventItems*/
      17) {
        page_changes.$$scope = { dirty, ctx: ctx2 };
      }
      page.$set(page_changes);
    },
    i(local) {
      if (current) return;
      transition_in(page.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(page.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(page, detaching);
    }
  };
}
function create_fragment$4(ctx) {
  let popup;
  let current;
  popup = new Popup2({
    props: {
      class: "popup-notification",
      swipeToClose: "to-bottom",
      swipeHandler: ".swipe-handler",
      $$slots: { default: [create_default_slot$4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(popup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(popup, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const popup_changes = {};
      if (dirty & /*$$scope, eventItems*/
      17) {
        popup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      popup.$set(popup_changes);
    },
    i(local) {
      if (current) return;
      transition_in(popup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(popup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(popup, detaching);
    }
  };
}
function instance$4($$self, $$props, $$invalidate) {
  let { eventItems = [] } = $$props;
  $$self.$$set = ($$props2) => {
    if ("eventItems" in $$props2) $$invalidate(0, eventItems = $$props2.eventItems);
  };
  return [eventItems];
}
class EventsNotificationPopup extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4, create_fragment$4, safe_not_equal, { eventItems: 0 });
  }
}
function get_each_context$1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list[i];
  child_ctx[22] = i;
  return child_ctx;
}
function create_default_slot_8(ctx) {
  let linehorizontal3;
  let current;
  linehorizontal3 = new LineHorizontal3({
    props: {
      class: "UI-nav-icons icon-menu-horizontal"
    }
  });
  return {
    c() {
      create_component(linehorizontal3.$$.fragment);
    },
    m(target, anchor) {
      mount_component(linehorizontal3, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current) return;
      transition_in(linehorizontal3.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(linehorizontal3.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(linehorizontal3, detaching);
    }
  };
}
function create_default_slot_7(ctx) {
  let button;
  let current;
  button = new Button({
    props: {
      panelOpen: "left",
      $$slots: { default: [create_default_slot_8] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty & /*$$scope*/
      8388608) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current) return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot_6(ctx) {
  let t_value = (
    /*$i18n*/
    ctx[1].t("ui:home:navTitle") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$i18n*/
      2 && t_value !== (t_value = /*$i18n*/
      ctx2[1].t("ui:home:navTitle") + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_5(ctx) {
  let t_value = (
    /*eventItems*/
    ctx[0].length + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*eventItems*/
      1 && t_value !== (t_value = /*eventItems*/
      ctx2[0].length + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_4$2(ctx) {
  let bell;
  let t2;
  let badge;
  let current;
  bell = new Bell({
    props: { class: "UI-nav-icons icon-bell" }
  });
  badge = new Badge({
    props: {
      class: "UI-badge",
      color: "red",
      $$slots: { default: [create_default_slot_5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(bell.$$.fragment);
      t2 = space();
      create_component(badge.$$.fragment);
    },
    m(target, anchor) {
      mount_component(bell, target, anchor);
      insert(target, t2, anchor);
      mount_component(badge, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const badge_changes = {};
      if (dirty & /*$$scope, eventItems*/
      8388609) {
        badge_changes.$$scope = { dirty, ctx: ctx2 };
      }
      badge.$set(badge_changes);
    },
    i(local) {
      if (current) return;
      transition_in(bell.$$.fragment, local);
      transition_in(badge.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(bell.$$.fragment, local);
      transition_out(badge.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(bell, detaching);
      destroy_component(badge, detaching);
    }
  };
}
function create_default_slot_3$2(ctx) {
  let button;
  let current;
  button = new Button({
    props: {
      class: "UI-btn-popup-notification",
      popupOpen: ".popup-notification",
      $$slots: { default: [create_default_slot_4$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty & /*$$scope, eventItems*/
      8388609) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current) return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot_2$2(ctx) {
  let navleft;
  let t0;
  let navtitle;
  let t1;
  let navright;
  let current;
  navleft = new Nav_left({
    props: {
      $$slots: { default: [create_default_slot_7] },
      $$scope: { ctx }
    }
  });
  navtitle = new Nav_title({
    props: {
      $$slots: { default: [create_default_slot_6] },
      $$scope: { ctx }
    }
  });
  navright = new Nav_right({
    props: {
      $$slots: { default: [create_default_slot_3$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(navleft.$$.fragment);
      t0 = space();
      create_component(navtitle.$$.fragment);
      t1 = space();
      create_component(navright.$$.fragment);
    },
    m(target, anchor) {
      mount_component(navleft, target, anchor);
      insert(target, t0, anchor);
      mount_component(navtitle, target, anchor);
      insert(target, t1, anchor);
      mount_component(navright, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const navleft_changes = {};
      if (dirty & /*$$scope*/
      8388608) {
        navleft_changes.$$scope = { dirty, ctx: ctx2 };
      }
      navleft.$set(navleft_changes);
      const navtitle_changes = {};
      if (dirty & /*$$scope, $i18n*/
      8388610) {
        navtitle_changes.$$scope = { dirty, ctx: ctx2 };
      }
      navtitle.$set(navtitle_changes);
      const navright_changes = {};
      if (dirty & /*$$scope, eventItems*/
      8388609) {
        navright_changes.$$scope = { dirty, ctx: ctx2 };
      }
      navright.$set(navright_changes);
    },
    i(local) {
      if (current) return;
      transition_in(navleft.$$.fragment, local);
      transition_in(navtitle.$$.fragment, local);
      transition_in(navright.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(navleft.$$.fragment, local);
      transition_out(navtitle.$$.fragment, local);
      transition_out(navright.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      destroy_component(navleft, detaching);
      destroy_component(navtitle, detaching);
      destroy_component(navright, detaching);
    }
  };
}
function create_root_start_slot(ctx) {
  let div;
  let div_style_value;
  return {
    c() {
      div = element("div");
      attr(div, "class", "event-color");
      attr(div, "style", div_style_value = `background-color: ${/*item*/
      ctx[20].color}`);
      attr(div, "slot", "root-start");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*eventItems*/
      1 && div_style_value !== (div_style_value = `background-color: ${/*item*/
      ctx2[20].color}`)) {
        attr(div, "style", div_style_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_each_block$1(key_1, ctx) {
  let first;
  let listitem;
  let current;
  listitem = new List_item({
    props: {
      title: (
        /*item*/
        ctx[20].title
      ),
      after: (
        /*item*/
        ctx[20].time
      ),
      $$slots: { "root-start": [create_root_start_slot] },
      $$scope: { ctx }
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(listitem.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(listitem, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const listitem_changes = {};
      if (dirty & /*eventItems*/
      1) listitem_changes.title = /*item*/
      ctx[20].title;
      if (dirty & /*eventItems*/
      1) listitem_changes.after = /*item*/
      ctx[20].time;
      if (dirty & /*$$scope, eventItems*/
      8388609) {
        listitem_changes.$$scope = { dirty, ctx };
      }
      listitem.$set(listitem_changes);
    },
    i(local) {
      if (current) return;
      transition_in(listitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(listitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(listitem, detaching);
    }
  };
}
function create_if_block(ctx) {
  let listitem;
  let current;
  listitem = new List_item({
    props: {
      $$slots: { title: [create_title_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(listitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(listitem, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(listitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(listitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(listitem, detaching);
    }
  };
}
function create_title_slot(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "   .";
      attr(span, "class", "text-color-gray");
      attr(span, "slot", "title");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_default_slot_1$3(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t2;
  let if_block_anchor;
  let current;
  let each_value = ensure_array_like(
    /*eventItems*/
    ctx[0]
  );
  const get_key = (ctx2) => (
    /*index*/
    ctx2[22]
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$1(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$1(key, child_ctx));
  }
  let if_block = (
    /*eventItems*/
    ctx[0].length === 0 && create_if_block(ctx)
  );
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t2 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, t2, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*eventItems*/
      1) {
        each_value = ensure_array_like(
          /*eventItems*/
          ctx2[0]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, t2.parentNode, outro_and_destroy_block, create_each_block$1, t2, get_each_context$1);
        check_outros();
      }
      if (
        /*eventItems*/
        ctx2[0].length === 0
      ) {
        if (if_block) {
          if (dirty & /*eventItems*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(if_block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(if_block_anchor);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_default_slot$3(ctx) {
  let navbar;
  let t0;
  let calendarzswiat;
  let t1;
  let list;
  let t2;
  let eventsnotificationpopup;
  let current;
  navbar = new Navbar({
    props: {
      $$slots: { default: [create_default_slot_2$2] },
      $$scope: { ctx }
    }
  });
  calendarzswiat = new CalendarzSwiat({ props: { events: (
    /*events*/
    ctx[3]
  ) } });
  list = new List({
    props: {
      id: "calendar-events",
      class: "no-margin no-safe-area-left",
      $$slots: { default: [create_default_slot_1$3] },
      $$scope: { ctx }
    }
  });
  eventsnotificationpopup = new EventsNotificationPopup({
    props: { eventItems: (
      /*eventItems*/
      ctx[0]
    ) }
  });
  return {
    c() {
      create_component(navbar.$$.fragment);
      t0 = space();
      create_component(calendarzswiat.$$.fragment);
      t1 = space();
      create_component(list.$$.fragment);
      t2 = space();
      create_component(eventsnotificationpopup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(navbar, target, anchor);
      insert(target, t0, anchor);
      mount_component(calendarzswiat, target, anchor);
      insert(target, t1, anchor);
      mount_component(list, target, anchor);
      insert(target, t2, anchor);
      mount_component(eventsnotificationpopup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const navbar_changes = {};
      if (dirty & /*$$scope, eventItems, $i18n*/
      8388611) {
        navbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      navbar.$set(navbar_changes);
      const list_changes = {};
      if (dirty & /*$$scope, eventItems*/
      8388609) {
        list_changes.$$scope = { dirty, ctx: ctx2 };
      }
      list.$set(list_changes);
      const eventsnotificationpopup_changes = {};
      if (dirty & /*eventItems*/
      1) eventsnotificationpopup_changes.eventItems = /*eventItems*/
      ctx2[0];
      eventsnotificationpopup.$set(eventsnotificationpopup_changes);
    },
    i(local) {
      if (current) return;
      transition_in(navbar.$$.fragment, local);
      transition_in(calendarzswiat.$$.fragment, local);
      transition_in(list.$$.fragment, local);
      transition_in(eventsnotificationpopup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(navbar.$$.fragment, local);
      transition_out(calendarzswiat.$$.fragment, local);
      transition_out(list.$$.fragment, local);
      transition_out(eventsnotificationpopup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
      }
      destroy_component(navbar, detaching);
      destroy_component(calendarzswiat, detaching);
      destroy_component(list, detaching);
      destroy_component(eventsnotificationpopup, detaching);
    }
  };
}
function create_fragment$3(ctx) {
  let page;
  let current;
  page = new Page({
    props: {
      name: "home",
      onPageInit: (
        /*onPageInit*/
        ctx[4]
      ),
      onPageBeforeRemove: (
        /*onPageBeforeRemove*/
        ctx[5]
      ),
      $$slots: { default: [create_default_slot$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(page.$$.fragment);
    },
    m(target, anchor) {
      mount_component(page, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const page_changes = {};
      if (dirty & /*$$scope, eventItems, $i18n*/
      8388611) {
        page_changes.$$scope = { dirty, ctx: ctx2 };
      }
      page.$set(page_changes);
    },
    i(local) {
      if (current) return;
      transition_in(page.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(page.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(page, detaching);
    }
  };
}
function instance$3($$self, $$props, $$invalidate) {
  let $i18n;
  const i18n2 = getContext("i18n");
  component_subscribe($$self, i18n2, (value2) => $$invalidate(1, $i18n = value2));
  let lng = $i18n.language;
  $i18n.t("debugmsg:debug:langDefault");
  const date = /* @__PURE__ */ new Date();
  const year = date.getFullYear();
  const month = date.getMonth();
  const day = date.getDate();
  const today = new Date(year, month, day);
  let events = [];
  let eventItems = [];
  let monthNames = [];
  let daysNames = [];
  let SPEventsCalendar;
  function renderEvents(SPEventsCalendar2) {
    const currentDate = SPEventsCalendar2.value[0];
    const currentEvents = events.filter((event) => event.date.getTime() >= currentDate.getTime() && event.date.getTime() < currentDate.getTime() + 24 * 60 * 60 * 1e3);
    const newEventItems = [];
    if (currentEvents.length) {
      currentEvents.forEach((event) => {
        const hours = event.hours;
        let minutes = event.minutes;
        if (minutes < 10) minutes = `0${minutes}`;
        newEventItems.push({
          title: event.title,
          time: `${hours}:${minutes}`,
          color: event.color
        });
      });
    }
    $$invalidate(0, eventItems = newEventItems);
    $i18n.on("languageChanged", (changed) => {
      if (changed) {
        eventItems.splice(0, eventItems.length);
        renderEvents(SPEventsCalendar2);
      }
    });
  }
  function renderMonthNameLocales(arr) {
    let newArrCollection = [];
    arr.forEach((obj) => {
      newArrCollection.push(obj);
    });
    monthNames = [...newArrCollection];
  }
  function renderDaysNameLocales(arr) {
    let newArrCollection = [];
    arr.forEach((obj) => {
      newArrCollection.push(obj);
    });
    daysNames = [...newArrCollection];
  }
  function dynamicDateGenerator(value2 = lng) {
    switch (value2) {
      case "ru":
        renderMonthNameLocales(resources.ru.ui.calendar.months);
        renderDaysNameLocales(resources.ru.ui.calendar.days);
        break;
      case "en":
        renderMonthNameLocales(resources.en.ui.calendar.months);
        renderDaysNameLocales(resources.en.ui.calendar.days);
        break;
      default:
        renderMonthNameLocales(resources.ru.ui.calendar.months);
        renderDaysNameLocales(resources.ru.ui.calendar.days);
    }
    $i18n.on("languageChanged", (changed) => {
      $i18n.t("debugmsg:debug:onLanguageChangedMsg");
      dynamicDateGenerator(changed);
      $i18n.t("debugmsg:debug:calendar:monthAfterLangChanged");
    });
  }
  dynamicDateGenerator();
  function onPageInit() {
    const $$ = f7.$;
    SPEventsCalendar = f7.calendar.create({
      containerEl: "#calendar-container",
      locale: lng,
      firstDay: 1,
      value: [today],
      events,
      renderToolbar() {
        return `
          <div class="toolbar calendar-custom-toolbar">
            <div class="toolbar-inner">
              <div class="left">
                <a  class="link icon-only"><i class="icon icon-back"></i></a>
              </div>
              <div class="center"></div>
              <div class="right">
                <a  class="link icon-only"><i class="icon icon-forward"></i></a>
              </div>
            </div>
          </div>
        `.trim();
      },
      on: {
        init(SPEventsCalendar2) {
          $$(".calendar-custom-toolbar .center").text(`${monthNames[SPEventsCalendar2.currentMonth]}, ${SPEventsCalendar2.currentYear}`);
          $$(".calendar-custom-toolbar .left .link").on("click", () => {
            SPEventsCalendar2.prevMonth(300);
          });
          $$(".calendar-custom-toolbar .right .link").on("click", () => {
            SPEventsCalendar2.nextMonth(300);
          });
          $i18n.on("languageChanged", (changed) => {
            if (changed) {
              $$(".calendar-custom-toolbar .center").text(`${monthNames[SPEventsCalendar2.currentMonth]}, ${SPEventsCalendar2.currentYear}`);
              $$(".calendar-week-day").forEach((el, index2) => {
                el.innerText = daysNames[index2];
              });
            }
          });
          renderEvents(SPEventsCalendar2);
        },
        monthYearChangeStart(SPEventsCalendar2) {
          $$(".calendar-custom-toolbar .center").text(`${monthNames[SPEventsCalendar2.currentMonth]}, ${SPEventsCalendar2.currentYear}`);
        },
        change(SPEventsCalendar2) {
          renderEvents(SPEventsCalendar2);
        }
      }
    });
  }
  function onPageBeforeRemove() {
    SPEventsCalendar.destroy();
  }
  return [eventItems, $i18n, i18n2, events, onPageInit, onPageBeforeRemove];
}
class Home extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3, create_fragment$3, safe_not_equal, {});
  }
}
function create_default_slot_4$1(ctx) {
  let t_value = (
    /*$i18n*/
    ctx[0].t("ui:about:navTitle") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$i18n*/
      1 && t_value !== (t_value = /*$i18n*/
      ctx2[0].t("ui:about:navTitle") + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_3$1(ctx) {
  let navleft;
  let t2;
  let navtitle;
  let current;
  navleft = new Nav_left({ props: { backLink: "back" } });
  navtitle = new Nav_title({
    props: {
      $$slots: { default: [create_default_slot_4$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(navleft.$$.fragment);
      t2 = space();
      create_component(navtitle.$$.fragment);
    },
    m(target, anchor) {
      mount_component(navleft, target, anchor);
      insert(target, t2, anchor);
      mount_component(navtitle, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const navtitle_changes = {};
      if (dirty & /*$$scope, $i18n*/
      5) {
        navtitle_changes.$$scope = { dirty, ctx: ctx2 };
      }
      navtitle.$set(navtitle_changes);
    },
    i(local) {
      if (current) return;
      transition_in(navleft.$$.fragment, local);
      transition_in(navtitle.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(navleft.$$.fragment, local);
      transition_out(navtitle.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(navleft, detaching);
      destroy_component(navtitle, detaching);
    }
  };
}
function create_default_slot_2$1(ctx) {
  let t_value = (
    /*$i18n*/
    ctx[0].t("ui:about:blockTitle") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$i18n*/
      1 && t_value !== (t_value = /*$i18n*/
      ctx2[0].t("ui:about:blockTitle") + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_1$2(ctx) {
  let p;
  let t_value = (
    /*$i18n*/
    ctx[0].t("ui:about:description") + ""
  );
  let t2;
  return {
    c() {
      p = element("p");
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*$i18n*/
      1 && t_value !== (t_value = /*$i18n*/
      ctx2[0].t("ui:about:description") + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_default_slot$2(ctx) {
  let navbar;
  let t0;
  let blocktitle;
  let t1;
  let block;
  let current;
  navbar = new Navbar({
    props: {
      $$slots: { default: [create_default_slot_3$1] },
      $$scope: { ctx }
    }
  });
  blocktitle = new Block_title({
    props: {
      medium: true,
      $$slots: { default: [create_default_slot_2$1] },
      $$scope: { ctx }
    }
  });
  block = new Block({
    props: {
      strongIos: true,
      outlineIos: true,
      $$slots: { default: [create_default_slot_1$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(navbar.$$.fragment);
      t0 = space();
      create_component(blocktitle.$$.fragment);
      t1 = space();
      create_component(block.$$.fragment);
    },
    m(target, anchor) {
      mount_component(navbar, target, anchor);
      insert(target, t0, anchor);
      mount_component(blocktitle, target, anchor);
      insert(target, t1, anchor);
      mount_component(block, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const navbar_changes = {};
      if (dirty & /*$$scope, $i18n*/
      5) {
        navbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      navbar.$set(navbar_changes);
      const blocktitle_changes = {};
      if (dirty & /*$$scope, $i18n*/
      5) {
        blocktitle_changes.$$scope = { dirty, ctx: ctx2 };
      }
      blocktitle.$set(blocktitle_changes);
      const block_changes = {};
      if (dirty & /*$$scope, $i18n*/
      5) {
        block_changes.$$scope = { dirty, ctx: ctx2 };
      }
      block.$set(block_changes);
    },
    i(local) {
      if (current) return;
      transition_in(navbar.$$.fragment, local);
      transition_in(blocktitle.$$.fragment, local);
      transition_in(block.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(navbar.$$.fragment, local);
      transition_out(blocktitle.$$.fragment, local);
      transition_out(block.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      destroy_component(navbar, detaching);
      destroy_component(blocktitle, detaching);
      destroy_component(block, detaching);
    }
  };
}
function create_fragment$2(ctx) {
  let page;
  let current;
  page = new Page({
    props: {
      name: "about",
      $$slots: { default: [create_default_slot$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(page.$$.fragment);
    },
    m(target, anchor) {
      mount_component(page, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const page_changes = {};
      if (dirty & /*$$scope, $i18n*/
      5) {
        page_changes.$$scope = { dirty, ctx: ctx2 };
      }
      page.$set(page_changes);
    },
    i(local) {
      if (current) return;
      transition_in(page.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(page.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(page, detaching);
    }
  };
}
function instance$2($$self, $$props, $$invalidate) {
  let $i18n;
  const i18n2 = getContext("i18n");
  component_subscribe($$self, i18n2, (value2) => $$invalidate(0, $i18n = value2));
  return [$i18n, i18n2];
}
class About extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2, create_fragment$2, safe_not_equal, {});
  }
}
const routes = [
  {
    path: "/",
    component: Home,
    master: true
  },
  {
    path: "/about/",
    component: About
  }
];
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  return child_ctx;
}
function create_each_block(ctx) {
  let option;
  let t0_value = (
    /*lng*/
    ctx[7] + ""
  );
  let t0;
  let t1;
  return {
    c() {
      option = element("option");
      t0 = text(t0_value);
      t1 = space();
      option.__value = /*lng*/
      ctx[7];
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t0);
      append(option, t1);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_default_slot_1$1(ctx) {
  let select;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*locales*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  return {
    c() {
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      if (
        /*selected*/
        ctx[0] === void 0
      ) add_render_callback(() => (
        /*select_change_handler*/
        ctx[5].call(select)
      ));
    },
    m(target, anchor) {
      insert(target, select, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(
        select,
        /*selected*/
        ctx[0],
        true
      );
      if (!mounted) {
        dispose = [
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[5]
          ),
          listen(
            select,
            "change",
            /*i18nSelectHandler*/
            ctx[4]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*locales*/
      4) {
        each_value = ensure_array_like(
          /*locales*/
          ctx2[2]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*selected, locales*/
      5) {
        select_option(
          select,
          /*selected*/
          ctx2[0]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(select);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_default_slot$1(ctx) {
  let listitem;
  let current;
  listitem = new List_item({
    props: {
      title: (
        /*$i18n*/
        ctx[1].t("ui:langswitcher:title")
      ),
      smartSelect: true,
      smartSelectParams: { openIn: "popover" },
      $$slots: { default: [create_default_slot_1$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(listitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(listitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const listitem_changes = {};
      if (dirty & /*$i18n*/
      2) listitem_changes.title = /*$i18n*/
      ctx2[1].t("ui:langswitcher:title");
      if (dirty & /*$$scope, selected*/
      1025) {
        listitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      listitem.$set(listitem_changes);
    },
    i(local) {
      if (current) return;
      transition_in(listitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(listitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(listitem, detaching);
    }
  };
}
function create_fragment$1(ctx) {
  let list;
  let current;
  list = new List({
    props: {
      strongIos: true,
      outlineIos: true,
      dividersIos: true,
      $$slots: { default: [create_default_slot$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(list.$$.fragment);
    },
    m(target, anchor) {
      mount_component(list, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const list_changes = {};
      if (dirty & /*$$scope, $i18n, selected*/
      1027) {
        list_changes.$$scope = { dirty, ctx: ctx2 };
      }
      list.$set(list_changes);
    },
    i(local) {
      if (current) return;
      transition_in(list.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(list.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(list, detaching);
    }
  };
}
function instance$1($$self, $$props, $$invalidate) {
  let $i18n;
  const translations = { ru: "Ru", en: "En" };
  const locales = Object.keys(translations);
  const i18n2 = getContext("i18n");
  component_subscribe($$self, i18n2, (value2) => $$invalidate(1, $i18n = value2));
  let selected = $i18n.language;
  const i18nSelectHandler = () => {
    selected !== void 0 ? $i18n.changeLanguage(selected) : selected;
  };
  function select_change_handler() {
    selected = select_value(this);
    $$invalidate(0, selected);
    $$invalidate(2, locales);
  }
  return [selected, $i18n, locales, i18n2, i18nSelectHandler, select_change_handler];
}
class LangSwitcher extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1, create_fragment$1, safe_not_equal, {});
  }
}
function create_default_slot_4(ctx) {
  let t_value = (
    /*$i18n*/
    ctx[0].t("ui:panel:navTitle") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$i18n*/
      1 && t_value !== (t_value = /*$i18n*/
      ctx2[0].t("ui:panel:navTitle") + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_media_slot(ctx) {
  let question;
  let current;
  question = new Question({
    props: {
      class: "UI-panel-icons icon-question",
      slot: "media"
    }
  });
  return {
    c() {
      create_component(question.$$.fragment);
    },
    m(target, anchor) {
      mount_component(question, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current) return;
      transition_in(question.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(question.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(question, detaching);
    }
  };
}
function create_default_slot_3(ctx) {
  let listitem;
  let current;
  listitem = new List_item({
    props: {
      link: "/about/",
      title: (
        /*$i18n*/
        ctx[0].t("ui:panel:navAbout")
      ),
      panelClose: true,
      $$slots: { media: [create_media_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(listitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(listitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const listitem_changes = {};
      if (dirty & /*$i18n*/
      1) listitem_changes.title = /*$i18n*/
      ctx2[0].t("ui:panel:navAbout");
      if (dirty & /*$$scope*/
      8) {
        listitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      listitem.$set(listitem_changes);
    },
    i(local) {
      if (current) return;
      transition_in(listitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(listitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(listitem, detaching);
    }
  };
}
function create_default_slot_2(ctx) {
  let blocktitle;
  let t0;
  let langswitcher;
  let t1;
  let list;
  let current;
  blocktitle = new Block_title({
    props: {
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    }
  });
  langswitcher = new LangSwitcher({});
  list = new List({
    props: {
      outlineIos: true,
      strongIos: true,
      menuList: true,
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(blocktitle.$$.fragment);
      t0 = space();
      create_component(langswitcher.$$.fragment);
      t1 = space();
      create_component(list.$$.fragment);
    },
    m(target, anchor) {
      mount_component(blocktitle, target, anchor);
      insert(target, t0, anchor);
      mount_component(langswitcher, target, anchor);
      insert(target, t1, anchor);
      mount_component(list, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const blocktitle_changes = {};
      if (dirty & /*$$scope, $i18n*/
      9) {
        blocktitle_changes.$$scope = { dirty, ctx: ctx2 };
      }
      blocktitle.$set(blocktitle_changes);
      const list_changes = {};
      if (dirty & /*$$scope, $i18n*/
      9) {
        list_changes.$$scope = { dirty, ctx: ctx2 };
      }
      list.$set(list_changes);
    },
    i(local) {
      if (current) return;
      transition_in(blocktitle.$$.fragment, local);
      transition_in(langswitcher.$$.fragment, local);
      transition_in(list.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(blocktitle.$$.fragment, local);
      transition_out(langswitcher.$$.fragment, local);
      transition_out(list.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      destroy_component(blocktitle, detaching);
      destroy_component(langswitcher, detaching);
      destroy_component(list, detaching);
    }
  };
}
function create_default_slot_1(ctx) {
  let navbar;
  let t2;
  let block;
  let current;
  navbar = new Navbar({
    props: {
      title: (
        /*$i18n*/
        ctx[0].t("ui:panel:title")
      )
    }
  });
  block = new Block({
    props: {
      strong: true,
      inset: true,
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(navbar.$$.fragment);
      t2 = space();
      create_component(block.$$.fragment);
    },
    m(target, anchor) {
      mount_component(navbar, target, anchor);
      insert(target, t2, anchor);
      mount_component(block, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const navbar_changes = {};
      if (dirty & /*$i18n*/
      1) navbar_changes.title = /*$i18n*/
      ctx2[0].t("ui:panel:title");
      navbar.$set(navbar_changes);
      const block_changes = {};
      if (dirty & /*$$scope, $i18n*/
      9) {
        block_changes.$$scope = { dirty, ctx: ctx2 };
      }
      block.$set(block_changes);
    },
    i(local) {
      if (current) return;
      transition_in(navbar.$$.fragment, local);
      transition_in(block.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(navbar.$$.fragment, local);
      transition_out(block.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(navbar, detaching);
      destroy_component(block, detaching);
    }
  };
}
function create_default_slot(ctx) {
  let view;
  let t2;
  let panel;
  let current;
  view = new View2({ props: { main: true, url: "/" } });
  panel = new Panel2({
    props: {
      left: true,
      floating: true,
      cover: true,
      containerEl: "#app",
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(view.$$.fragment);
      t2 = space();
      create_component(panel.$$.fragment);
    },
    m(target, anchor) {
      mount_component(view, target, anchor);
      insert(target, t2, anchor);
      mount_component(panel, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const panel_changes = {};
      if (dirty & /*$$scope, $i18n*/
      9) {
        panel_changes.$$scope = { dirty, ctx: ctx2 };
      }
      panel.$set(panel_changes);
    },
    i(local) {
      if (current) return;
      transition_in(view.$$.fragment, local);
      transition_in(panel.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(view.$$.fragment, local);
      transition_out(panel.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(view, detaching);
      destroy_component(panel, detaching);
    }
  };
}
function create_fragment(ctx) {
  let app2;
  let current;
  const app_spread_levels = [
    /*f7params*/
    ctx[1]
  ];
  let app_props = {
    $$slots: { default: [create_default_slot] },
    $$scope: { ctx }
  };
  for (let i = 0; i < app_spread_levels.length; i += 1) {
    app_props = assign(app_props, app_spread_levels[i]);
  }
  app2 = new App({ props: app_props });
  return {
    c() {
      create_component(app2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(app2, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const app_changes = dirty & /*f7params*/
      2 ? get_spread_update(app_spread_levels, [get_spread_object(
        /*f7params*/
        ctx2[1]
      )]) : {};
      if (dirty & /*$$scope, $i18n*/
      9) {
        app_changes.$$scope = { dirty, ctx: ctx2 };
      }
      app2.$set(app_changes);
    },
    i(local) {
      if (current) return;
      transition_in(app2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(app2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(app2, detaching);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let $i18n;
  component_subscribe($$self, i18n, ($$value) => $$invalidate(0, $i18n = $$value));
  setContext("i18n", i18n);
  const f7params = {
    name: "Kalendarz Swiat",
    // -> App name
    theme: "auto",
    // -> Automatic theme detection
    // App routes
    routes
  };
  const debugMsg = $i18n.t("debugmsg:debug:app:localesChecking");
  debug(debugMsg, $i18n.t("ui:panel:navTitle"));
  return [$i18n, f7params];
}
class App_1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, {});
  }
}
Framework7.use([Framework7Svelte, Popup$1, PopoverComponent, PopoverComponent, SmartSelectComponent, Panel$1, PickerComponent, Calendar2]);
new App_1({
  target: document.getElementById("app")
});
